<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>源码分析之Handler、Looper及MessageQueue之间关系</title>
      <link href="/FuckCode/2019/04/09/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHandler%E3%80%81Looper%E5%8F%8AMessageQueue%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB/"/>
      <url>/FuckCode/2019/04/09/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHandler%E3%80%81Looper%E5%8F%8AMessageQueue%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>在 Android 的应用开发中，线程之间的通信机制主要是以 Handler 机制为主。我们都知道 Android 中的 UI 更新只能在主线程中执行，通常的做法是，我们在 Activity 中直接 new Handler，通过 handler 发送消息，在 handlerMessage 处理即可。本篇博文就根据源码来具体分析其中工作机制以及源码架构。</strong><br><a id="more"></a></p><h1 id="Java-层的三巨头"><a href="#Java-层的三巨头" class="headerlink" title="Java 层的三巨头"></a>Java 层的三巨头</h1><p>上层的 Java 代码，集中于以下三个类，Handler，Looper 以及 MessageQueue，下面我们集中分析它们。</p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>我们通常都会在 Activity 中直接新建 Handler 来实现主线程下 UI 的更新。我们思考一下为什么直接新建的 handler 便可以更新 UI，默认为主线程呢？（直接新建 Handler 可以更新 UI，但是涉及到 Activity 生命周期以及复杂的逻辑延时处理等，此处建议以弱引用、虚引用方式持有对象，否则在延时处理中，Activity 已经销毁了，才反过来处理消息必定会发生崩溃）。</p><h3 id="Handler-与-Looper-的绑定"><a href="#Handler-与-Looper-的绑定" class="headerlink" title="Handler 与 Looper 的绑定"></a>Handler 与 Looper 的绑定</h3><p>我们都知道 Activity 由 ActivityThread 启动，之后会调用 ActivityThread 的 main 函数，其内部有如下代码：</p><pre><code>public static void main(String[] args) {    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);    SamplingProfilerIntegration.start();    // CloseGuard defaults to true and can be quite spammy.  We    // disable it here, but selectively enable it later (via    // StrictMode) on debug builds, but using DropBox, not logs.    CloseGuard.setEnabled(false);    Environment.initForCurrentUser();    // Set the reporter for event logging in libcore    EventLogger.setReporter(new EventLoggingReporter());    AndroidKeyStoreProvider.install();    // Make sure TrustedCertificateStore looks in the right place for CA certificates    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());    TrustedCertificateStore.setDefaultUserDirectory(configDir);    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);    // 创建主线程 looper,只创建一次    Looper.prepareMainLooper();    ActivityThread thread = new ActivityThread();    // attach到系统进程    thread.attach(false);    if (sMainThreadHandler == null) {        sMainThreadHandler = thread.getHandler();    }    if (false) {        Looper.myLooper().setMessageLogging(new                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));    }    // End of event ActivityThreadMain.    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);    // 主线程进入循环状态    Looper.loop();    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);}</code></pre><p>由此可见，Activity 中已经默认给我们创建了 Looper 轮训器。此时我们直接可以使用 Handler 机制进行消息通信了。</p><p>下面我们来看 prepareMainLooper</p><pre><code>public static void prepareMainLooper() {    prepare(false);    synchronized (Looper.class) {        if (sMainLooper != null) {            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);        }        sMainLooper = myLooper();    }}</code></pre><p>此处我们看到，直接调用 prepare，注意参数 false，之后调用 sMainLooper = myLooper()，将内部 sMainLooper 赋值，及主线程 looper 循环器。</p><pre><code>private static void prepare(boolean quitAllowed) {    if (sThreadLocal.get() != null) {        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);    }    sThreadLocal.set(new Looper(quitAllowed));}</code></pre><p>此处最后通过线程本地存储 sThreadLocal 新建 Looper 对象并设置进去。sMainLooper 获取就是这个对象。</p><pre><code>private Looper(boolean quitAllowed) {    mQueue = new MessageQueue(quitAllowed);    mThread = Thread.currentThread();}</code></pre><p>此处在 Looper 的构造函数中，新建了 MessageQueue 对象。这样，在应用 Activity 启动之时，Looper 与 MessageQueue就已经被系统分配完毕，后续我们直接使用即可，此处的分析暂时告一段落。</p><h3 id="Handler-实例化"><a href="#Handler-实例化" class="headerlink" title="Handler 实例化"></a>Handler 实例化</h3><p>Handler 拥有多个构造函数，我们在 Activity 中直接使用的 Handler 为默认的构造函数，如下：</p><pre><code>// 默认的构造函数 public Handler() {    this(null, false);}// 参数为 null，falsepublic Handler(Callback callback, boolean async) {    if (FIND_POTENTIAL_LEAKS) {        final Class&lt;? extends Handler&gt; klass = getClass();        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +                klass.getCanonicalName());        }    }    // 直接从 Looper 中获取 mLooper 对象    mLooper = Looper.myLooper();    if (mLooper == null) {        throw new RuntimeException(            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);    }    // Looper 创建即产生了 MessageQueue    mQueue = mLooper.mQueue;    mCallback = callback;    mAsynchronous = async;}</code></pre><p>有上面分析，此处直接获取了 mLooper 对象，由于在 Activity 之前调用了 Looper.prepareMainLooper() 函数，之前分析可以得知，此处获取的便是 sMainLooper 轮训器。Looper 创建之时便已经 与 MessageQueue 建立联系，此处直接可以获取消息队列 mQueue。</p><h3 id="Handler-获取消息"><a href="#Handler-获取消息" class="headerlink" title="Handler 获取消息"></a>Handler 获取消息</h3><p>Handler 内部维持了一个消息池，我们通过 obtainMessage 便可以获取一个消息实例 Message。obtainMessage 重载了很多方法，最终走向 Message.obtain 中去，Message.obtain 中根据多种参数的重载，最终指向了内部方法 obtain()。</p><pre><code>public static Message obtain() {    synchronized (sPoolSync) {        if (sPool != null) {            Message m = sPool;            sPool = m.next;            m.next = null;            m.flags = 0; // clear in-use flag            sPoolSize--;            return m;        }    }    return new Message();}</code></pre><p>此方法原译注释 </p><p><strong>Return a new Message instance from the global pool. Allows us to avoid allocating new objects in many cases.</strong></p><p>译文为：从全局池返回新的消息实例。允许我们在许多情况下避免分配新对象。</p><p>由此可见我们通过此方法可以避免自己 new Message，直接是使用提供的接口获取。减少分配对象造成的内存消耗。</p><p>关于 Message 内更多具体的分析，可以参考一下博文</p><p><a href="https://blog.csdn.net/xmh19936688/article/details/51901338" target="_blank" rel="noopener">Message详细解析</a></p><h3 id="Handler-发送消息、Runnable以及取消"><a href="#Handler-发送消息、Runnable以及取消" class="headerlink" title="Handler 发送消息、Runnable以及取消"></a>Handler 发送消息、Runnable以及取消</h3><p>通过 Handler 对象 send<em>Message</em>，或者 post* runnable 都可以，其内部方法重载众多，我们直接追溯根源，其最终调用到 enqueueMessage 方法，期间涉及延迟等不作过多分析。</p><pre><code>private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {    msg.target = this;    if (mAsynchronous) {        msg.setAsynchronous(true);    }    return queue.enqueueMessage(msg, uptimeMillis);}</code></pre><p>代码可以看出，最终还是通过内部持有对象 MessageQueue queue 的 enqueueMessage 方法来实现。其内部具体逻辑由后面的 MessageQueue 章节具体分析。</p><p>通过 removeMessages 方法即可取消一个消息，通过 removeCallbacksAndMessages 可取消一个 Callback，其最终实现代码再后面章节中具体分析。</p><pre><code>public final void removeMessages(int what, Object object) {    mQueue.removeMessages(this, what, object);}public final void removeCallbacksAndMessages(Object token) {    mQueue.removeCallbacksAndMessages(this, token);}</code></pre><p>从上面分析我们可以得知为什么我们可以拿来主义，直接使用了 Handler，原因是在应用启动之后，系统已经自动帮我们完成了 Looper 以及 MessageQueue 的创建。</p><h3 id="Handler-处理消息"><a href="#Handler-处理消息" class="headerlink" title="Handler 处理消息"></a>Handler 处理消息</h3><p>Handler 内部对消息的处理进行了一定程度的划分，如下代码：</p><pre><code>public void handleMessage(Message msg) {}public void dispatchMessage(Message msg) {    // 首先调用消息中的 callback 回调    if (msg.callback != null) {        handleCallback(msg);    } else {        // 然后检查 Handler 中是否存在 mCallback，回调        if (mCallback != null) {            if (mCallback.handleMessage(msg)) {                return;            }        }        // 最后调用 Handler 自身的 handleMessage        handleMessage(msg);    }}</code></pre><p>其接口 handleMessage 由用户自己实现，dispatchMessage 为系统内部默认的处理方式，根据消息内容作不同的处理。</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>Looper 我们可以称其为消息轮训器，其主要的工作是不断的读取 MessageQueue 内部的消息，取到之后便交给 Handler 来处理。</p><p>之前在 handler 中我们分析了其绑定过程，其调用的 prepareMainLooper 方法只能在主线程中调用一个，我们开发者使用时候不可以直接调用，下面我们用代码来说明。</p><h3 id="Looper-的使用"><a href="#Looper-的使用" class="headerlink" title="Looper 的使用"></a>Looper 的使用</h3><p>Looper 内部有一个静态变量 sThreadLocal，其具有单例唯一性。</p><pre><code>static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</code></pre><p>此时，如果你在主线程中调用了 prepare，那么你将会收到一个RuntimeException，代码中如下：</p><pre><code>public static void prepare() {    prepare(true);}private static void prepare(boolean quitAllowed) {    if (sThreadLocal.get() != null) {        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);    }    sThreadLocal.set(new Looper(quitAllowed));}</code></pre><p>我们如果要在一个线程中使用 Looper，我们只需要做以下几步即可：</p><ol><li>调用 prepare 初始化 Looper 对象</li><li>调用 loop 方法，启动 Looper 消息轮训</li><li>处理 Handler 的 handlerMessage 方法</li><li>调用 quit，停止 Lopper 轮训工作</li></ol><h3 id="Looper-构造"><a href="#Looper-构造" class="headerlink" title="Looper 构造"></a>Looper 构造</h3><p>Looper 的构造函数，在 prepare 方法中就已经实现了，sThreadLocal.set(new Looper(quitAllowed))，具体代码如下：</p><pre><code>private Looper(boolean quitAllowed) {    mQueue = new MessageQueue(quitAllowed);    mThread = Thread.currentThread();}</code></pre><h3 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h3><p>prepare 方法用于初始化创建一个 Looper，内部新建 Looper 对象，其还会创建 MessageQueue 对象，与其绑定，完成消息队列与轮训的双重工作。具体代码见上。</p><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>loop 使得 Looper 轮训器开始工作，不断检测 MessageQueue 内部是否存在消息需要处理，代码如下：</p><pre><code>public static void loop() {    final Looper me = myLooper();    if (me == null) {        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);    }    // 获取 loop 轮训器的消息队列 MessageQueue    final MessageQueue queue = me.mQueue;    // Make sure the identity of this thread is that of the local process,    // and keep track of what that identity token actually is.    Binder.clearCallingIdentity();    final long ident = Binder.clearCallingIdentity();    // 无限循环    for (;;) {        // 调用 MessageQueue 的 next 获取下一条消息        Message msg = queue.next(); // might block        if (msg == null) {            // No message indicates that the message queue is quitting.            return;        }        // This must be in a local variable, in case a UI event sets the logger        Printer logging = me.mLogging;        if (logging != null) {            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +                    msg.callback + &quot;: &quot; + msg.what);        }        // 分发消息，msg.target 为 msg 所依赖的 Handler对象        msg.target.dispatchMessage(msg);        if (logging != null) {            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);        }        // Make sure that during the course of dispatching the        // identity of the thread wasn&apos;t corrupted.        final long newIdent = Binder.clearCallingIdentity();        if (ident != newIdent) {            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;                    + Long.toHexString(ident) + &quot; to 0x&quot;                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;                    + msg.target.getClass().getName() + &quot; &quot;                    + msg.callback + &quot; what=&quot; + msg.what);        }        // 回收消息资源        msg.recycleUnchecked();    }}</code></pre><p>代码中我们可以看出，这里在无限循环中，通过 queue.next() 不断获取消息，得到的消息便调用 msg.target.dispatchMessage(msg) 将消息交与其 handler 进行处理，最终在将 msg 消息资源进行回收。</p><h3 id="quit"><a href="#quit" class="headerlink" title="quit"></a>quit</h3><p>通过 quit 即可停止 Looper 的工作，逻辑很简单，调用 MessageQueue 的 quit，其包含普通退出和安全退出</p><pre><code>public void quit() {    mQueue.quit(false);}public void quitSafely() {    mQueue.quit(true);}</code></pre><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>MessageQueue 为消息队列，承载 Message 对象的结构。其可以安排 Messgae 的插入，删除，查找，退出等。我们分别来看一下其内部结构。</p><h3 id="MessageQueue-的初始化"><a href="#MessageQueue-的初始化" class="headerlink" title="MessageQueue 的初始化"></a>MessageQueue 的初始化</h3><p>Java 层的 MessageQueue 初始化，直接走向 Native 层，通过 JNI 指向 Native 层，后续分析 Native 层的逻辑。</p><pre><code>MessageQueue(boolean quitAllowed) {    mQuitAllowed = quitAllowed;    // 调用 native 层，对应于 android_os_MessageQueue.cpp    mPtr = nativeInit();}</code></pre><h3 id="enqueueMessage-发送消息"><a href="#enqueueMessage-发送消息" class="headerlink" title="enqueueMessage 发送消息"></a>enqueueMessage 发送消息</h3><p>Java 层的 Handler 通过 send*Mesage 等通过 MessageQueue 内部方法 enqueueMessage 来发送消息，代码如下：</p><pre><code>boolean enqueueMessage(Message msg, long when) {    if (msg.target == null) {        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);    }    if (msg.isInUse()) {        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);    }    synchronized (this) {        // 退出轮训        if (mQuitting) {            IllegalStateException e = new IllegalStateException(                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);            Log.w(TAG, e.getMessage(), e);            // 回收资源            msg.recycle();            return false;        }        msg.markInUse();        msg.when = when;        Message p = mMessages;        boolean needWake;        if (p == null || when == 0 || when &lt; p.when) {            // New head, wake up the event queue if blocked.            msg.next = p;            mMessages = msg;            needWake = mBlocked;        } else {            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake            // up the event queue unless there is a barrier at the head of the queue            // and the message is the earliest asynchronous message in the queue.            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();            Message prev;            // 找到合适的位置，添加 msg 到队列中去            for (;;) {                prev = p;                p = p.next;                if (p == null || when &lt; p.when) {                    break;                }                if (needWake &amp;&amp; p.isAsynchronous()) {                    needWake = false;                }            }            msg.next = p; // invariant: p == prev.next            prev.next = msg;        }        // We can assume mPtr != 0 because mQuitting is false.        // 需要唤醒操作，Native 操作        if (needWake) {            nativeWake(mPtr);        }    }    return true;}</code></pre><p>MessageQueue 通过 enqueueMessage 将 msg 封装到队列中去，之后如果需要唤醒，便会调用 nativeWake 进行唤醒。</p><h3 id="next-获取消息"><a href="#next-获取消息" class="headerlink" title="next 获取消息"></a>next 获取消息</h3><p>Looper 消息轮训器通过无限循环调用 MessageQueue 的 next方法，不断获取消息并处理，代码如下：</p><pre><code>Message next() {    // Return here if the message loop has already quit and been disposed.    // This can happen if the application tries to restart a looper after quit    // which is not supported.    final long ptr = mPtr;    if (ptr == 0) {        return null;    }    int pendingIdleHandlerCount = -1; // -1 only during first iteration    int nextPollTimeoutMillis = 0;    // 无限循环    for (;;) {        if (nextPollTimeoutMillis != 0) {            Binder.flushPendingCommands();        }        // 调用 Native 层的 nativePollOnce        nativePollOnce(ptr, nextPollTimeoutMillis);        synchronized (this) {            // Try to retrieve the next message.  Return if found.            final long now = SystemClock.uptimeMillis();            Message prevMsg = null;            Message msg = mMessages;            // 异步消息            if (msg != null &amp;&amp; msg.target == null) {                // Stalled by a barrier.  Find the next asynchronous message in the queue.                do {                    prevMsg = msg;                    msg = msg.next;                } while (msg != null &amp;&amp; !msg.isAsynchronous());            }            if (msg != null) {                // 延迟消息处理                if (now &lt; msg.when) {                    // Next message is not ready.  Set a timeout to wake up when it is ready.                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                } else {                    // Got a message.                    // 获取消息并返回                    mBlocked = false;                    if (prevMsg != null) {                        prevMsg.next = msg.next;                    } else {                        mMessages = msg.next;                    }                    msg.next = null;                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);                    msg.markInUse();                    return msg;                }            } else {                // No more messages.                nextPollTimeoutMillis = -1;            }            // Process the quit message now that all pending messages have been handled.            if (mQuitting) {                dispose();                return null;            }            // If first time idle, then get the number of idlers to run.            // Idle handles only run if the queue is empty or if the first message            // in the queue (possibly a barrier) is due to be handled in the future.            if (pendingIdleHandlerCount &lt; 0                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {                pendingIdleHandlerCount = mIdleHandlers.size();            }            if (pendingIdleHandlerCount &lt;= 0) {                // No idle handlers to run.  Loop and wait some more.                mBlocked = true;                continue;            }            if (mPendingIdleHandlers == null) {                // 最大空闲线程                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];            }            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);        }        // Run the idle handlers.        // We only ever reach this code block during the first iteration.        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {            final IdleHandler idler = mPendingIdleHandlers[i];            mPendingIdleHandlers[i] = null; // release the reference to the handler            boolean keep = false;            try {                // 调用空闲线程 handler 的 queueIdle                keep = idler.queueIdle();            } catch (Throwable t) {                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);            }            if (!keep) {                synchronized (this) {                    mIdleHandlers.remove(idler);                }            }        }        // Reset the idle handler count to 0 so we do not run them again.        pendingIdleHandlerCount = 0;        // While calling an idle handler, a new message could have been delivered        // so go back and look again for a pending message without waiting.        nextPollTimeoutMillis = 0;    }}</code></pre><p>从上面可以看出，next 优先调用 nativePollOnce 处理 Native 层的消息，其次在获取到 Java 层 MessageQueue 中的消息并返回。</p><h3 id="quit-退出"><a href="#quit-退出" class="headerlink" title="quit 退出"></a>quit 退出</h3><p>MessageQueue 通过 quit 方法，完成 Looper轮训器的退出操作。</p><pre><code>void quit(boolean safe) {    if (!mQuitAllowed) {        throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);    }    synchronized (this) {        if (mQuitting) {            return;        }        mQuitting = true;        if (safe) {            removeAllFutureMessagesLocked();        } else {            removeAllMessagesLocked();        }        // We can assume mPtr != 0 because mQuitting was previously false.        nativeWake(mPtr);    }}</code></pre><p>其上层 Looper 通过普通模式和安全模式调用到此，最终通过 nativeWake 指向 Natvie。</p><h3 id="消息以及回调的删除"><a href="#消息以及回调的删除" class="headerlink" title="消息以及回调的删除"></a>消息以及回调的删除</h3><p>首先简单看一下消息的删除，方法涉及多个重载，我们这里只看其中一个，代码如下：</p><pre><code>// 根据 handler，what，以及 object 查找到 msg 并删除void removeMessages(Handler h, int what, Object object) {    if (h == null) {        return;    }    synchronized (this) {        // 获取当前消息        Message p = mMessages;        // Remove all messages at front.        // 便利找到对应的消息        while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what               &amp;&amp; (object == null || p.obj == object)) {            Message n = p.next;            mMessages = n;            p.recycleUnchecked();            p = n;        }        // Remove all messages after front.        // 删除消息，链接前后消息        while (p != null) {            Message n = p.next;            if (n != null) {                if (n.target == h &amp;&amp; n.what == what                    &amp;&amp; (object == null || n.obj == object)) {                    Message nn = n.next;                    n.recycleUnchecked();                    p.next = nn;                    continue;                }            }            p = n;        }    }}</code></pre><p>删除消息回调</p><pre><code>// 根据 handler 以及 object 删除回调void removeCallbacksAndMessages(Handler h, Object object) {    if (h == null) {        return;    }    synchronized (this) {        Message p = mMessages;        // Remove all messages at front.        while (p != null &amp;&amp; p.target == h                &amp;&amp; (object == null || p.obj == object)) {            Message n = p.next;            mMessages = n;            p.recycleUnchecked();            p = n;        }        // Remove all messages after front.        while (p != null) {            Message n = p.next;            if (n != null) {                if (n.target == h &amp;&amp; (object == null || n.obj == object)) {                    Message nn = n.next;                    n.recycleUnchecked();                    p.next = nn;                    continue;                }            }            p = n;        }    }}</code></pre><h1 id="JNI-层分析"><a href="#JNI-层分析" class="headerlink" title="JNI 层分析"></a>JNI 层分析</h1><p>Java 通过 JNI 方式，链接到 Native 层代码 android_os_MessageQueue.cpp，具体代码如下：</p><pre><code>static JNINativeMethod gMessageQueueMethods[] = {    /* name, signature, funcPtr */    { &quot;nativeInit&quot;, &quot;()J&quot;, (void*)android_os_MessageQueue_nativeInit },    { &quot;nativeDestroy&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeDestroy },    { &quot;nativePollOnce&quot;, &quot;(JI)V&quot;, (void*)android_os_MessageQueue_nativePollOnce },    { &quot;nativeWake&quot;, &quot;(J)V&quot;, (void*)android_os_MessageQueue_nativeWake },    { &quot;nativeIsPolling&quot;, &quot;(J)Z&quot;, (void*)android_os_MessageQueue_nativeIsPolling },    { &quot;nativeSetFileDescriptorEvents&quot;, &quot;(JII)V&quot;,            (void*)android_os_MessageQueue_nativeSetFileDescriptorEvents },};int register_android_os_MessageQueue(JNIEnv* env) {    int res = RegisterMethodsOrDie(env, &quot;android/os/MessageQueue&quot;, gMessageQueueMethods,                                NELEM(gMessageQueueMethods));    jclass clazz = FindClassOrDie(env, &quot;android/os/MessageQueue&quot;);    gMessageQueueClassInfo.mPtr = GetFieldIDOrDie(env, clazz, &quot;mPtr&quot;, &quot;J&quot;);    gMessageQueueClassInfo.dispatchEvents = GetMethodIDOrDie(env, clazz,            &quot;dispatchEvents&quot;, &quot;(II)I&quot;);    return res;}</code></pre><h2 id="nativeInit"><a href="#nativeInit" class="headerlink" title="nativeInit"></a>nativeInit</h2><p>Java 层的 nativeInit 在 MessageQueue 初始化时调用，代码如下：</p><pre><code>static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {    // 新建 NativeMessageQueue，对应与 Java 层    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();    if (!nativeMessageQueue) {        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);        return 0;    }    nativeMessageQueue-&gt;incStrong(env);    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);}</code></pre><p>其对象 NativeMessageQueue 为内部类，其构造函数如下：</p><pre><code>NativeMessageQueue::NativeMessageQueue() :        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {    mLooper = Looper::getForThread();    // 创建 Native 层的 Looper 对象    if (mLooper == NULL) {        mLooper = new Looper(false);        Looper::setForThread(mLooper);    }}</code></pre><p>Native 层的 NativeMessageQueue 在构造时候回依赖 Looper 对象，此时回新建 Native 层的 Looper 对象。</p><h2 id="nativeWake"><a href="#nativeWake" class="headerlink" title="nativeWake"></a>nativeWake</h2><p>Java 层通过 enqueueMessage 发消息，quit 退出以及 removeSyncBarrier 方法都会调用到 nativeWake，其指向函数 android_os_MessageQueue_nativeWake，代码如下：</p><pre><code>static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);    nativeMessageQueue-&gt;wake();}</code></pre><p>同样依赖内部成员 nativeMessageQueue-&gt;wake() 方法，最终指向 mLooper-&gt;wake()。</p><pre><code>void NativeMessageQueue::wake() {    mLooper-&gt;wake();}</code></pre><h2 id="nativePollOnce"><a href="#nativePollOnce" class="headerlink" title="nativePollOnce"></a>nativePollOnce</h2><p>Java 层的 nativePollOnce 调用于 上层 MessageQueue 的 next 方法，用于不断获取数据处理操作，这里是优先处理 Native 的逻辑。在这里指向函数 android_os_MessageQueue_nativePollOnce，，如下：</p><pre><code>static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,        jlong ptr, jint timeoutMillis) {    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);}</code></pre><p>函数最终指向了 nativeMessageQueue-&gt;pollOnce，代码如下：</p><pre><code>void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {    mPollEnv = env;    mPollObj = pollObj;    // 调用持有对象 looper 的 pollOnce    mLooper-&gt;pollOnce(timeoutMillis);    mPollObj = NULL;    mPollEnv = NULL;    if (mExceptionObj) {        env-&gt;Throw(mExceptionObj);        env-&gt;DeleteLocalRef(mExceptionObj);        mExceptionObj = NULL;    }}</code></pre><p>此处通过持有对象 Native 层的 looper，调用到 pollOnce 方法，后面具体分析。</p><p>分析到这里，我们之是大概的分析了其内部调用逻辑，JNI 部分也只是衔接 Java 和 Native 部分，具体的逻辑还是在下面的 Native 层章节具体分析。</p><h1 id="Native-层三巨头"><a href="#Native-层三巨头" class="headerlink" title="Native 层三巨头"></a>Native 层三巨头</h1><p>Java 中存在的三巨头，Native 也同样存在，下面我们来具体分析。</p><h2 id="NativeMessageQueue"><a href="#NativeMessageQueue" class="headerlink" title="NativeMessageQueue"></a>NativeMessageQueue</h2><p>Java 层建议对象 MessageQueue 时，便和 Native 曾建立联系，NativeMessageQueue 声明在 android_os_MessageQueue.h 中，其依赖两个父类，如下：</p><pre><code>class MessageQueue : public virtual RefBase {public:    inline sp&lt;Looper&gt; getLooper() const {        return mLooper;    }    bool raiseAndClearException(JNIEnv* env, const char* msg);    virtual void raiseException(JNIEnv* env, const char* msg, jthrowable exceptionObj) = 0;protected:    MessageQueue();    virtual ~MessageQueue();protected:    sp&lt;Looper&gt; mLooper;};class LooperCallback : public virtual RefBase {protected:    virtual ~LooperCallback() { }public:    virtual int handleEvent(int fd, int events, void* data) = 0;};class NativeMessageQueue : public MessageQueue, public LooperCallback {public:    NativeMessageQueue();    virtual ~NativeMessageQueue();    virtual void raiseException(JNIEnv* env, const char* msg, jthrowable exceptionObj);    void pollOnce(JNIEnv* env, jobject obj, int timeoutMillis);    void wake();    void setFileDescriptorEvents(int fd, int events);    virtual int handleEvent(int fd, int events, void* data);private:    JNIEnv* mPollEnv;    jobject mPollObj;    jthrowable mExceptionObj;};</code></pre><p>上面可以看出，父类 MessageQueue 主要提供 raiseAndClearException 和<br> raiseException 方法，同时持有成员变量 mLooper 轮训器。父类 LooperCallback 则更简单，提供一个共有接口 handleEvent。</p><h3 id="NativeMessageQueue-构造函数"><a href="#NativeMessageQueue-构造函数" class="headerlink" title="NativeMessageQueue 构造函数"></a>NativeMessageQueue 构造函数</h3><p>NativeMessageQueue 的构造函数如下：</p><pre><code>NativeMessageQueue::NativeMessageQueue() :        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {    mLooper = Looper::getForThread();    if (mLooper == NULL) {        mLooper = new Looper(false);        Looper::setForThread(mLooper);    }}</code></pre><p>创建 Native 层的 Looper 对象，设置 Looper 线程的 looper 对象。</p><h3 id="wake"><a href="#wake" class="headerlink" title="wake"></a>wake</h3><p>NativeMessageQueue 的 wake 函数相对简单，代码如下：</p><pre><code>void NativeMessageQueue::wake() {    mLooper-&gt;wake();}</code></pre><h3 id="pollOnce"><a href="#pollOnce" class="headerlink" title="pollOnce"></a>pollOnce</h3><p>NativeMessageQueue 的 pollOnce 实现对消息队列的轮训检查，具体代码如下：</p><pre><code>void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {    mPollEnv = env;    mPollObj = pollObj;    // 调用持有对象 looper 的 pollOnce    mLooper-&gt;pollOnce(timeoutMillis);    mPollObj = NULL;    mPollEnv = NULL;    if (mExceptionObj) {        env-&gt;Throw(mExceptionObj);        env-&gt;DeleteLocalRef(mExceptionObj);        mExceptionObj = NULL;    }}</code></pre><p>最终实现方法还是依赖 Looper 的 pollOnce，看来 Native 层的 Looper 才是最终要干活的人啊！</p><h2 id="Looper（Native）"><a href="#Looper（Native）" class="headerlink" title="Looper（Native）"></a>Looper（Native）</h2><p>上面分析，均已 Looper 截断，此处我们具体分析 Looper 的逻辑。</p><h3 id="Looper-的构造函数"><a href="#Looper-的构造函数" class="headerlink" title="Looper 的构造函数"></a>Looper 的构造函数</h3><p>Native 层的 Looper 类相对最复杂，我们首先分析其工作流程，剩下的其他部分后续再补充说明。代码如下：</p><pre><code>Looper::Looper(bool allowNonCallbacks) :        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),        mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),        mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {    // 创建事件对象 mWakeEventFd，不阻塞方式    mWakeEventFd = eventfd(0, EFD_NONBLOCK);    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; 0, &quot;Could not make wake event fd.  errno=%d&quot;, errno);    AutoMutex _l(mLock);    rebuildEpollLocked();}</code></pre><p>Looper 初始化将创建一个时间对象用于唤醒，eventfd 方式的具体解释，可以参考一下博文</p><p><a href="https://blog.csdn.net/tanswer_/article/details/79008322" target="_blank" rel="noopener">eventfd 事件通知</a></p><p>构造函数最后，调用 rebuildEpollLocked 重新构建 epoll 下文件描述符的监听任务，如下代码：</p><pre><code>void Looper::Request::initEventItem(struct epoll_event* eventItem) const {    int epollEvents = 0;    if (events &amp; EVENT_INPUT) epollEvents |= EPOLLIN;    if (events &amp; EVENT_OUTPUT) epollEvents |= EPOLLOUT;    memset(eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union    eventItem-&gt;events = epollEvents;    eventItem-&gt;data.fd = fd;}void Looper::rebuildEpollLocked() {    // Close old epoll instance if we have one.    if (mEpollFd &gt;= 0) {#if DEBUG_CALLBACKS        ALOGD(&quot;%p ~ rebuildEpollLocked - rebuilding epoll set&quot;, this);#endif        close(mEpollFd);    }    // Allocate the new epoll instance and register the wake pipe.    // 创建 epoll 监听文件描述符，监数目 8    mEpollFd = epoll_create(EPOLL_SIZE_HINT);    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);    struct epoll_event eventItem;    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union    eventItem.events = EPOLLIN;    eventItem.data.fd = mWakeEventFd;    // 将 mWakeEventFd 文件描述符加入监听列表中    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake event fd to epoll instance.  errno=%d&quot;,            errno);    // mRequests 为 KeyedVector&lt;int, Request&gt; 类型，通过 index 和 Request 进行绑定，后续进行结构体的具体分析    for (size_t i = 0; i &lt; mRequests.size(); i++) {        // 获取对应的 Request        const Request&amp; request = mRequests.valueAt(i);        struct epoll_event eventItem;        // 初始化 eventItem        request.initEventItem(&amp;eventItem);        // 加入监听中        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);        if (epollResult &lt; 0) {            ALOGE(&quot;Error adding epoll events for fd %d while rebuilding epoll set, errno=%d&quot;,                    request.fd, errno);        }    }}</code></pre><p>如此一来，Looper 便完成了相关文件描述符的监听，其中包括事件通知对象 mWakeEventFd。至于 mRequests 内部对象的添加，后续分析。</p><h3 id="wake-1"><a href="#wake-1" class="headerlink" title="wake"></a>wake</h3><p>Looper 的 wake 函数实际上是最终调用的函数，代码如下：</p><pre><code>void Looper::wake() {#if DEBUG_POLL_AND_WAKE    ALOGD(&quot;%p ~ wake&quot;, this);#endif    uint64_t inc = 1;    // 想文件描述符中写入数据，以便唤醒    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));    if (nWrite != sizeof(uint64_t)) {        if (errno != EAGAIN) {            ALOGW(&quot;Could not write wake signal, errno=%d&quot;, errno);        }    }}</code></pre><p>wake 函数通过向 mWakeEventFd 写入数据，此时发生了数据写入操作，在 pollOnce 中监听便得到响应。</p><h3 id="pollOnce-1"><a href="#pollOnce-1" class="headerlink" title="pollOnce"></a>pollOnce</h3><p>Java 层的 Looper 在无限循环中，通过 next 获取消息并处理，优先处理 Native 的消息，机调用 pollOnce 走到次数，代码如下：</p><pre><code>int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {    int result = 0;    // 无限循环    for (;;) {        // 优先处理 response，此处的 mResponses 为一个 Vector&lt;Response&gt; 类型        while (mResponseIndex &lt; mResponses.size()) {            // 取出对应的 response            const Response&amp; response = mResponses.itemAt(mResponseIndex++);            int ident = response.request.ident;            if (ident &gt;= 0) {                int fd = response.request.fd;                int events = response.events;                void* data = response.request.data;#if DEBUG_POLL_AND_WAKE                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;                        &quot;fd=%d, events=0x%x, data=%p&quot;,                        this, ident, fd, events, data);#endif                // 赋值                if (outFd != NULL) *outFd = fd;                if (outEvents != NULL) *outEvents = events;                if (outData != NULL) *outData = data;                // 直接返回 ident，此时的 ident 为大于 0 的值                return ident;            }        }        // 一次轮训结束后，从下面返回的 result        if (result != 0) {#if DEBUG_POLL_AND_WAKE            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);#endif            if (outFd != NULL) *outFd = 0;            if (outEvents != NULL) *outEvents = 0;            if (outData != NULL) *outData = NULL;            return result;        }        // 调用 pollInner 再次处理，依然在无限循环内部        result = pollInner(timeoutMillis);    }}</code></pre><p>代码逻辑中，优先处理 mResponses 中对应的 Response，存在赋值并直接返回 ident，否则调用 pollInner 进入下层逻辑。代码如下：</p><pre><code>int Looper::pollInner(int timeoutMillis) {#if DEBUG_POLL_AND_WAKE    ALOGD(&quot;%p ~ pollOnce - waiting: timeoutMillis=%d&quot;, this, timeoutMillis);#endif    // Adjust the timeout based on when the next message is due.    if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) {        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);        if (messageTimeoutMillis &gt;= 0                &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) {            timeoutMillis = messageTimeoutMillis;        }#if DEBUG_POLL_AND_WAKE        ALOGD(&quot;%p ~ pollOnce - next message in %&quot; PRId64 &quot;ns, adjusted timeout: timeoutMillis=%d&quot;,                this, mNextMessageUptime - now, timeoutMillis);#endif    }    // Poll.    int result = POLL_WAKE;    // mResponses 处理完成，清理工作     mResponses.clear();    mResponseIndex = 0;    // We are about to idle.    mPolling = true;    // epoll_event 结构体，容纳 16 个文件描述符事件单位的数组    struct epoll_event eventItems[EPOLL_MAX_EVENTS];    // epoll_wait 等待在 mEpollFd 文件描述符上发生事件    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);    // No longer idling.    mPolling = false;    // Acquire lock.    mLock.lock();    // Rebuild epoll set if needed.    // 是否有需要重新构建 epoll 监听列表    if (mEpollRebuildRequired) {        mEpollRebuildRequired = false;        rebuildEpollLocked();        goto Done;    }    // Check for poll error.    // epoll 监听发生错误    if (eventCount &lt; 0) {        if (errno == EINTR) {            goto Done;        }        ALOGW(&quot;Poll failed with an unexpected error, errno=%d&quot;, errno);        result = POLL_ERROR;        goto Done;    }    // Check for poll timeout.    // epoll 监听超时    if (eventCount == 0) {#if DEBUG_POLL_AND_WAKE        ALOGD(&quot;%p ~ pollOnce - timeout&quot;, this);#endif        result = POLL_TIMEOUT;        goto Done;    }    // Handle all events.#if DEBUG_POLL_AND_WAKE    ALOGD(&quot;%p ~ pollOnce - handling events from %d fds&quot;, this, eventCount);#endif    // 处理文件节点发生的事件，eventCount 为监听文件描述符发生事件的个数    for (int i = 0; i &lt; eventCount; i++) {        // 获取发生事件的具体文件描述符        int fd = eventItems[i].data.fd;        // 获取对应发生事件类型        uint32_t epollEvents = eventItems[i].events;        // 唤醒操作，即客户端调用 wake 向 mWakeEventFd 写入数据，追溯上层 Java 层可以调用 nativeWake 引起        if (fd == mWakeEventFd) {            if (epollEvents &amp; EPOLLIN) {                // 唤醒操作                awoken();            } else {                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;, epollEvents);            }        } else {            // 其他文件描述符使用了 &lt;index，Request&gt; 来存储，这里从 mRequests 中获取获取 index，返回值 requestIndex 大于 0 即为获取成功，存在            ssize_t requestIndex = mRequests.indexOfKey(fd);            if (requestIndex &gt;= 0) {                int events = 0;                if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;                if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;                if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;                if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;                // 调用 pushResponse 继续处理，从 mRequests 中 &lt;int，Request&gt; 获取fd对应的 Request，并添加到 mResponses 中                pushResponse(events, mRequests.valueAt(requestIndex));            } else {                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on fd %d that is &quot;                        &quot;no longer registered.&quot;, epollEvents, fd);            }        }    }Done: ;    // Invoke pending message callbacks.    mNextMessageUptime = LLONG_MAX;    while (mMessageEnvelopes.size() != 0) {        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);        const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);        if (messageEnvelope.uptime &lt;= now) {            { // obtain handler                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;                Message message = messageEnvelope.message;                mMessageEnvelopes.removeAt(0);                mSendingMessage = true;                mLock.unlock();#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS                ALOGD(&quot;%p ~ pollOnce - sending message: handler=%p, what=%d&quot;,                        this, handler.get(), message.what);#endif                // 调用对应的 msg 的 handleMessage 方法，具体分析见后面                handler-&gt;handleMessage(message);            } // release handler            mLock.lock();            mSendingMessage = false;            result = POLL_CALLBACK;        } else {            // The last message left at the head of the queue determines the next wakeup time.            mNextMessageUptime = messageEnvelope.uptime;            break;        }    }    // Release lock.    mLock.unlock();    // Invoke all response callbacks.    // 处理 mResponses 中具体的 response    for (size_t i = 0; i &lt; mResponses.size(); i++) {        Response&amp; response = mResponses.editItemAt(i);        // response 中元素 request.ident 为 POLL_CALLBACK，即含有回调函数        if (response.request.ident == POLL_CALLBACK) {            int fd = response.request.fd;            int events = response.events;            void* data = response.request.data;#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS            ALOGD(&quot;%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p&quot;,                    this, response.request.callback.get(), fd, events, data);#endif            // 回调 callback 的 handleEvent 函数            int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);            if (callbackResult == 0) {                // 成功，移除工作                removeFd(fd, response.request.seq);            }            response.request.callback.clear();            result = POLL_CALLBACK;        }    }    return result;}void Looper::pushResponse(int events, const Request&amp; request) {    Response response;    response.events = events;    response.request = request;    // 再次使用 mResponses 进行处理，调用 push 后，mResponses 中便添加了新元素 response    mResponses.push(response);}</code></pre><p>以上代码众多，主要涉及到了 epoll 机制，如果读者对 epoll 不了解的话，可能需要重新学习一下 epoll 机制了，这里不做过多说明了，有需要请参考之前的博文，这里对上述代码做一个总结：</p><ol><li>pollOnce 中主要对 mResponses 信息进行处理，如果 response.request.ident 大于0，就取出信息直接返回，否则再调用 pollInner 继续处理</li><li>pollInner 中首先针对过期的消息设置超时时间，然后再清理 Responses 数据，因为之前已经处理了 Responses 中的数据，后续要对发生事件的文件描述符进行统计，再次集中记录到 Responses 处理</li><li>接下来便是基本的 epoll 模型，epoll_wait 监听文件描述符事件发生</li><li>分别处理 epoll 监听错误，监听超时等错误</li><li>接下来处理文件节点发生的事件，eventCount 返回发生事件文件描述符个数</li><li>如果 fd 为 mWakeEventFd，即进行唤醒操作，执行 awoken</li><li>对于其他文件描述符，Looper 使用了 &lt;int，Request&gt; 来存储，这里从 mRequests 中获取获取 index，返回值 requestIndex 大于 0 即为获取成功，之后调用 pushResponse 集中添加到 mResponses 中</li><li>遍历完成后，便开始对消息进行处理，优先处理 mMessageEnvelopes 中的消息回调</li><li>再处理 mResponses 中具体的 response，这里的是之前文件描述符发生事件写入的集合列表</li><li>最后执行相应的清理任务并返回执行结果</li></ol><p>上述代码中，需要读者对 epoll 机制有一定的了解，否则真的难以看懂，之前博主已经对 epoll 进行了相关的介绍，请自行查看，这里主要是处在两个数据集合，一个是 mResponses，另一个是 mMessageEnvelopes，下面我们具体分析一下这两个数据集合。</p><h3 id="mResponses-数据分析"><a href="#mResponses-数据分析" class="headerlink" title="mResponses 数据分析"></a>mResponses 数据分析</h3><p>Looper.h 的头文件中声明了 Vector<response> mResponses，其实一个 Vector 容器，类型为 Response，那么 Response 又是什么？</response></p><pre><code>struct Response {    int events;    Request request;};</code></pre><p>结构体 Response 内部有两个元素，events 即位事件，那么 Request 又是什么？</p><pre><code>struct Request {    int fd;    int ident;    int events;    int seq;    sp&lt;LooperCallback&gt; callback;    void* data;    void initEventItem(struct epoll_event* eventItem) const;};</code></pre><p>到这里就清晰明了了，Request 集中封装了事件发生的文件结构，例如文件描述符，事件类型，事件回调，以及额外数据，同时提供函数指针 initEventItem 用于 Looper 中实现快捷的将 int events 类型转换到 epoll 原型监听文件结构，如下：</p><pre><code>void Looper::Request::initEventItem(struct epoll_event* eventItem) const {    int epollEvents = 0;    // 根据 events 转换到 epoll 下的事件类型    if (events &amp; EVENT_INPUT) epollEvents |= EPOLLIN;    if (events &amp; EVENT_OUTPUT) epollEvents |= EPOLLOUT;    memset(eventItem, 0, sizeof(epoll_event));    // 赋值操作    eventItem-&gt;events = epollEvents;    eventItem-&gt;data.fd = fd;}</code></pre><p>由上可以看出，mResponses 中存放了 Vector<response> 类型的数据，其每一个元素对应一个需要监听的 epoll 文件描述符，其元素的 Request 节点的 指针函数 initEventItem 便于将数据结构快捷的转换到 epoll 所需的文件结构，实现 epoll 监听。</response></p><h4 id="数据添加"><a href="#数据添加" class="headerlink" title="数据添加"></a>数据添加</h4><p>到这里，数据结构分析完毕了，那么文件监听是如何添加进去的呢？Looper 中有一个函数如下：</p><pre><code>int Looper::addFd(int fd, int ident, int events, Looper_callbackFunc callback, void* data) {    return addFd(fd, ident, events, callback ? new SimpleLooperCallback(callback) : NULL, data);}</code></pre><p>SimpleLooperCallback 继承自 LooperCallback，如下：</p><pre><code>class SimpleLooperCallback : public LooperCallback {protected:    virtual ~SimpleLooperCallback();public:    SimpleLooperCallback(Looper_callbackFunc callback);    virtual int handleEvent(int fd, int events, void* data);private:    Looper_callbackFunc mCallback;};SimpleLooperCallback::SimpleLooperCallback(Looper_callbackFunc callback) :    mCallback(callback) {}int SimpleLooperCallback::handleEvent(int fd, int events, void* data{    return mCallback(fd, events, data);}</code></pre><p>子实现类 SimpleLooperCallback， 构造函数维持有 Looper_callbackFunc 对象，需要实现 handleEvent 方法，下面继续看 addFd 函数：</p><pre><code>int Looper::addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data) {#if DEBUG_CALLBACKS    ALOGD(&quot;%p ~ addFd - fd=%d, ident=%d, events=0x%x, callback=%p, data=%p&quot;, this, fd, ident,            events, callback.get(), data);#endif    // 存在为空    if (!callback.get()) {        if (! mAllowNonCallbacks) {            ALOGE(&quot;Invalid attempt to set NULL callback but not allowed for this looper.&quot;);            return -1;        }        if (ident &lt; 0) {            ALOGE(&quot;Invalid attempt to set NULL callback with ident &lt; 0.&quot;);            return -1;        }    } else {        ident = POLL_CALLBACK;    }    { // acquire lock        AutoMutex _l(mLock);        // 使用 Request 结构体承载数据        Request request;        request.fd = fd;        request.ident = ident;        request.events = events;        request.seq = mNextRequestSeq++;        request.callback = callback;        request.data = data;        if (mNextRequestSeq == -1) mNextRequestSeq = 0; // reserve sequence number -1        struct epoll_event eventItem;        // 将 Request 转化成 epoll 需要的 eventItem 数据结构        request.initEventItem(&amp;eventItem);        ssize_t requestIndex = mRequests.indexOfKey(fd);        // 没有添加过，直接添加监听        if (requestIndex &lt; 0) {            int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);            if (epollResult &lt; 0) {                ALOGE(&quot;Error adding epoll events for fd %d, errno=%d&quot;, fd, errno);                return -1;            }            // mRequests 为一个 KeyedVector&lt;int, Request&gt;，没有记录项，添加            mRequests.add(fd, request);        } else {            // 监听存在，修改属性            int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem);            // 添加出错            if (epollResult &lt; 0) {                if (errno == ENOENT) {#if DEBUG_CALLBACKS                    ALOGD(&quot;%p ~ addFd - EPOLL_CTL_MOD failed due to file descriptor &quot;                            &quot;being recycled, falling back on EPOLL_CTL_ADD, errno=%d&quot;,                            this, errno);#endif                    epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);                    if (epollResult &lt; 0) {                        ALOGE(&quot;Error modifying or adding epoll events for fd %d, errno=%d&quot;,                                fd, errno);                        return -1;                    }                    scheduleEpollRebuildLocked();                } else {                    ALOGE(&quot;Error modifying epoll events for fd %d, errno=%d&quot;, fd, errno);                    return -1;                }            }            // 替换对应元素            mRequests.replaceValueAt(requestIndex, request);        }    } // release lock    return 1;}</code></pre><p>Native 层提供的 addfd 函数，Java 层通过函数 nativeSetFileDescriptorEvents 连接到 Native，JNI 接口函数如下：</p><pre><code>static void android_os_MessageQueue_nativeSetFileDescriptorEvents(JNIEnv* env, jclass clazz,        jlong ptr, jint fd, jint events) {    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);    nativeMessageQueue-&gt;setFileDescriptorEvents(fd, events);}</code></pre><p>至于 Java 层添加等详细流程，后续的分析这里就不展开了。</p><h4 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h4><p>既然有了添加，那么肯定有移除操作了，如下；</p><pre><code>int Looper::removeFd(int fd, int seq) {#if DEBUG_CALLBACKS    ALOGD(&quot;%p ~ removeFd - fd=%d, seq=%d&quot;, this, fd, seq);#endif    { // acquire lock        AutoMutex _l(mLock);        // 从 mRequests 集合中获取 fd 对应的 index        ssize_t requestIndex = mRequests.indexOfKey(fd);        if (requestIndex &lt; 0) {            return 0;        }        if (seq != -1 &amp;&amp; mRequests.valueAt(requestIndex).seq != seq) {#if DEBUG_CALLBACKS            ALOGD(&quot;%p ~ removeFd - sequence number mismatch, oldSeq=%d&quot;,                    this, mRequests.valueAt(requestIndex).seq);#endif            return 0;        }        // 移除        mRequests.removeItemsAt(requestIndex);        // 将 fd 从 epoll 监听节点 mEpollFd 中删除        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_DEL, fd, NULL);        if (epollResult &lt; 0) {            if (seq != -1 &amp;&amp; (errno == EBADF || errno == ENOENT)) {#if DEBUG_CALLBACKS                ALOGD(&quot;%p ~ removeFd - EPOLL_CTL_DEL failed due to file descriptor &quot;                        &quot;being closed, errno=%d&quot;, this, errno);#endif                scheduleEpollRebuildLocked();            } else {                ALOGE(&quot;Error removing epoll events for fd %d, errno=%d&quot;, fd, errno);                scheduleEpollRebuildLocked();                return -1;            }        }    } // release lock    return 1;}</code></pre><p>同样，Java 层也可以通过 JNI 进行回调。</p><h4 id="数据回调"><a href="#数据回调" class="headerlink" title="数据回调"></a>数据回调</h4><p>mResponses 中的数据发生改变是如何回调的呢，之前我们在函数 pollInner 中，有如下代码</p><pre><code>for (size_t i = 0; i &lt; mResponses.size(); i++) {    Response&amp; response = mResponses.editItemAt(i);    // response 中元素 request.ident 为 POLL_CALLBACK，即含有回调函数    if (response.request.ident == POLL_CALLBACK) {        int fd = response.request.fd;        int events = response.events;        void* data = response.request.data;        // 回调 callback 的 handleEvent 函数        int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);        if (callbackResult == 0) {            // 成功，移除工作            removeFd(fd, response.request.seq);        }        response.request.callback.clear();        result = POLL_CALLBACK;    }}</code></pre><p>具体对应的函数如下：</p><pre><code>int NativeMessageQueue::handleEvent(int fd, int looperEvents, void* data) {    int events = 0;    // 事件类型转换    if (looperEvents &amp; Looper::EVENT_INPUT) {        events |= CALLBACK_EVENT_INPUT;    }    if (looperEvents &amp; Looper::EVENT_OUTPUT) {        events |= CALLBACK_EVENT_OUTPUT;    }    if (looperEvents &amp; (Looper::EVENT_ERROR | Looper::EVENT_HANGUP | Looper::EVENT_INVALID)) {        events |= CALLBACK_EVENT_ERROR;    }    int oldWatchedEvents = reinterpret_cast&lt;intptr_t&gt;(data);    // 反过来回调 Java 层的 dispatchEvents 方法    int newWatchedEvents = mPollEnv-&gt;CallIntMethod(mPollObj,            gMessageQueueClassInfo.dispatchEvents, fd, events);    if (!newWatchedEvents) {        return 0; // unregister the fd    }    if (newWatchedEvents != oldWatchedEvents) {        // 更改 Native 层的 fd        setFileDescriptorEvents(fd, newWatchedEvents);    }    return 1;}void NativeMessageQueue::setFileDescriptorEvents(int fd, int events) {    if (events) {        int looperEvents = 0;        if (events &amp; CALLBACK_EVENT_INPUT) {            looperEvents |= Looper::EVENT_INPUT;        }        if (events &amp; CALLBACK_EVENT_OUTPUT) {            looperEvents |= Looper::EVENT_OUTPUT;        }        mLooper-&gt;addFd(fd, Looper::POLL_CALLBACK, looperEvents, this,                reinterpret_cast&lt;void*&gt;(events));    } else {        mLooper-&gt;removeFd(fd);    }}</code></pre><p>函数中 mPollEnv-&gt;CallIntMethod(mPollObj,gMessageQueueClassInfo.dispatchEvents, fd, events) 中指明了函数的出处，此处通过 JNI 指向了 Java 层接口回调，如下：</p><pre><code>private int dispatchEvents(int fd, int events) {    // Get the file descriptor record and any state that might change.    final FileDescriptorRecord record;    final int oldWatchedEvents;    final OnFileDescriptorEventListener listener;    final int seq;    synchronized (this) {        record = mFileDescriptorRecords.get(fd);        if (record == null) {            return 0; // spurious, no listener registered        }        oldWatchedEvents = record.mEvents;        events &amp;= oldWatchedEvents; // filter events based on current watched set        if (events == 0) {            return oldWatchedEvents; // spurious, watched events changed        }        listener = record.mListener;        seq = record.mSeq;    }    // Invoke the listener outside of the lock.    // 通过 listener 监听接口，回调函数 onFileDescriptorEvents    int newWatchedEvents = listener.onFileDescriptorEvents(            record.mDescriptor, events);    if (newWatchedEvents != 0) {        newWatchedEvents |= OnFileDescriptorEventListener.EVENT_ERROR;    }    if (newWatchedEvents != oldWatchedEvents) {        synchronized (this) {            int index = mFileDescriptorRecords.indexOfKey(fd);            if (index &gt;= 0 &amp;&amp; mFileDescriptorRecords.valueAt(index) == record                    &amp;&amp; record.mSeq == seq) {                record.mEvents = newWatchedEvents;                if (newWatchedEvents == 0) {                    mFileDescriptorRecords.removeAt(index);                }            }        }    }    return newWatchedEvents;}</code></pre><p>至此，基本分析完了 mResponses 中的数据结构，包括数据的添加，回调以及删除，下面我们来看 mMessageEnvelopes 数据结构。</p><h3 id="mMessageEnvelopes-数据分析"><a href="#mMessageEnvelopes-数据分析" class="headerlink" title="mMessageEnvelopes 数据分析"></a>mMessageEnvelopes 数据分析</h3><p>首先来看其声明部分，如下：</p><pre><code>Vector&lt;MessageEnvelope&gt; mMessageEnvelopes; // 承载消息队列的信封struct MessageEnvelope {    MessageEnvelope() : uptime(0) { }    MessageEnvelope(nsecs_t uptime, const sp&lt;MessageHandler&gt; handler,            const Message&amp; message) : uptime(uptime), handler(handler), message(message) {    }    nsecs_t uptime;    sp&lt;MessageHandler&gt; handler;    Message message;};</code></pre><p>mMessageEnvelopes 为元素为 MessageEnvelope 类型的 Vector 容器，容器内每一个元素都代表着一个 消息 msg，MessageEnvelope 通过 sp 强引用与 handler 建立链接，每封信封封装了消息的信息，事件，handler接受人等。</p><h4 id="MessageEnvelope-的发送"><a href="#MessageEnvelope-的发送" class="headerlink" title="MessageEnvelope 的发送"></a>MessageEnvelope 的发送</h4><p>Native 层通过 send*Message 接口发送消息，最终走向 sendMessageAtTime 如下代码：</p><pre><code>void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler,        const Message&amp; message) {#if DEBUG_CALLBACKS    ALOGD(&quot;%p ~ sendMessageAtTime - uptime=%&quot; PRId64 &quot;, handler=%p, what=%d&quot;,            this, uptime, handler.get(), message.what);#endif    size_t i = 0;    { // acquire lock        AutoMutex _l(mLock);        // 获取 mMessageEnvelopes 的大小        size_t messageCount = mMessageEnvelopes.size();        // 根据时间，找到合适位置进行插入        while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) {            i += 1;        }        // 新建信封单位 messageEnvelope 并加入到 mMessageEnvelopes        MessageEnvelope messageEnvelope(uptime, handler, message);        mMessageEnvelopes.insertAt(messageEnvelope, i, 1);        if (mSendingMessage) {            return;        }    } // release lock    // 信封没有信件，进入 wake 状态    if (i == 0) {        wake();    }}</code></pre><p>代码注释很详细，下面来看信封中信息的删除。</p><h4 id="MessageEnvelope-的删除"><a href="#MessageEnvelope-的删除" class="headerlink" title="MessageEnvelope 的删除"></a>MessageEnvelope 的删除</h4><p>Looper 中的函数 removeMessages 有多个重载，逻辑差不太多，我们直接看其中一个的一个，根据 handler 与 what 类型进行删除</p><pre><code>void Looper::removeMessages(const sp&lt;MessageHandler&gt;&amp; handler, int what) {#if DEBUG_CALLBACKS    ALOGD(&quot;%p ~ removeMessages - handler=%p, what=%d&quot;, this, handler.get(), what);#endif    { // acquire lock        AutoMutex _l(mLock);        // 遍历 mMessageEnvelopes 数据结构，找到对应的并删除        for (size_t i = mMessageEnvelopes.size(); i != 0; ) {            const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(--i);            if (messageEnvelope.handler == handler                    &amp;&amp; messageEnvelope.message.what == what) {                mMessageEnvelopes.removeAt(i);            }        }    } // release lock}</code></pre><h4 id="MessageEnvelope-的回调"><a href="#MessageEnvelope-的回调" class="headerlink" title="MessageEnvelope 的回调"></a>MessageEnvelope 的回调</h4><p>对于 MessageEnvelope 的添加和删除操作，同样，在函数 pollOnce 的子函数 pollInner 中，有如下代码实现了信息的回调：</p><pre><code>while (mMessageEnvelopes.size() != 0) {    nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);    const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);    if (messageEnvelope.uptime &lt;= now) {        { // obtain handler            sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;            Message message = messageEnvelope.message;            mMessageEnvelopes.removeAt(0);            mSendingMessage = true;            mLock.unlock();            // 调用对应的 msg 的 handleMessage 方法            handler-&gt;handleMessage(message);        } // release handler        mLock.lock();        mSendingMessage = false;        result = POLL_CALLBACK;    } else {        mNextMessageUptime = messageEnvelope.uptime;        break;    }}</code></pre><p>通览 pollOnce 函数，可以看出，MessageEnvelope 的信息处理优先级高于 Response 类型的 mResponses 回调。对于 MessageHandler 到下一节中介绍。</p><h2 id="MessageHandler"><a href="#MessageHandler" class="headerlink" title="MessageHandler"></a>MessageHandler</h2><p>Native 层的 Handler 对应于 MessageHandler，其在 Looper 中声明如下：</p><pre><code>class MessageHandler : public virtual RefBase {protected:    virtual ~MessageHandler() { }public:    /**    * Handles a message.    */    virtual void handleMessage(const Message&amp; message) = 0;};</code></pre><p>基类 MessageHandler 只声明了 handleMessage 接口，而实际上实现的确实子类 WeakMessageHandler，如下：</p><pre><code>class WeakMessageHandler : public MessageHandler {protected:    virtual ~WeakMessageHandler();public:    WeakMessageHandler(const wp&lt;MessageHandler&gt;&amp; handler);    virtual void handleMessage(const Message&amp; message);private:    wp&lt;MessageHandler&gt; mHandler;};WeakMessageHandler::WeakMessageHandler(const wp&lt;MessageHandler&gt;&amp; handler) :        mHandler(handler) {}WeakMessageHandler::~WeakMessageHandler() {}</code></pre><p>子类 WeakMessageHandler 通过弱引用方式维持了 MessageHandler 类型的 handler 对象，其 handleMessage 方法如下：</p><pre><code>void WeakMessageHandler::handleMessage(const Message&amp; message) {    sp&lt;MessageHandler&gt; handler = mHandler.promote();    if (handler != NULL) {        handler-&gt;handleMessage(message);    }}</code></pre><p>代码中并未直接处理 handleMessage，因为弱饮用的关系，可能饮用对象不存在，需要尝试升级到强引用 mHandler.promote，然后再处理 handleMessage。关于智能指针的引用计数，有需要请参考之前的博文。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上内容的介绍，相信读者对安卓中的 Handler 通信机制有更深的了解。本文通过源码分析的方式，从 Java 到 JNI 到 Native，分别分析了 Handler、Looper、MessageQueue三者的关系，网上很多博主对其进行了总结，感觉也十分出众，这里本人也画了一幅小图来总结一下其之间的关系，如下：</p><img src="/FuckCode/2019/04/09/源码分析之Handler、Looper及MessageQueue之间关系/Handler.png" class="Handler模型"><p>在分析 MessageQueue 的过程中，本人使用 Xmind 思维导图将函数之间的调用关系进行了相关的汇总，图片如下：</p><img src="/FuckCode/2019/04/09/源码分析之Handler、Looper及MessageQueue之间关系/MessageQueue.png" class="MessageQueue关系思维导图"><p>文章内容涉及 epoll 模型，强烈推荐读者了解一下 select，poll，epoll等高并发模型，在后续代码分析中将会如鱼得水。</p><p><a href="https://891904833.gitee.io/fuckingcode/2019/01/23/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/#more">高并发模型推荐</a></p><p>文件从邓凡平前辈的相关博文中汲取灵感，推荐博文如下：</p><p><a href="https://blog.csdn.net/Innost/article/details/47252865" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Handler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之多路IO转接服务器</title>
      <link href="/FuckCode/2019/01/23/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/FuckCode/2019/01/23/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>本章节主要介绍Linux中高并发服务器下的三种多路IO转接模型：select，poll，epoll。各模型分别从原理，系统函数，实现代码三个方面一一说明。文章内容稍有深度，代码理解不易，需要读者结合代码注释以及参考链接内容，反复比较思考。文章最后，对几种多路IO模型的优缺点进行总结，算是对此章节做的收尾工作。</strong><br><a id="more"></a></p><h1 id="多路IO转接服务器"><a href="#多路IO转接服务器" class="headerlink" title="多路IO转接服务器"></a>多路IO转接服务器</h1><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p><ol><li>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用</li><li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现</li><li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用</li><li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用</li><li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用</li></ol><p>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p><h2 id="select服务器模型"><a href="#select服务器模型" class="headerlink" title="select服务器模型"></a>select服务器模型</h2><p>select函数能够实现多路IO复用机制，通过select系统调用，让我们的程序监视多个文件句柄的状态变化的，其使用一个 fd_set 来监测数据是否到达，状态是否改变，提供三种数据：读数据，写数据，异常数据。同时，select还可以指定文件阻塞方式和超时等待，非阻塞直接返回，阻塞式直到被监视的文件句柄有一个或多个发生了状态改变才会返回，返回值为变化的文件描述符个数。</p><p>使用 select 需要注意以下两点：</p><ol><li>select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024,单纯改变进程打开的文件描述符个数并不能改变select监听文件个数</li><li>解决1024以下客户端时使用select是很合适的,但如果链接客户端过多,select采用的是轮询模型,会大大降低服务器响应效率,不应在select上投入更多精力</li></ol><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><pre><code>#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);nfds: 监控的文件描述符集里最大文件描述符加1,因为此参数会告诉内核检测前多少个文件描述符的状态readfds: 监控有读数据到达文件描述符集合,传入传出参数writefds: 监控写数据到达文件描述符集合,传入传出参数exceptfds: 监控异常发生达文件描述符集合,如带外数据到达异常,传入传出参数timeout: 定时阻塞监控时间,3种情况  1. NULL,永远等下去  2. 设置timeval,等待固定时间  3. 设置timeval里时间均为0,检查描述字后立即返回,轮询返回值：  1. -1，执行错误  2. 0，timeout时间到达  3. 其他，正确执行，并且有就绪事件到达。结构体 timevalstruct timeval {  long tv_sec; /* seconds */  long tv_usec; /* microseconds */};文件描述符集 fd_set 操作函数void FD_CLR(int fd, fd_set *set); 把文件描述符集合里fd清 0int FD_ISSET(int fd, fd_set *set); 测试文件描述符集合里fd是否置 1void FD_SET(int fd, fd_set *set); 把文件描述符集合里fd位置 1void FD_ZERO(fd_set *set); 把文件描述符集合里所有位清 0</code></pre><p>select 函数参数众多，从函数原型上看得到所以然，下面展示模板代码，理解起来稍微不易，需要认真思考分析。</p><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/select.h&gt;#include &quot;wrap.h&quot;#define SERVER_PORT 8000#define BUF_SIZE 1024int main(int argc ,char *argv[]){    struct sockaddr_in serveraddr, clientaddr;    socklen_t clientlen;    char buf[BUF_SIZE];    // INET_ADDRSTRLEN 宏，ipv4地址大小    char clientip[INET_ADDRSTRLEN];    int readlen, sockfd, connfd;    int maxfd, maxi,i;    int selectfd;    // FD_SETSIZE 大小为 1024    int clientset[FD_SETSIZE];    // select 中需要的文件描述符集    fd_set curset, oriset;    sockfd = Socket(AF_INET,SOCK_STREAM,0);    bzero(&amp;serveraddr,sizeof (serveraddr));    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);    serveraddr.sin_port = htons(SERVER_PORT);    Bind(sockfd,(struct sockaddr *)&amp;serveraddr,sizeof (serveraddr));    Listen(sockfd,20);    maxi = -1;    maxfd = sockfd;    // 初始化 clientset    for(i=0; i &lt; FD_SETSIZE; i++){        clientset[i] = -1;    }    // 清空 oriset，将 sockfd 加入监听    FD_ZERO(&amp;oriset);    FD_SET(sockfd,&amp;oriset);    printf(&quot;Select... \n&quot;);    //　循环监测socket文件描述符    for(;;){        curset = oriset;        // 使用select监测scoket文件，监测读断，返回链接服务器的客户端个数        // 由于参数位 &amp;curset 是传入传出参数，每次调用 select 都会发生改变。这里采用临时备份值记录        // 监听最大文件描述符 sockfd+1，只关心读数据到达，不关心写数据到达，异常数据到达，阻塞式        selectfd = select(maxfd+1,&amp;curset,NULL,NULL,NULL);        // 有数据到达，做处理判断，返回已到达的链接数        if(selectfd &lt; 0)            perr_exit(&quot;select&quot;);        //　检查读文件描述符集set中sockfd是否被置位，即是否有新客户端链接上，处理新客户端链接上操作        if(FD_ISSET(sockfd,&amp;curset)){            // sockfd 文件描述符有读到达，即有客户端链接请求            clientlen = sizeof (clientaddr);            // 调用Accept，内核分配文件描述符进行数据交互            connfd = Accept(sockfd,(struct sockaddr *)&amp;clientaddr,&amp;clientlen);            printf(&quot;Clinet IP: %s, port: %d \n&quot;,                   inet_ntop(AF_INET,&amp;clientaddr.sin_addr,clientip,INET_ADDRSTRLEN),                   ntohs(clientaddr.sin_port)                   );            //　将产生的数据交互文件描述符添加到数据集合中，等待下一轮轮训统一处理            for(i = 0; i&lt; FD_SETSIZE;i++){                if(clientset[i] &lt; 0){                    clientset[i] = connfd;                    break;                }            }            // 异常监测，链接数大于可承载范围1024            if(i == FD_SETSIZE){                fputs(&quot;too many clients!!!&quot;,stderr);                exit(1);            }            //　将分配的新文件描述符（客户端链接上，用于数据交互）添加到 select 中继续监听是否有数据到达            FD_SET(connfd,&amp;oriset);            // 更新 select 内最大文件描述符值（新加入一个）            if(connfd &gt; maxfd)                maxfd = connfd;            // 此处的 maxi 为监听文件描述符数组内的数量，用于后续统一进行数据交互之用            if(i &gt; maxi)                maxi = i;            // 这句代码需要重点理解，进入此模块，前提是有新客户端请求链接，客户端通信数据需要判断            // 1. select监听到 1个读数据到达，那么就是新客户端链接请求（上面处理完），直接返回开头重新监听新客户端链接请求和已连接上客户端的数据交互请求            // 2. select监听到 2个及以上数据到达，进入此模块肯定有新客户端链接请求（已对其分配描述符，可以进行数据交互），此时--select不为 0，继续向下处理已连接上的客户端数据交互请求            if( --selectfd == 0)                continue;        }        // select 监听到数据到达返回，但不是新的客户端链接上的请求，这里统一处理已连接上客户端的数据交互        // 遍历 clientset，统一处理客户端数据请求        for(i =0;i&lt;=maxi;i++){            int temp = clientset[i];            if(temp&lt;0)                continue;            // 找出数据到达的文件描述符，处理具体的客户端数据请求            if(FD_ISSET(temp,&amp;curset)){                if((readlen = Read(temp,buf,BUF_SIZE)) == 0){                    // client端关闭连接，服务端也将关闭                    // 关闭链接文件描述符                    Close(temp);                    // 修改set集合对应元素                    clientset[i] = -1;                    //　清除监听select中set元素                    FD_CLR(temp,&amp;oriset);                    maxfd--;                }else {                    // 服务器具体的数据回传处理                    for(int j=0;j&lt;readlen;j++)                        buf[j] = toupper(buf[j]);                    Write(temp,buf,readlen);                }                // 自减 select 返回的数据到达数量，避免不必要的遍历操作                if( --selectfd == 0)                    break;            }        }    }    Close(sockfd);    return 0;}</code></pre><p>上述代码有相关的注释说明，有以下几点要注意：</p><ol><li>select 返回数据改变的文件描述符个数，需要对其个数进行具体分析</li><li>select返回 1，判断是新客户端链接请求，Accept分配描述符进行数据读写，加入 select 监听，更新中间变量，加入 clientset 数据集监听数据交互请求，后续统一数据交互处理，–select后为 0 直接返回开头，select 重新监听</li><li>select返回大于 1，判断是否有新客户端链接请求，是则同上 1 处理后，–select后不为 0，进入第二层 for 循环，统一处理客户端的数据交互</li><li>select 返回 1或者大于 1，但不是新客户端链接请求，那么进入底层 for 循环，统一处理客户端的数据交互请求</li><li>底层for遍历循环中，遍历 clientset 数据集，通过 select 返回的 curset，找出具体文件描述符一一进行回复，处理完成一个， –select</li><li>当数据处理中发现有客户端断开（读数据长度为0），需要将 clientset 中对应为清除，同时 select 中对应的 fd_set 文件描述符集对应元素也要清除，</li><li>当–select后为 0时，代表 select 中监听到数据到达都已经处理完成了，循环结束，重新开始 select 的监听</li></ol><h3 id="小结-select-服务器模型"><a href="#小结-select-服务器模型" class="headerlink" title="小结 select 服务器模型"></a>小结 select 服务器模型</h3><p>select相比多进程多线程高效的原因</p><p>首先要知道一个概念，一次I/O分两个部分（①等待数据就绪 ②进行I/O），减少等的比重，增加I/O的比重就可以达到高效服务器的目的。select工作原理就是这个，同时监控多个文件描述符（或者说文件句柄），一旦其中某一个进入就绪状态，就进行I/O操作。监控多个文件句柄可以达到提高就绪状态出现的概率，就可以使CPU在大多数时间下都处于忙碌状态，大大提高CPU的性能。达到高效服务器的目的。 可以理解为select轮询监控多个文件句柄或套接字。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>不需要建立多个线程、进程就可以实现一对多的通信。</li><li>可以同时等待多个文件描述符，效率比起多进程多线程来说要高很多</li><li>跨平台性，windows、linux、micOS、unix、mips都支持 select</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>每次进行 select 都要把文件描述符集 fd 由用户态拷贝到内核态，这样的开销会很大</li><li>实现 select 服务器，内部要不断对文件描述符集 fd 进行循环遍历，当 fd 很多时，开销也很大</li><li>select 能监控文件描述符的数量有限，一般为1024。（sizeof（fd_set） * 8 = 1024（fd_set内部是以位图表示文件描述符））</li></ol><h4 id="pselect"><a href="#pselect" class="headerlink" title="pselect"></a>pselect</h4><p>pselect 相比 select 支持了信号屏蔽字的操作，函数原型如下</p><pre><code>#include &lt;sys/select.h&gt;int pselect(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask);struct timespec {  long tv_sec; /* seconds */  long tv_nsec; /* nanoseconds */};</code></pre><p>用sigmask替代当前进程的阻塞信号集,调用返回后还原原有阻塞信号集，具体代码略</p><p><a href="https://blog.csdn.net/qq_35116371/article/details/75020664" target="_blank" rel="noopener">参考博客1</a></p><p><a href="https://blog.csdn.net/weixin_40204595/article/details/83212900" target="_blank" rel="noopener">参考博客2</a></p><h2 id="poll-服务器模型"><a href="#poll-服务器模型" class="headerlink" title="poll 服务器模型"></a>poll 服务器模型</h2><p>poll 的机制与 select 类似，与 select 在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是 poll 没有最大文件描述符数量的限制。</p><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><pre><code>#include &lt;poll.h&gt;int poll(struct pollfd *fds, nfds_t nfds, int timeout);struct pollfd {  int fd; /* 文件描述符 */  short events; /* 监控的事件 */  short revents; /* 监控事件中满足条件返回的事件 */};events取值：  POLLIN普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND  POLLRDNORM-数据可读  POLLRDBAND-优先级带数据可读  POLLPRI 高优先级可读数据  POLLOUT普通或带外数据可写  POLLWRNORM-数据可写  POLLWRBAND-优先级带数据可写  POLLERR 发生错误  POLLHUP 发生挂起  POLLNVAL 描述字不是一个打开的文件nfds 监控数组中有多少文件描述符需要被监控timeout 毫秒级等待  -1: 阻塞等,#define INFTIM，-1 Linux中没有定义此宏  0: 立即返回,不阻塞进程  &gt;0: 等待指定毫秒数,如当前系统时间精度不够毫秒,向上取值返回值：  返回监控文件描述符状态改变的个数，等待超时返回 0，失败返回 -1，设置 errno</code></pre><p>函数相关说明：</p><ol><li>结构体 pollfd 指定了一个被监视的文件描述符，可以传递结构体数组，指示 poll 监视多个文件描述符。每个结构体的 events 域是监视该文件描述符的事件掩码，由用户来设置这个域。revents 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。events 域中请求的任何事件都可能在 revents 域中返回</li><li>POLLIN | POLLPRI 等价于 select() 的读事件，POLLOUT |POLLWRBAND 等价于 select() 的写事件。POLLIN 等价于 POLLRDNORM |POLLRDBAND，而 POLLOUT 则等价于 POLLWRNORM。例如，要同时监视一个文件描述符是否可读和可写，我们可以设置 events 为 POLLIN |POLLOUT。在 poll 返回时，我们可以检查 revents 中的标志，对应于文件描述符请求的 events 结构体。如果 POLLIN 事件被设置，则文件描述符可以被读取而不阻塞。如果 POLLOUT 被设置，则文件描述符可以写入而不导致阻塞。这些标志并不是互斥的：它们可能被同时设置，表示这个文件描述符的读取和写入操作都会正常返回而不阻塞。</li><li>成功时，poll() 返回结构体中 revents 域不为 0 的文件描述符个数；如果在超时前没有任何事件发生，poll() 返回 0；失败时，poll() 返回 -1，并设置 errno。</li></ol><h3 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;poll.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;errno.h&gt;#include &quot;wrap.h&quot;#define BUF_SIZE 1024#define SERVER_PORT 8000#define FILE_MAX 1024int main(int argc,char  *argv[]){    int i,j, maxi, ready,readlen;    int sockfd, tempfd, connfd;    socklen_t clientlen;    struct sockaddr_in serveraddr, clientaddr;    struct pollfd clientset[FILE_MAX];    char buf[FILE_MAX], clientip[INET_ADDRSTRLEN];    sockfd = Socket(AF_INET,SOCK_STREAM,0);    bzero(&amp;serveraddr,sizeof (serveraddr));    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);    serveraddr.sin_port = htons(SERVER_PORT);    Bind(sockfd,(struct sockaddr *)&amp;serveraddr,sizeof (serveraddr));    Listen(sockfd,20);    // 将客户端集合0号元素置位于sockfd,设置元素监听为普通数据可读    clientset[0].fd = sockfd;    clientset[0].events = POLLRDNORM;    // 初始化其他元素，注意此时从１开始    for(i = 1;i&lt; FILE_MAX;i++){      clientset[i].fd = -1;    }    maxi = 0;    printf(&quot;poll...\n&quot;);    for(;;){        // 阻塞式监听文件描述符事件sockfd,注意参数为集合元素个数，返回状态改变的文件描述符个数        ready = poll(clientset,maxi+1,-1);        // 0 元素存在数据可读状态        if(clientset[0].revents &amp; POLLRDNORM){            // 为新链接客户端分配新的描述符            clientlen = sizeof (clientaddr);            connfd = Accept(sockfd,(struct sockaddr *)&amp;clientaddr,&amp;clientlen);            printf(&quot;received from: %s at PORT: %d\n&quot;,                   inet_ntop(AF_INET, &amp;clientaddr.sin_addr, clientip, INET_ADDRSTRLEN),                   ntohs(clientaddr.sin_port));            // 遍历数组 clientset，将新客户端分配的数据交互描述符添加到 poll 监听中            for(i =1;i&lt;FILE_MAX;i++){                if(clientset[i].fd &lt; 0){                    clientset[i].fd = connfd;                    clientset[i].events = POLLRDNORM;                    break;                }            }            // 临界数据检测            if(i &gt;= FILE_MAX)                perr_exit(&quot;too many clients&quot;);            // 初始值为 0，poll 监测个数为 maxi+1，遍历时 i 从 1 开始            if(i &gt; maxi)                maxi = i;            // 只有一个事件是有新客户端链接，分配新的描述子并添加到监听中，跳出此次循环从头开始从新监听            if(--ready &lt;= 0)                continue;        }        // 遍历处理监听字符集内数据相应,此时只对　1 后面的字符集和操作        // 注意此处截止到 (i &lt;= maxi)        for(i=1; i &lt;= maxi; i++){            tempfd = clientset[i].fd;            if(tempfd&lt;0)                continue;            if(clientset[i].revents &amp; (POLLRDNORM | POLLERR)){                if((readlen = Read(tempfd,buf,BUF_SIZE))&lt;0){                    // 数据交互收到 RST 标志                    if(errno == ECONNABORTED){                        printf(&quot;client[%d] aborted connection&quot;,i);                        Close(tempfd);                        clientset[i].fd = -1;                    }else {                        perr_exit(1);                    }                }else if (readlen == 0) {                    // 数据读出0，客户端关闭了                    printf(&quot;client[%d] closed connection&quot;,i);                    Close(tempfd);                    clientset[i].fd = -1;                }else {                    // 正常数据交互                    for(j=0;j&lt;readlen;j++){                        buf[j] = toupper(buf[j]);                    }                    Write(tempfd,buf,readlen);                }                // 遍历结束条件，状态改变文件描述符个数减为 0                if(--ready ==0)                    break;            }        }    }    Close(sockfd);    return 0;}</code></pre><p>上述代码和 select逻辑基本相似，只是采用了 poll 方式，逻辑上与 select 并无二至，有以下几点说明</p><ol><li>poll 第一个参数接受了一个数组，监测一个 pollfd 的数组最大为 1024</li><li>poll 返回监测文件描述符数组内状态改变的个数，同样通过 poll 返回值，遍历处理其中的对应文件描述符的数据</li><li>初始化时候，0 号元素对应sockfd， 后面的数据处理中需要从 1 开始，中间变量的矫正需要注意 maxi 的值</li><li>状态发生改变的文件描述符，通过传出参数 revents来获取，通过其位状态，判断其数据是否可读可写</li><li>对于不想监听的某个描述符时候，直接将其 pollfd 中的 fd 置位 -1，poll 将不再对其监听<br>6。 具体的处理流程详见 select 中说明。</li></ol><h3 id="poll-小结"><a href="#poll-小结" class="headerlink" title="poll 小结"></a>poll 小结</h3><ol><li>poll 和 select 原理上都是通过轮训的方式对文件描述符进行监控，相比于 select 来说，poll 不限制文件描述符 1024</li><li>其自定义结构体 pollfd 内实现了监听事件和返回事件分离。但是其不能跨平台，只能在linux中使用。无法直接定位满足监听事件的文件描述符，需要轮询数组</li><li>poll 和 select 同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大</li><li>ppoll 为 poll 的升级版本，GNU定义了 ppoll(非 POSIX 标准),可以支持设置信号屏蔽字,具体代码略</li></ol><p><a href="https://blog.csdn.net/weixin_40204595/article/details/83212900" target="_blank" rel="noopener">参考链接</a></p><h2 id="epoll-服务器模型"><a href="#epoll-服务器模型" class="headerlink" title="epoll 服务器模型"></a>epoll 服务器模型</h2><p>目前 epell 是 linux 大规模并发网络程序中的热门首选模型。</p><p>epoll 是 Linux 下多路复用IO接口 select/poll 的增强版本,它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。epoll 模型相对 select、poll 来说不再是一个系统函数，而是需要具体的 api 来支持，因此其效率异常高效。</p><h3 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h3><p>epoll 不再是一个单独的系统调用，而是由 epoll_create、epoll_ctl、epoll_wait 三个系统调用组成。如下：</p><h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><p>创建一个epoll句柄,参数size用来告诉内核监听的文件描述符个数,跟内存大小有关。</p><pre><code>#include &lt;epoll.h&gt;int epoll_create(int size)size: 告诉内核监听的数目返回值： 成功时，返回一个非负整数的文件描述符，作为创建好的 epoll 句柄。调用失败时，返回 -1，错误信息可以通过 errno 获得</code></pre><p> 说明：<br> 创建一个 epoll 句柄，size 用来告诉内核这个监听的数目一共有多大。这个参数不同于 select 中的第一个参数，给出最大监听的 fd+1 的值。需要注意的是，当创建好 epoll 句柄后，它就是会占用一个 fd 值，所以在使用完 epoll 后，必须调用 close 关闭，否则可能导致 fd 被耗尽。</p><h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><p>控制某个epoll监控的文件描述符上的事件:注册、修改、删除。</p><pre><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);epfd： epoll_create 函数返回的 epoll 句柄op： 操作选项，可选值有以下3个  EPOLL_CTL_ADD：注册新的 fd 到 epfd 中；  EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件；  EPOLL_CTL_DEL：从epfd中删除一个 fd；fd： 要进行操作的目标文件描述符event： struct epoll_event结构指针，将fd和要进行的操作关联起来。返回值： 成功时，返回 0，作为创建好的 epoll 句柄。调用失败时，返回 -1，错误信息可以通过 errno 获得。</code></pre><p>相关说明：</p><ol><li><p>epoll 的事件注册函数，它不同与 select 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</p></li><li><p>struct epoll_event结构如下：</p><pre><code>typedef union epoll_data {    void *ptr;    int fd;    __uint32_t u32;    __uint64_t u64;  } epoll_data_t;  struct epoll_event {    __uint32_t events; /* Epoll events */    epoll_data_t data; /* User data variable */  };</code></pre></li><li><p>结构体 epoll_event 中 events可以是以下几个宏的集合</p><pre><code>EPOLLIN： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；EPOLLOUT： 表示对应的文件描述符可以写；EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；EPOLLERR： 表示对应的文件描述符发生错误；EPOLLHUP： 表示对应的文件描述符被挂断；EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。EPOLLONESHOT： 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</code></pre></li></ol><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>等待所监控文件描述符上有事件的产生,类似于select()调用。</p><pre><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);epfd： epoll_create 函数返回的 epoll 句柄events： struct epoll_event 结构指针，用来从内核得到事件的集合maxevents： 告诉内核这个 events 有多大timeout: 等待时的超时时间，以毫秒为单位返回值： 成功时，返回需要处理的事件数目。调用失败时，返回 0，表示等待超时</code></pre><p>说明：</p><p>epoll_wait 调用成功后，返回处理数目大小，待处理数据文件描述符都被封装到了 epoll_event * events 中去，此时只需要遍历这里面的数据就可以了，大大提高效率</p><h3 id="实例代码-2"><a href="#实例代码-2" class="headerlink" title="实例代码"></a>实例代码</h3><pre><code>#include &quot;wrap.h&quot;#include &lt;sys/epoll.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;errno.h&gt;#include &lt;netinet/in.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define SERVER_PORT 8000#define BUF_SIZE 1024#define FILE_MAX 1024int main(int argc,char *argv[]){    int sockfd, connfd,tempfd;    int i,j, maxi, ready, epfd, readlen;    socklen_t clientlen;    char buf[BUF_SIZE], clientip[INET_ADDRSTRLEN];    int clientset[FILE_MAX];    struct sockaddr_in serveraddr,clientaddr;    struct epoll_event temp_event, ep_events[FILE_MAX];    sockfd = Socket(AF_INET,SOCK_STREAM,0);    // 初始化服务器地址参数    bzero(&amp;serveraddr,sizeof (serveraddr));    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);    serveraddr.sin_port = htons(SERVER_PORT);    // 执行绑定    Bind(sockfd,(struct sockaddr *)&amp;serveraddr,sizeof (serveraddr));    // 执行listen    Listen(sockfd,20);    // 初始化局部参数，已链接客户端数据集    for(i = 0; i&lt; FILE_MAX;i++){        clientset[i] = -1;    }    maxi = -1;    //　创建 epoll 句柄    epfd = epoll_create(FILE_MAX);    if(epfd == -1){        perr_exit(&quot;epoll_create&quot;);    }    //　操作句柄监听事件    temp_event.events = EPOLLIN;    temp_event.data.fd = sockfd;    // 将 sockfd 加入到 epoll 监听中，监测事件为 EPOLLIN    int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,sockfd,&amp;temp_event);    if(ret ==-1){        perr_exit(&quot;epoll_ctl sockfd&quot;);    }    printf(&quot;epoll_wait...\n&quot;);    // 循环监听事件发生    for(;;){        // 阻塞等待链接事件发生        ready = epoll_wait(epfd,ep_events,FILE_MAX,-1);        if(ready == -1){            perr_exit(&quot;epoll_wait&quot;);        }        // 遍历描述符变化的数据集 ep_events        for(i = 0;i&lt;ready;i++){            // 非数据读入事件，跳出此循环，继续阻塞等待下次事件发生            if(!(ep_events[i].events &amp; EPOLLIN))                continue;            // sockfd 描述符有状态变化，即有新的客户端链接请求，执行 accept            if (ep_events[i].data.fd == sockfd) {                clientlen = sizeof (clientaddr);                // 为新链接客户端分配新的描述符                connfd = Accept(sockfd,(struct sockaddr *)&amp;clientaddr,&amp;clientlen);                printf(&quot;received from: %s at PORT: %d\n&quot;,                       inet_ntop(AF_INET, &amp;clientaddr.sin_addr, clientip, INET_ADDRSTRLEN),                       ntohs(clientaddr.sin_port));                //　加入到服务端集合,for 结束后，j 的值为已链接客户端数目                for(j =0; j&lt; FILE_MAX;j++){                    if(clientset[j] &lt; 0){                        clientset[j] = connfd;                        break;                    }                }                // 矫正局部参数变量                if(j &gt; FILE_MAX)                    perr_exit(&quot;too many clients&quot;);                if(j&gt;maxi)                    maxi = j;                //　将新分配的客户端描述符添加到 epoll 监听中客户端的数据请求                temp_event.data.fd = connfd;                temp_event.events = EPOLLIN;                int ret = epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;temp_event);                if(ret == -1)                    perr_exit(&quot;epoll_ctl sockfd&quot;);            } else {                // 此处为客户端请求服务器进行数据交互操作                // 遍历取出客户端集合中对应数据进行处理                tempfd = ep_events[i].data.fd;                readlen = Read(tempfd,buf,BUF_SIZE);                // 数据读出为0,客户端关闭了                if(readlen == 0){                    // 客户端关闭，删除 clientset 集合元素，删除 epoll_event 监听事件，关闭 socket 文件                    for(j = 0;j&lt;maxi;j++){                        if(clientset[j] = tempfd)                            clientset[i]=-1;                        break;                    }                    // 客户端关闭了，解除 epoll 中对应文件描述符的监听                    int ret = epoll_ctl(epfd,EPOLL_CTL_DEL,tempfd,NULL);                    if(ret == -1){                        perr_exit(&quot;epoll_ctl del&quot;);                    }                    Close(tempfd);                    printf(&quot;clientset[%d] closed connection! \n&quot;, i);                }else {                    // 数据读出不为 0,正常数据请求操作                    for(j =0; j&lt; readlen;j++){                        buf[j]= toupper(buf[j]);                    }                    Write(tempfd,buf,readlen);                }            }        }    }    //程序结束，关闭 socket 文件，关闭 epoll 句柄    Close(sockfd);    close(epfd);    return 0;}</code></pre><p>程序说明：</p><ol><li>epoll 监听文件描述符，要事先通过 epoll_create 创建句柄，然后将需要监听的描述符信息填充到结构体中，最后通过 epoll_ctl 函数设置到 epoll 中去</li><li>epoll 监听到文件描述符有数据到达，直接通过函数 epoll_wait中的 ep_events 参数，将文件描述符集传递出来，只需要对其进行遍历即可</li><li>由于遍历的文件描述符集就是有数据改变的文件描述符，因此效率非常高，避免无用的遍历操作</li><li>不同于 select、poll，epoll 完全没有文件描述符的限制，只限制于进程可打开文件数量的最大值（可修改），使用完成后需要关闭 epoll_create 创建的句柄</li></ol><p>相关补充：</p><p>一个进程打开大数目的socket描述符</p><pre><code>cat /proc/sys/fs/file-max</code></pre><p>设置最大打开文件描述符限制</p><pre><code>sudo vi /etc/security/limits.conf写入以下配置,soft软限制,hard硬限制* soft nofile 65536* hard nofile 100000</code></pre><h3 id="epoll总结"><a href="#epoll总结" class="headerlink" title="epoll总结"></a>epoll总结</h3><p>epoll 是 Linux 内核为处理大批量文件描述符而作了改进的 poll，是 Linux 下多路复用IO接口 select/poll 的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p><p>epoll除了提供 select/poll 那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少 epoll_wait/epoll_pwait 的调用，提高应用程序效率。epoll支持一个进程打开大数目的 socket 描述符，io效率不随 fd 数目增加而线性下降，使用 mmap 加速内核与用户空间的消息传递。</p><p>epoll 相比 select、poll 的优势：</p><ol><li>支持一个进程打开大数目的socket描述符</li><li>IO效率不随FD数目增加而线性下降</li><li>内核微调</li></ol><p><a href="https://blog.csdn.net/iEearth/article/details/46738555" target="_blank" rel="noopener">参考链接</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章节主要介绍了 Linux 下几种常见的多路IO转接模型，以适应高并发，大数据量服务器编程实例，每个模型都有详细的代码演示和说明，相信读者看完心中会有所收货，也仅此作为自己的学习笔记，后续遗忘追溯回来，看两眼代码就能够想起来。</p><p>在博客撰文中，搜集到网络上前辈们写的一些博文，文章角度和思考深度都值得学习，希望大家看博文期间多参考文章后面的链接，多总结思考，相信会收获更多的。</p><h3 id="几种模型的优缺点比较"><a href="#几种模型的优缺点比较" class="headerlink" title="几种模型的优缺点比较"></a>几种模型的优缺点比较</h3><p>直接看下表:</p><table><thead><tr><th style="text-align:center">函数模型</th><th style="text-align:center">select</th><th style="text-align:center">poll</th><th style="text-align:center">epoll</th></tr></thead><tbody><tr><td style="text-align:center">事件集合</td><td style="text-align:center">内核会修改用户注册监听的文件描述符集，用以反馈就绪事件，每次调用 select 都需要重新填入监听文件描述符集</td><td style="text-align:center">使用 pollfd.events传入监听事件，使用 pollfd.revents来反馈就绪事件</td><td style="text-align:center">使用内内核事件表来管理用户事件，epoll_wait仅用来保存就绪事件</td></tr><tr><td style="text-align:center">程序索引就绪文件描述符集的时间复杂度</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">最大支持监听的文件描述符个数</td><td style="text-align:center">有限制，一般1024</td><td style="text-align:center">65535</td><td style="text-align:center">65535</td></tr><tr><td style="text-align:center">工作模式</td><td style="text-align:center">LT</td><td style="text-align:center">LT</td><td style="text-align:center">支持ET高效模式</td></tr><tr><td style="text-align:center">内核实现原理</td><td style="text-align:center">轮训方式</td><td style="text-align:center">轮训方式</td><td style="text-align:center">回调方式</td></tr></tbody></table><p>更多详细细节比较，参考链接如下：</p><p><a href="https://blog.csdn.net/sinat_31532941/article/details/80386944" target="_blank" rel="noopener">点我没错1</a></p><p><a href="http://www.embeddedlinux.org.cn/html/yingjianqudong/201303/11-2477.html" target="_blank" rel="noopener">点我没错2</a></p><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多路IO转接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之多进程、多线程并发服务器</title>
      <link href="/FuckCode/2019/01/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/FuckCode/2019/01/21/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>本章节就服务器的开章，仅介绍多进程，多线程下高并发服务器模型的实现。这两种模型实现简单，逻辑清晰，但同时局限性也很大，受限于系统资源以及文件描述符上限等，后续会就多路IO转接服务器进行进一步分析。</strong><br><a id="more"></a></p><h1 id="高并发服务器"><a href="#高并发服务器" class="headerlink" title="高并发服务器"></a>高并发服务器</h1><h2 id="多进程并发服务器"><a href="#多进程并发服务器" class="headerlink" title="多进程并发服务器"></a>多进程并发服务器</h2><p>多进程并发服务器，顾名思义，采用Linux下多进程机制，对于多个客户端链接请求，服务器端对应多个进程与其进行数据通信交互。可模型理解简单，代码实现也容易，但其缺点也显而易见，主要几种以下几个方面：</p><ol><li>父进程能够创建的最大文件描述个数(父进程中需要close关闭accept返回的新文件描述符)</li><li>系统内创建进程个数(内存大小相关)</li><li>进程创建过多是否降低整体服务性能(进程调度)</li></ol><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><pre><code>#include &quot;wrap.h&quot;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#define SERVER_PORT 8000#define BUF_SIZE 1024// 信号捕捉函数，处理子进程退出，回收系统资源void do_sigchild(void* arg){    // 0 -&gt; 回收和当前调用waitpid一组的所有子进程    // 即当前进程内的所有子进程    waitpid(0,NULL,WNOHANG);}int main(int argc, char *argv[]){    int sockfd,confd, readlen;    struct sockaddr_in serveraddr,clientaddr;    socklen_t clientaddr_len;    char clientIP[128];    char buf[BUF_SIZE];    pid_t pid;    // 设置信号捕追函数，捕追子进程退出，节约资源    struct sigaction newact;    newact.sa_flags = 0;    newact.sa_handler = do_sigchild;    sigemptyset(&amp;newact);    sigaction(SIGCHLD,&amp;newact,NULL);    sockfd = Socket(AF_INET, SOCK_STREAM, 0);    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);    serveraddr.sin_port = htons(SERVER_PORT);    Bind(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));    Listen(sockfd,30);    printf(&quot; Accepting connections ...\n&quot;);    while(1){        clientaddr_len = sizeof(clientaddr);        // 监听客户端链接，成功链接返回描述符，否则阻塞        confd = Accept(sockfd, (struct sockaddr*)&amp;clientaddr, &amp;clientaddr_len);        // 此时有客户端链接上服务器，创建子进程与其进行通信，父进程继续监听新的链接请求        pid = fork();        if(pid == 0){            // 子进程内，关闭父子进程继承的文件描述符，节约系统资源            Close(sockfd);            // 数据交互            while (1) {                readlen = Read(confd, buf, BUF_SIZE);                if (readlen == 0) {                    printf(&quot;the other side has been closed.\n&quot;);                    break;                }                printf(&quot;received from %s at PORT %d received: %s\n&quot;,                       inet_ntop(AF_INET, &amp;clientaddr.sin_addr, clientIP, sizeof(clientIP)),                       ntohs(clientaddr.sin_port),                       buf);                for (int i = 0; i &lt; readlen; i++)                    buf[i] = toupper(buf[i]);                Write(confd, buf, readlen);            }            // 数据交互结束，关闭socket链接，等待信号捕捉函数回收进程资源            Close(confd);            return 0;        }else if (pid &gt; 0) {            // 父进程内关闭链接客户端的描述符，父进程只关心链接情况，而不参与数据请求（子进程参与数据请求）            Close(confd);        }else {            // fork失败，退出            perr_exit(&quot;fork&quot;);        }    }}</code></pre><p>以上代码需要注意几点：</p><ol><li>子进程的回收处理需要在fork之前进程，因为信号捕捉函数会fork继承到子进程内，因为子进程的退出（发送SIGCHLD）可以得到处理，回收系统资源</li><li>进程的创建在链接请求操作完成之后进行，如果没有客户端链接，那么就没有子进程创建</li><li>父进程只负责监听客户端链接，分配描述符进行子进程的创建，继承下来的通信confd描述符需要关闭</li><li>子进程也需要关闭继承下来的sockfd，子进程只关心数据通信通信（confd），进一步节省系统资源</li></ol><p>从模型中可以看出，多进程下高并发服务器下，对于进程的创建开销极其大，非常考验系统内存容量，并且受限于文件描述符的大小。为了进一步节省资源，需要对进程内不需要使用的文件描述的进行适当的关闭。同时，新的链接请求产生，就意味着新进程的创建，因此高并发下多个客户端同时链接，会造成服务器某一时刻负载极其大，容易出现未知的问题。</p><h3 id="Clinet"><a href="#Clinet" class="headerlink" title="Clinet"></a>Clinet</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet/in.h&gt;#include &quot;wrap.h&quot;#define MAXLINE 80#define SERV_PORT 8000int main(int argc, char *argv[]){    struct sockaddr_in servaddr;    char buf[MAXLINE];    int sockfd, n;    char ServerIP[] =&quot;127.0.0.1&quot;;    sockfd = Socket(AF_INET, SOCK_STREAM, 0);    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sin_family = AF_INET;    inet_pton(AF_INET, ServerIP, &amp;servaddr.sin_addr);    servaddr.sin_port = htons(SERV_PORT);    Connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));    while (fgets(buf, MAXLINE, stdin) != NULL) {        Write(sockfd, buf, strlen(buf));        n = Read(sockfd, buf, MAXLINE);        if (n == 0)            printf(&quot;the other side has been closed.\n&quot;);        else            Write(STDOUT_FILENO, buf, n);    }    Close(sockfd);    return 0;}</code></pre><p>客户端代码就容易许多了，主要进行连接服务器，等待用户输入字符传入服务器处理，再将服务器回传数据显示打印到输出窗口中。</p><h2 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a>多线程并发服务器</h2><p>从上面介绍的多进程服务模型可以推出，多线程服务模型也就是将进程概念转换为线程而已，但是考虑创建线程的开销肯定比进程来的小，所以多线程高并发服务器还是有一定的优势的。</p><p>多线程下高并发服务器的编程中需要注意以下几点：</p><ol><li>调整进程内最大文件描述符上限</li><li>线程如有共享数据,考虑线程同步</li><li>服务于客户端线程退出时,退出处理。(退出值,分离态)</li><li>系统负载,随着链接客户端增加,导致其它线程不能及时得到CPU</li></ol><h3 id="Server-1"><a href="#Server-1" class="headerlink" title="Server"></a>Server</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;pthread.h&gt;#include &quot;wrap.h&quot;#define MAXLINE 80#define SERV_PORT 8000#define MAX_PTHREAD_SIZE 256// 自定义结构体，存储客户端地址以及对应的服务器connfdstruct s_info {    struct sockaddr_in cliaddr;    int connfd;};// 线程工作载入实体void *do_work(void *arg){    int n,i;    // 强转数据，得到s_info    struct s_info *ts = (struct s_info*)arg;    char buf[MAXLINE];    char str[INET_ADDRSTRLEN];    /* 可以在创建线程前设置线程创建属性,设为分离态,哪种效率高内? */    pthread_detach(pthread_self());    while (1) {        n = Read(ts-&gt;connfd, buf, MAXLINE);        if (n == 0) {            // 客户端关闭，跳出循环            printf(&quot;the other side has been closed.\n&quot;);            break;        }        printf(&quot;received from %s at PORT %d\n&quot;,               inet_ntop(AF_INET, &amp;(*ts).cliaddr.sin_addr, str, sizeof(str)),               ntohs((*ts).cliaddr.sin_port));        for (i = 0; i &lt; n; i++)            buf[i] = toupper(buf[i]);        Write(ts-&gt;connfd, buf, n);    }    // 客户端关闭，服务端线程关闭文件描述符    // 由于线程已置位分离态，系统自动回收线程资源    Close(ts-&gt;connfd);}int main(void){    struct sockaddr_in servaddr, cliaddr;    socklen_t cliaddr_len;    int listenfd, connfd;    int i = 0;    pthread_t tid;    // 配置同一时刻线程峰值数    struct s_info ts[MAX_PTHREAD_SIZE];    listenfd = Socket(AF_INET, SOCK_STREAM, 0);    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);    servaddr.sin_port = htons(SERV_PORT);    Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));    Listen(listenfd, 20);    printf(&quot;Accepting connections ...\n&quot;);    // 主函数内主负责监听客户端链接，创建子线程    while (1) {        cliaddr_len = sizeof(cliaddr);        connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);        // 将必要的信息封装到结构体传入子线程中        ts[i].cliaddr = cliaddr;        ts[i].connfd = connfd;        /* 达到线程最大数时,pthread_create出错处理, 增加服务器稳定性 */        pthread_create(&amp;tid, NULL, do_work, (void*)&amp;ts[i]);        i++;        // 子线程数量过载，退出        if(i&gt;=MAX_PTHREAD_SIZE)            break;    }    Close(listenfd);    return 0;}</code></pre><p>以上代码仅仅是个模型，许多细节有待优化，集中以下几点：</p><ol><li>线程峰值数量问题：上述采用的数组容器，其峰值预先定好，对于先前创建的线程因为客户端关闭而退出，后被系统回收了情况下，此时数组容器应当记录并将给予新创建的子线程使用</li><li>子线程创建时分离态的问题：子线程创建之前就通过 pthread_attr_setdetachstate 设置，相比创建时通过 pthread_detach 来说，更有效率</li><li>和多进程模型相似，新链接的产生，对应子线程的创建，同一时刻下过多客户端链接下多线程的创建造成服务器负载过高的问题</li><li>进程pcb大小问题，适当提高进程下线程数量，也可以提高多线程高并发下的优势</li></ol><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>客户端不涉及多进程和多线程概念，同上多进程下 Client 代码一致，此处不再贴源码了。</p><h2 id="线程池并发服务器"><a href="#线程池并发服务器" class="headerlink" title="线程池并发服务器"></a>线程池并发服务器</h2><p>通过以上两个高并发服务器，都有一个共同特点，那就是一对一的数据交互服务连接。一个客户端，服务器分配一个进程或者线程与其对接完成数据交互。然而应用到现实中去，如果同一时间多个客户端同时访问链接服务器，那么对于服务器端的负载过大是显而易见的，因此在此基础上，有一种更加高效的模型就诞生了，线程池高并发服务器。</p><p>同样采用线程来处理客户端的数据请求，事先分配一定数额的工作线程，然后由一个线程池管理。线程池内约束一定量的线程数量，优先保障这些线程的工作效率。先到来的客户端链接请求会优先得到线程的处理，如果同一时刻客户端访问过多，那么后面需要链接请求的，就需要等待工作线程处理结束，才能得到响应。</p><h3 id="Server-2"><a href="#Server-2" class="headerlink" title="Server"></a>Server</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#define MAX 10int fds[MAX]={0};sem_t sem;// 静态初始化锁pthread_mutex_t luck = PTHREAD_MUTEX_INITIALIZER;void fds_init(){    pthread_mutex_lock(&amp;luck);    int i=0;    for(;i&lt;MAX;i++)    {        fds[i]=-1;    }    pthread_mutex_unlock(&amp;luck);}int fds_add(int c){    pthread_mutex_lock(&amp;luck);    int i=0;    for(;i&lt;MAX;i++)    {        if(fds[i]==-1)        {            fds[i]=c;            return 1;        }    }    pthread_mutex_unlock(&amp;luck);    return 0;}void fds_sub(int c){    pthread_mutex_lock(&amp;luck);    int i=0;    for(;i&lt;MAX-1;i++)    {        fds[i]=fds[i+1];        if(fds[i+1]==-1)            break;    }    pthread_mutex_unlock(&amp;luck);    fds[MAX-1]=-1;}int fds_get(){    pthread_mutex_lock(&amp;luck);    int i=0;    for(;i&lt;MAX;i++)    {        if(fds[i]!=-1)        {            int c=fds[i];            fds_sub(c);            return c;        }    }    pthread_mutex_unlock(&amp;luck);    return -1;}// 线程函数载入实体void *pthread_fun(void *arg){    while(1)    {        // 获取信号量，有剩余空余线程即进入，否则等待信号号产生        sem_wait(&amp;sem);        // 通过锁机制获取待处理的客户端链接请求        int c=fds_get();        while(1)        {            char buff[128]={0};            int n = Read(c,buff,127);            if(n&lt;=0)            {                Close(c);                break;            }            Write(c,&quot;I accept&quot;,sizeof(&quot;I accept&quot;));        }    }}int main(){    // 初始化信号量    sem_init(&amp;sem,0,0);    // 初始化    fds_init();    // 线程池工作队列 3 个    for(int i=0;i&lt;3;i++)    {        pthread_t id;        int rt=pthread_create(&amp;id,NULL,(void *)pthread_fun,NULL);        assert(rt==0);    }    int sockfd=Socket(AF_INET,SOCK_STREAM,0);    assert(sockfd!=-1);    struct sockaddr_in ser,cli;    memset(&amp;ser,0,sizeof(ser));    ser.sin_family=AF_INET;    ser.sin_addr.s_addr=inet_addr(&quot;127.0.0.1&quot;);    ser.sin_port=htons(8000);    int res=Bind(sockfd,(struct sockaddr *)&amp;ser,sizeof(ser));    assert(res!=-1);    Listen(sockfd,5);    printf(&quot;Accepting connections ...\n&quot;);    while(1)    {        int len=sizeof(cli);        int c=Accept(sockfd,(struct sockaddr *)&amp;cli,&amp;len);        if(c&gt;=0)        {            if(!fds_add(c))            {                printf(&quot;Please wait a memmet&quot;);                Close(c);                continue;            }            // 产生一个信号量，其中一个工作线程开始处理            sem_post(&amp;sem);        }        else        {            printf(&quot;error\n&quot;);            continue;        }    }}</code></pre><p>上述代码中：</p><ol><li>线程池维护三个固定线程，其主要负责处理客户端的请求</li><li>客户端同时链接请求峰值为 10，同时得到响应的是工作线程峰值 3，其他的记录在数组中，工作线程处理完成后通过取得信号量，继续处理</li><li>工作线程处理请求时，使用锁机制保证各个线程处理请求时数据唯一</li><li>工作线程中有两个循环，内层循环处理和已连接上的客户端进行数据交互，外层循环监测信号量，处理文件描述符集合新的客户端请求</li></ol><p><a href="https://blog.csdn.net/zhuoya_/article/details/78724637" target="_blank" rel="noopener">参考链接</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章主要对Linux下高并发服务中常见的多进程，多线程模型进行实现，其模型搭建简单快速，但是局限性也很大。一来进程和线程的频繁创建太消耗资源（一个客户端对应一个进程或者线程），二来创建的进程、线程的数量大小也受限于系统资源大小。线程池模型是之前两种模型上的升级版，是一种相对理想的模型，其可以动态的响应客户端的请求，内部使用信号量、锁等同步机制保证访问资源的唯一性，同时内部使用线程代替进程，消耗资源也得到有效控制。当然最理想的还要在下章节中介绍的多路IO转接模型 select、poll、epoll 等模型。</p><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之Socket编程</title>
      <link href="/FuckCode/2019/01/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/"/>
      <url>/FuckCode/2019/01/18/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>本章节主要介绍Linux下如何通过系统提供的API接口实现Socket编程。通过结合之前几篇博文中的内容，包括网络基础，TCP/IP模型以及其之间建议通信的链接细节，从理论到代码完整的贯通，毕竟Socket编程的重要性，对于程序员来说不言而喻了。</strong><br><a id="more"></a></p><h1 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h1><h2 id="开胃菜"><a href="#开胃菜" class="headerlink" title="开胃菜"></a>开胃菜</h2><p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”就唯一标识网络通讯中的一个进程，因此，“IP 地址+端口号”就称为socket。</p><p>在TCP协议中，建立连接的两个进程各自有一个socket来标识，那么这两个socket组成 的socket pair就唯一标识一个连接。socket本身有“插座”的意思，因此用来描述网络连接的一对一关系。</p><p>TCP/IP协议最早在BSD UNIX上实现，为TCP/IP协议设计的应用层编程接口称为socket API。</p><p>再介绍具体的编程之前，我们还需要了解一下几个重要概念。</p><h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><p>我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢?</p><p>发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定:先发出的数据是低地址，后发出的数据是高地址。</p><p>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。例如上一节的UDP段格式，地址0-1是16位的源端口号，如果这个端口号是1000(0x3e8)，则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。</p><p>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。</p><pre><code>#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort);h表示host，n表示network，l表示32位长整数，s表示16位短整数如果主机是小端字节序，这些函数将参数做相应的大小端转换后返回，如果主机是大端字节序，这些函数不作转换，将参数原封不动的返回。</code></pre><h3 id="IP地址相关函数"><a href="#IP地址相关函数" class="headerlink" title="IP地址相关函数"></a>IP地址相关函数</h3><p>IP转换函数再早期只支持IPv4，也不支持可重入，具体如下：</p><pre><code>#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int inet_aton(const *cp, struct in_addr *inp);in_addr_t inet_addr(const char *cp);char *inet_ntoa(struct in_addr in);</code></pre><p>在后续编程中，使用下面新的API接口实现方式：</p><pre><code>#include &lt;arpa/inet.h&gt;int inet_pton(int af, const char *src, void *dst);const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);支持IPv4和IPv6可重入函数</code></pre><p>其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr，因此函数接口是void *addrptr。</p><p>这里就不先贴代码了，总体先有个印象，后续代码中会有详细注释。</p><h3 id="结构体sockaddr"><a href="#结构体sockaddr" class="headerlink" title="结构体sockaddr"></a>结构体sockaddr</h3><p>strcut sockaddr 很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了(void *)的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p><img src="/FuckCode/2019/01/18/Linux系统编程之Socket编程/sockaddr数据结构.png" class="sockaddr数据结构"><pre><code>struct sockaddr {sa_family_t sa_family;char  sa_data[14];};struct sockaddr_in {__kernel_sa_family_t  sin_family;__be16 sin_port;struct in_addr sin_addr;unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) -    sizeof(unsigned short int) - sizeof(struct in_addr)];};/* Internet address. */struct in_addr {__be32  s_addr;};struct sockaddr_in6 {unsigned short int  sin6_family;__be16 sin6_port;__be32 sin6_flowinfo;struct in6_addr sin6_addr;__u32 sin6_scope_id;};struct in6_addr {union {    __u8    u6_addr8[16];    __be16 u6_addr16[8];    __be32 u6_addr32[4];} in6_u;#define s6_addr in6_u.u6_addr8#define s6_addr16 in6_u.u6_addr16#define s6_addr32 in6_u.u6_addr32};#define UNIX_PATH_MAX 108struct sockaddr_un {__kernel_sa_family_t sun_family;char sun_path[UNIX_PATH_MAX];};</code></pre><p>IPv4和IPv6的地址格式定义在 netinet/in.h 中，IPv4地址用 sockaddr_in 结构体表示，包括16位端口号和32位IP地址，IPv6地址用 sockaddr_in6 结构体表示，包括16位端口号、128位IP地址和一些控制字段。</p><p>UNIX Domain Socket的地址格式定义在 sys/un.h 中，用 sock_addr_un 结构体表示。各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度(并不是所有UNIX的实现都有长度字段，如Linux就没有)，后16位表示地址类型。</p><p>IPv4、IPv6和Unix Domain Socket的地址类型分别定义为常数AF_INET、AF_INET6、AF_UNIX。 这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。</p><p>因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成void <em>类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有void </em>类型，因此这些函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，例如:</p><pre><code>bind(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));</code></pre><p>更多关于sockaddr的信息参考以下链接</p><p><a href="https://blog.csdn.net/albertsh/article/details/80991684" target="_blank" rel="noopener">关于sockaddr的相关解释</a></p><h2 id="食材"><a href="#食材" class="headerlink" title="食材"></a>食材</h2><p>在介绍具体的编程模型之前，我们先来了解一下其中涉及到的重要函数，只有了解了这些函数的相关概念，在后续的实战编程中，我们结合模型，才能更好的理解其流程。</p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>创建一个socket网络通讯端口。</p><p>函数原型</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);domain:    AF_INET 这是大多数用来产生socket的协议,使用TCP或UDP来传输,用IPv4的地址    AF_INET6 与上面类似,不过是来用IPv6的地址    AF_UNIX 本地协议,使用在Unix和Linux系统上,一般都是当客户端和服务器在同一台及其上的时候使用type:    SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型,这个socket是使用TCP来进行传输。    SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的,使用UDP来进行它的连接。    SOCK_SEQPACKET 这个协议是双线路的、可靠的连接,发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。    SOCK_RAW 这个socket类型提供单一的网络访问,这个socket类型使用ICMP公共协议。(ping、traceroute使用该协议)    SOCK_RDM 这个类型是很少使用的,在大部分的操作系统上没有实现,它是提供给数据链路层使用,不保证数据包的顺序protocol:    0 默认协议返回值:    成功返回一个新的文件描述符,失败返回-1,设置errno</code></pre><p>socket()打开一个网络通讯端口,如果成功的话,就像 open() 一样返回一个文件描用出错则返回 -1。对于 IPv4,domain 参数指定为 AF_INET。对于TCP协议,type 参数指定为 SOCK_STREAM,表示面向流的传输协议。如果是 UDP 协议,则 type 参数指定为 SOCK_DGRAM,表示面向数据报的传输协议。protocol 参数的介绍从略,指定为 0 即可。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>执行socket端口与设备端口号和ip地址绑定。</p><p>函数原型</p><pre><code>  #include &lt;sys/types.h&gt;  #include &lt;sys/socket.h&gt;  int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);  sockfd:      socket文件描述符  addr:      构造出IP地址加端口号  addrlen:      sizeof(addr)长度  返回值:成功返回0,失败返回-1, 设置errno</code></pre><p>服务器程序所监听的网络地址和端口号通常是固定不变的,客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接,因此服务器需要调用 bind 绑定一个固定的网络地址和端口号。</p><p>bind()的作用是将参数 sockfd 和 结构体 sockaddr addr绑定在一起,使 sockfd 这个用于网络通讯的文件描述符监听 addr 所描述的地址和端口号。struct sockaddr *是一个通用指针类型,addr 参数实际上可以接受多种协议的 sockaddr 结构体,而它们的长度各不相同,所以需要第三个参数 addrlen 指定结构体的长度。函数接口会根据其长度自动分析出其地址是 IPV4 还是 IPV6，例如:</p><pre><code>struct sockaddr_in servaddr;// 清零bzero(&amp;servaddr, sizeof(servaddr));// 指定 IP地址为 IPV4servaddr.sin_family = AF_INET;// 任意本地 IP地址servaddr.sin_addr.s_addr = htonl(INADDR_ANY);servaddr.sin_port = htons(8000);</code></pre><p>首先将整个结构体清零,然后设置地址类型为 AF_INET,网络地址为 INADDR_ANY,这个宏表示本地的任意IP地址,因为服务器可能有多个网卡,每个网卡也可能绑定多个IP地址,这样设置可以在所有的IP地址上监听,直到与某个客户端建立了连接时才确定下来到底用哪个IP地址,端口号为8000。</p><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><p>接受客户端连接，就绪等待处理。</p><p>函数原型</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);sockfd:    socket文件描述符backlog:    排队建立3次握手队列和刚刚建立3次握手队列的链接数和</code></pre><p>查看系统默认backlog</p><pre><code>cat /proc/sys/net/ipv4/tcp_max_syn_backlog</code></pre><p>典型的服务器程序可以同时服务于多个客户端,当有客户端发起连接时,服务器调用的 accept() 返回并接受这个连接,如果有大量的客户端发起连接而服务器来不及处理,尚未 accept 的客户端就处于连接等待状态, listen() 声明 sockfd 处于监听状态,并且最多允许有 backlog 个客户端处于连接待状态,如果接收到更多的连接请求就忽略。listen() 成功返回0,失败返回 -1。</p><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p>接受客户端的连接请求，得到一个用于读写数据的通道标识符。</p><p>函数原型</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);sockdf:    socket文件描述符addr:    传出参数,返回链接客户端地址信息,含IP地址和端口号addrlen:    传入传出参数(值-结果),传入sizeof(addr)大小,函数返回时返回真正接收到地址结构体的大小返回值:    成功返回一个新的socket文件描述符,用于和客户端通信,失败返回-1,设置errno</code></pre><p>三方握手完成后,服务器调用 accept() 接受连接,如果服务器调用 accept() 时还没有客户端的连接请求,就阻塞等待直到有客户端连接上来。addr 是一个传出参数,accept() 返回时传出客户端的地址和端口号。addrlen 参数是一个传入传出参数(value-resultargument),传入的是调用者提供的缓冲区 addr 的长度以避免缓冲区溢出问题,传出的是客户端地址结构体的实际长度(有可能没有占满调用者提供的缓冲区)。如果给 addr 参数传 NULL,表示不关心客户端的地址。</p><p>我们的服务器程序结构是这样的:</p><pre><code>while (1) {    cliaddr_len = sizeof(cliaddr);    connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);    n = read(connfd, buf, MAXLINE);    ......    close(connfd);}</code></pre><p>整个是一个 while 死循环,每次循环处理一个客户端连接。由于 cliaddr_len 是传入传出参数,每次调用 accept() 之前应该重新赋初值。 accept() 的参数 listenfd 是先前的监听文件描述符，而 accept() 的返回值是另外一个文件描述符 connfd,之后与客户端之间就通过这个 connfd 通讯,最后关闭 connfd 断开连接,而不关闭 listenfd,再次回到循环开头 listenfd 仍然用作 accept 的参数。accept() 成功返回一个文件描述符,出错返回 -1。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>通过 accept 返回的新文件描述符，建立数据交互的连接通道。</p><p>函数原型</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockdf:    socket文件描述符addr:    传入参数,指定服务器端地址信息,含IP地址和端口号addrlen:    传入参数,传入sizeof(addr)大小返回值:    成功返回 0,失败返回 -1,设置 errno</code></pre><p>客户端需要调用 connect() 连接服务器,connect 和 bind 的参数形式一致,区别在于 bind 的参数是自己的地址,而 connect 的参数是对方的地址。服务器可以通过 connect 中的具体参数获取到当前已连接的客户端的 ip 地址和端口号。connect() 成功返回 0,出错返回 -1。</p><h2 id="美食1-TCP"><a href="#美食1-TCP" class="headerlink" title="美食1-TCP"></a>美食1-TCP</h2><p>上面具体介绍了Socket编程中用的几个重要函数，下面就来实战Socket编程中TCP的代码实现。</p><p>TCP协议的通信流程在之前TCP、UDP章节中具体分析过了，包括其三次握手建立连接，四次握手断开链接，连接中状态装换以及滑动窗口等概念和原理。下图具体展示了TCP协议的通信模型，包括客户端和服务器连接过程中具体函数接口的调用时机，两端设备端口的状态，数据导向等，再此基础上加深理解具体代码的实现过程。</p><img src="/FuckCode/2019/01/18/Linux系统编程之Socket编程/TCP协议通讯流程.png" class="TCP协议通讯流程"><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>服务器的工作任务很简单，根据连接上的客户端传来的数据，进行转大写回传。</p><pre><code>#include &quot;wrap.h&quot;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;// 服务端端口定义 8000#define SERVER_PORT 8000// 缓冲区 4096#define BUF_SIZE 4096int main(int argc, char *argv[]){    int sockfd, confd, readlen;    struct sockaddr_in serveraddr,clientaddr;    socklen_t clientaddr_len;    char clientIP[128];    char buf[BUF_SIZE];    // 新建Socket通道，指定TCP协议    sockfd = Socket(AF_INET, SOCK_STREAM, 0);    // 填充结构体 sockaddr_in    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);    serveraddr.sin_port = htons(SERVER_PORT);    // 绑定指定socket    Bind(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));    // 开始监听    Listen(sockfd,30);    printf(&quot; Accepting connections ...\n&quot;);    // 死循环等待客户链接    while(1){        clientaddr_len = sizeof(clientaddr);        // 连接上客户端        confd = Accept(sockfd, (struct sockaddr*)&amp;clientaddr, &amp;clientaddr_len);        // 打印已链接的客户端数据        printf(&quot;client IP: %s, Port: %d \n&quot;,            inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr,clientIP, sizeof(clientIP)),            ntohs(clientaddr.sin_port)            );        // 获取客户端传来数据        readlen = Read(confd,buf,sizeof(buf));        int i = 0;        while(i&lt;readlen){            // 小写转大写            buf[i] = toupper(buf[i]);            i++;        }        // 回传客户端        Write(confd,buf,readlen);        Close(confd);    }}</code></pre><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>client.c的作用是从命令行参数中获得一个字符串发给服务器,然后接收服务器返回的字符串并打印。</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &quot;wrap.h&quot;// 与服务端的一致#define SERVER_PORT 8000#define BUF_SIZE 4096int main(int argc, char * argv[]){    int serverfd, readlen;    struct sockaddr_in serveraddr;    // ServerIP，可以自己指定自己的IP，也可以默认本地IP    char serverIP[] = &quot;127.0.0.1&quot;;    char buf[BUF_SIZE];    if(argc &lt; 2){        printf(&quot;./client agc...\n&quot;);        exit(1);    }    serverfd = Socket(AF_INET, SOCK_STREAM, 0);    // 清空结构体serveraddr    bzero(&amp;serveraddr,sizeof(serveraddr));    serveraddr.sin_family = AF_INET;    // IP地址转换    inet_pton(AF_INET, serverIP, &amp;serveraddr.sin_addr.s_addr);    serveraddr.sin_port = htons(SERVER_PORT);  　// 连接服务器    Connect(serverfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));    Write(serverfd, argv[1],sizeof(argv[1]));    readlen = Read(serverfd,buf,sizeof(buf));    Write(STDOUT_FILENO, buf,readlen);    Close(serverfd);}</code></pre><p>由于客户端不需要固定的端口号,因此不必调用 bind(),客户端的端口号由内核自动分配。注意,客户端不是不允许调用 bind(),只是没有必要调用 bind() 固定一个端口号,服务器也不是必须调用 bind(),但如果服务器不调用 bind(),内核会自动给服务器分配监听端口,每次启动服务器时端口号都不一样,客户端要连接服务器就会遇到麻烦。</p><p>客户端和服务器启动后可以查看链接情况:</p><pre><code>netstat -apn|grep 8000</code></pre><p>调试相关说明：</p><ol><li>启动shell窗口，运行服务  ./server</li><li>新建shell窗口，再运行Client客户端，记得添加需要转换的额外数据，例如： ./client abcdefg</li><li>连接成功后，服务器窗口返回已连接客户端的ip地址和端口号，客户端则会打印命令中额外参数对应的大写数据，对应上面的则是：ABCDEFG</li></ol><h2 id="美食2-UDP"><a href="#美食2-UDP" class="headerlink" title="美食2-UDP"></a>美食2-UDP</h2><p>这里我们来看一下 UDP 的实战编程。由于 UDP 不需要维护连接,程序逻辑简单了很多,但是 UDP 协议是不可靠的,实际上有很多保证通讯可靠性的机制需要在应用层实现。</p><p>UDP 通信模型如下图：</p><img src="/FuckCode/2019/01/18/Linux系统编程之Socket编程/UDP协议通讯流程.png" class="TDP协议通讯流程"><p>UDP 的通信模型和 TCP 在建立链接之前的配置基本相似，但是对于后面建立连接后的数据通信过程就简单多了。sendto 负责发送数据，recvfrom 负责接受数据，其每次数据传输过程中（不论是发送还是接受数据），都需要传入地址参数，而这一切在 TCP 模型中，都被 connect 取代了。</p><h3 id="Server-1"><a href="#Server-1" class="headerlink" title="Server"></a>Server</h3><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define SERVER_PORT 8001#define BUF_SIZE 1024int main(int argc, char const *argv[]){    int sockfd, readlen;    char buf[BUF_SIZE];    char clientIP[INET_ADDRSTRLEN];    socklen_t clientlen;    struct sockaddr_in serveraddr, clientaddr;// 创建网络通信端口，指定SOCK_DGRAM为ＵＤＰ    sockfd = socket(AF_INET, SOCK_DGRAM, 0);// 设置服务器端口信息    bzero(&amp;serveraddr, sizeof(serveraddr));    serveraddr.sin_family =  AF_INET;    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);    serveraddr.sin_port = htons(SERVER_PORT);// 执行绑定    bind(sockfd,(struct sockaddr *)&amp;serveraddr,sizeof(serveraddr));    printf(&quot;Accepting connections ...\n&quot;);    while(1){        bzero(&amp;clientaddr,sizeof(clientaddr));        clientlen = sizeof(clientlen);    // 从已连接的客户端读数据，传出参数clientaddr包含客户端信息        readlen = recvfrom(sockfd, buf, BUF_SIZE, 0,            (struct sockaddr *)&amp;clientaddr,&amp;clientlen);        printf(&quot;client IP: %s, Port: %d \n&quot;,            inet_ntop(AF_INET, &amp;clientaddr.sin_addr,clientIP, sizeof(clientIP)),            ntohs(clientaddr.sin_port)            );        int i = 0;        while(i&lt;readlen){            buf[i] = toupper(buf[i]);            i++;        }    // 回传数据到客户端，传出参数客户端clientaddr结构体信息        sendto(sockfd,buf,readlen,0,            (struct sockaddr *)&amp;clientaddr,sizeof(clientaddr));    }    close(sockfd);    return 0;}</code></pre><h3 id="Client-1"><a href="#Client-1" class="headerlink" title="Client"></a>Client</h3><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define SERVER_PORT 8001#define BUF_SIZE 1024int main(int argc, char * argv[]){    int serverfd, readlen;    struct sockaddr_in serveraddr;    char serverIP[] = &quot;127.0.0.1&quot;;    char buf[BUF_SIZE];    socklen_t serverlen;    if(argc &lt; 2){        printf(&quot;./client agc...\n&quot;);        exit(1);    }    serverfd = socket(AF_INET, SOCK_DGRAM, 0);    bzero(&amp;serveraddr,sizeof(serveraddr));    serveraddr.sin_family = AF_INET;    inet_pton(AF_INET, serverIP, &amp;serveraddr.sin_addr);    serveraddr.sin_port = htons(SERVER_PORT);    sendto(serverfd,argv[1],sizeof(argv[1]),0,        (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));    bzero(&amp;serverlen,sizeof(serverlen));    readlen = recvfrom(serverfd,buf,BUF_SIZE,0,        NULL, 0);    write(STDOUT_FILENO, buf,readlen);    close(serverfd);    return 0;}</code></pre><p>UDP 模型下的实例代码，运行流程和 TCP 相似，首先启动 Server，然后开启 Client，发送数据到服务器进行大写转换，客户端读取收到的数据打印出来。</p><p>相信有读者已经发现了其两者之间通信模型的差距，其实理解起来也很容易，TCP 相当于打电话，开始接通之前喂喂喂确认是对方后，知道挂断前都不用再确认对方身份，也就是在数据交互过程中不需要夹杂地址信息了；然而 UDP 则必须每次数据交互中都需要填入对方地址信息，就犹如寄信，每次张信都需要地址和邮票一样。</p><p>总的话来说，还是其通信的本质有区别，TCP 是基于数据流方式，UDP 是基于消息方式。</p><h2 id="饭后甜点"><a href="#饭后甜点" class="headerlink" title="饭后甜点"></a>饭后甜点</h2><p>上面的两个实例不仅功能简单，而且简单到几乎没有什么错误处理。然而在系统调用不能保证每次都成功，必须进行出错处理，这样一方面可以保证程序逻辑正常，另一方面可以迅速得到故障信息。</p><p>为使错误处理的代码不影响主程序的可读性，我们把与 socket 相关的一些系统函数加上错误处理代码包装成新的函数，做成一个模块 wrap.c，提供一个头文件 wrap.h 依赖，具体的wrap.c 如下：</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><pre><code>#ifndef WRAP_H#define WRAP_H#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;errno.h&gt;void perr_exit(const char *s);int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr);void Bind(int fd, const struct sockaddr *sa, socklen_t salen);void Connect(int fd, const struct sockaddr *sa, socklen_t salen);void Listen(int fd, int backlog);int Socket(int family, int type, int protocol);ssize_t Read(int fd, void *ptr, size_t nbytes);ssize_t Write(int fd, const void *ptr, size_t nbytes);void Close(int fd);ssize_t Readn(int fd, void *vptr, size_t n);ssize_t Writen(int fd, const void *vptr, size_t n);static ssize_t my_read(int fd, char *ptr);ssize_t Readline(int fd, void *vptr, size_t maxlen);#endif // WRAP_H</code></pre><p>###　实现文件</p><pre><code>#include &quot;wrap.h&quot;void perr_exit(const char *s){    perror(s);    exit(1);}int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr){    int n;again:    if((n = accept(fd,sa,salenptr)) &lt; 0){        if((errno == ECONNABORTED) || (errno == EINTR)){            goto again;        }else {            perr_exit(&quot;accept&quot;);        }        return n;    }}void Bind(int fd, const struct sockaddr *sa, socklen_t salen){    if(bind(fd,sa,salen)&lt;0)        perr_exit(&quot;bind&quot;);}void Connect(int fd, const struct sockaddr *sa, socklen_t salen){    if (connect(fd, sa, salen) &lt; 0)        perr_exit(&quot;connect error&quot;);}void Listen(int fd, int backlog){    if (listen(fd, backlog) &lt; 0)        perr_exit(&quot;listen error&quot;);}int Socket(int family, int type, int protocol){    int n;    if((n = socket(family,type,protocol))&lt;0)        perr_exit(&quot;socket&quot;);    return n;}ssize_t Read(int fd, void *ptr, size_t nbytes){    ssize_t n;again:    if((n = read(fd,ptr,nbytes))==-1){        if(errno == EINTR)            goto again;        else            return -1;    }    return n;}ssize_t Write(int fd, const void *ptr, size_t nbytes){    ssize_t n;again:    if ( (n = write(fd, ptr, nbytes)) == -1) {        if (errno == EINTR)            goto again;        else            return -1;    }    return n;}void Close(int fd){    if (close(fd) == -1)        perr_exit(&quot;close error&quot;);}ssize_t Readn(int fd, void *vptr, size_t n){    size_t nleft;    ssize_t nread;    char            *ptr;    ptr = vptr;    nleft = n;    while (nleft &gt; 0) {        if ( (nread = read(fd, ptr, nleft)) &lt; 0) {            if (errno == EINTR)                nread = 0;            else                return -1;        } else if (nread == 0)            break;        nleft -= nread;        ptr += nread;    }    return n - nleft;}ssize_t Writen(int fd, const void *vptr, size_t n){    size_t nleft;    ssize_t nwritten;    const char *ptr;    ptr = vptr;    nleft = n;    while (nleft &gt; 0) {        if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) {            if (nwritten &lt; 0 &amp;&amp; errno == EINTR)                nwritten = 0;            else                return -1;        }        nleft -= nwritten;        ptr += nwritten;    }    return n;}ssize_t my_read(int fd, char *ptr){    static int read_cnt;    static char *read_ptr;    static char read_buf[100];    if (read_cnt &lt;= 0) {again:        if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) {            if (errno == EINTR)                goto again;            return -1;        } else if (read_cnt == 0)            return 0;        read_ptr = read_buf;    }    read_cnt--;    *ptr = *read_ptr++;    return 1;}ssize_t Readline(int fd, void *vptr, size_t maxlen){    ssize_t n, rc;    char            c, *ptr;    ptr = vptr;    for (n = 1; n &lt; maxlen; n++) {        if ( (rc = my_read(fd, &amp;c)) == 1) {            *ptr++ = c;            if (c                    == &apos;\n&apos;)                break;        } else if (rc == 0) {            *ptr = 0;            return n - 1;        } else            return -1;    }    *ptr = 0;    return n;}</code></pre><p>对于上述模块，可以采用以下几种调用方式</p><ol><li>源代码直接包含，简单直接，在 Makefile 中直接声明 -I 方式将头文件包含进去，记得 wrap.c 文件需要和源文件 server.c client.c 同级目录。</li><li>直接包含头文件，源文件以动态库形式存在，隐藏源码，需要事先将模块编译成 so 动态链接库，具体方法，请参考之前静态、动态链接库实战章节。</li></ol><h2 id="真香"><a href="#真香" class="headerlink" title="真香"></a>真香</h2><p>本章节介绍了Socket编程下，TCP,UDP模型的实例代码。由于其通信模型的不同，其代码实现上也有不同，但是大同小异。相同的是建立连接服务过程中，服务端必须指定ip地址和端口号，绑定后，客户端连接时也要和服务器的一致；不同的是在数据交互过程中，TCP基于流，一旦建立链接(connect)后就可以直接数据传输，无需地址信息的参与，而UDP则需要在数据交互中，有一个传入传出参数负责地址的接受和发送，每次发送数据都需要将接收数据的地址信息包含进去，谁发来，回传给谁。</p><p>总而言之，对于上述代码实现以及章节中的模型图，相信对这两种通信协议能有很好的理解。</p><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之TCP/UDP协议</title>
      <link href="/FuckCode/2019/01/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP%E5%8D%8F%E8%AE%AE/"/>
      <url>/FuckCode/2019/01/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8BTCP-UDP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>本章节集中分析网络编程必备知识TCP，UDP数据报格式，熟悉其原理，优缺点以及通信细节，尤其是对于TCP下的三次握手，状态转换，滑动窗口等复杂机制的理解，为后续Socket编程打下牢牢的基础。</strong><br><a id="more"></a></p><h1 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h1><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>从之前网络基础中，我们了解到，UDP协议不面向连接，也不保证可靠性，有点像寄信，写好信放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件是按顺序寄到目的地的。 使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</p><p>其协议相对简单，并且更加灵活，对服务器和网络资源的负载也相对小一些。底层协议提供的数据不保障可靠性，那么就需要在上层应用中自己试试对应的政策来保证数据传输的有效性了。</p><h3 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h3><p>UDP数据段如下图所示：</p><img src="/FuckCode/2019/01/17/Linux系统编程之TCP-UDP协议/UDP数据段.png" class="UDP数据段"><p>图示很简单，UDP格式中8字节64bit的数据是必须的，只包含了源端口号，目的端口号，UDP长度以及校验位，结合之前网络基础的各层协议数据报格式，这里具体分析一下。</p><h3 id="UDP通信分析"><a href="#UDP通信分析" class="headerlink" title="UDP通信分析"></a>UDP通信分析</h3><p>下面分析一帧基于UDP的TFTP协议帧</p><pre><code>以太网首部0000: 00055d67d0b100055d6158a80800IP首部0000: 45 000010: 005393250000801125ecc0a80037c0a80020: 00 01UDP首部0020: 05 d4 00 45 00 3f ac 40TFTP协议0020: 00 01 ‘c”:‘”’q’0030: ‘w’‘e’‘r’‘q”.‘’q’‘w’‘e’00 ’n’‘e”t’‘a”s’‘c’‘i’ 0040: ‘i’00 ’b’‘l’‘k”s’‘i’‘z’‘e’00 ’5’‘1’‘2’00 ’t’‘i’ 0050: ’m’‘e’‘o’‘u”t’00 ‘1’‘0’00 ’t”s’‘i’‘z’‘e’00 ’0’ 0060: 00</code></pre><ol><li>以太网首部: 源MAC地址是 00:05:5d:61:58:a8，目的MAC地址是 00:05:5d:67:d0:b1，上层协议类型 0x0800表示IP。</li><li>IP首部: 每一个字节0x45包含4位版本号和4位首部长度，版本号为4，即IPv4，首部长度为5，说明IP首部不带有选项字段。服务类型为0，没有使用服务。16位总长度字段(包括IP首部和IP层payload的长度)为0x0053，即83字节，加上以太网首部14字节可知整个帧长度是97字节。IP报标识是0x9325，标志字段和片偏移字段设置为0x0000，就是DF=0允许分片，MF=0此数据报没有更多分片，没有分片偏移。TTL是0x80，也就是128。上层协议0x11表示UDP协议。IP首部校验和为0x25ec，源主机IP是 c0 a8 00 37(192.168.0.55)，目的主机IP是 c0 a8 00 01(192.168.0.1)。</li><li>UDP首部: 源端口号 0x05d4(1492)是客户端的端口号，目的端口号 0x0045(69)是TFTP服务的well-known端口号。UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。UDP首部和UDP层payload的校验和为0xac40。</li><li><p>TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是:</p><pre><code>c:\qwerq.qwenetasciiblksize 512timeout 10tsize 0</code></pre></li></ol><p>一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器，客户端主动发起请求(上面的例子就是客户端发起的请求帧)，而服务器被动地等待、接收和应答请求。客户端的IP地址和端口号唯一标识了该主机上的TFTP客户端进程，服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程，由于客户端是主动发起请求的一方，它必须知道服务器的IP地址和TFTP服务进程的端口号，所以，一些常见的网络协议有默认的服务器端口，例如HTTP服务默认TCP协议的80端口，FTP服务默认TCP协议的21端口，TFTP服务默认UDP协议的69端口(如上例所示)。在使用客户端程序时，必须指定服务器的主机名或IP地址， 如果不明确指定端口号则采用默认端口，请读者查阅ftp、tftp等程序的man page了解如何指定端口号。/etc/services中列出了所有well-known的服务端口和对应的传输层协议，这是由IANA(Internet Assigned Numbers Authority)规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。</p><p>很多服务有well-known的端口号，然而客户端程序的端口号却不必是well-known的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为 ephemeral的端口号.</p><p>发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了， 如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。</p><p>通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。</p><p>因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。例如，基于UDP的TFTP协议一般只用于传送小文件(所以才叫trivial的ftp)，而基于TCP的FTP协议适用于各种文件的传输。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP是一种面向连接的、可靠的协议。TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。</p><h3 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a>TCP数据报格式</h3><p>作为一种可靠的协议，其格式相比UDP来说自然更加复杂些，具体如下图所示：</p><img src="/FuckCode/2019/01/17/Linux系统编程之TCP-UDP协议/TCP数据段.png" class="TCP数据段"><p>和UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。32位序号、32位确认序号、窗口大小稍后详细解释。4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。URG、ACK、PSH、RST、SYN、FIN是六个控制位，本节稍后将解释SYN、ACK、FIN、RST四个位，其它位的解释从略。16位检验和将TCP协议头和数据都计算在内。紧急指针和各种选项的解释从略。</p><h3 id="TCP通信时序"><a href="#TCP通信时序" class="headerlink" title="TCP通信时序"></a>TCP通信时序</h3><p>下图是一次TCP通讯的时序图：</p><img src="/FuckCode/2019/01/17/Linux系统编程之TCP-UDP协议/TCP时序图.png" class="TCP时序图"><p>首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序，注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。双方发送的段按时间顺序编号为1-10，各段中的主要信息在箭头上标出，例如段2的箭头上标着 SYN, 8000(0), ACK 1001,表示该段中的 SYN 位置1，32位序号是 8000，该段不携带有效载荷(数据字节数为0)，ACK 位置1，32位确认序号是 1001，带有一个 mss 选项值为1024。</p><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>TCP建立连接的过程，或者称为三次握手，如下：</p><ol><li>客户端发出段1，SYN 位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定 SYN 位和 FIN 位也要占一个序号，这次虽然没发数据，但是由于发了 SYN 位，因此下次再发送应该用序号 1001。mss 表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。</li><li>服务器发出段2，也带有 SYN 位，同时置 ACK 位表示确认，确认序号是 1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。</li><li>客户端发出段3，对服务器的连接请求进行应答，其中带有标志 ACK，，确认序号在接受数据上加一，是8001。</li></ol><p>在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三方握手(three-way-handshake)”。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。</p><p>在TCP通讯中，如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含 RST 位的段给另一方。</p><h4 id="数据传输的过程"><a href="#数据传输的过程" class="headerlink" title="数据传输的过程"></a>数据传输的过程</h4><p>由图中中间段数据传输图示，可以得知：</p><ol><li>客户端发出段4，包含从序号1001开始的20个字节数据， ACK 确认序号 8001（确认三次握手建立连接的到的 ACK 8001）。</li><li>服务器发出段5，确认序号 ACK 为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。</li><li>客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。</li></ol><h4 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h4><p>TCP关闭连接的过程，或称为四次握手:</p><ol><li>客户端发出段7，FIN 位表示客户端主动关闭彼此连接的请求。</li><li>服务器发出段8，应答客户端的关闭连接请求， ACK 在之前 1021 基础上加一。</li><li>服务器发出段9，其中也包含 FIN 位，服务端开始关闭，向客户端发送关闭连接的请求。</li><li>客户端发出段10，应答服务器的关闭连接请求，表示以确认服务端关闭。</li></ol><p>以上，基本描述了TCP一次完整通信过程中的详细细节。</p><h3 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h3><p>相信对于上面的时序图来说，大多数都不陌生。上述过程在非常理想状态下是完全ok的，也就说是排除了定位网络或系统故障。对于具体的每个状态及其装换过程，尤其涉及到网络波动时，就需要对每个状态之间的切换作了解，同时在了解了状态图后，那么对于时序图的理解会更加充分。下面对这张图的11种状态详细解析一下，以便加强记忆!不过在这之前，先回顾一下TCP建立连接的三次握手过程，以及关闭连接的四次握手过程。</p><h4 id="TCP的连接与断开"><a href="#TCP的连接与断开" class="headerlink" title="TCP的连接与断开"></a>TCP的连接与断开</h4><h5 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h5><ol><li>客户端发送一个带 SYN 标志的TCP报文到服务器。这是三次握手过程中的报文1。</li><li>服务器端回应客户端的，这是三次握手中的第2个报文，这个报文同时带 ACK 标志和 SYN 标志。因此它表示对刚才客户端 SYN 报文的回应;同时又标志 SYN 给客户端，询问客户端是否准备好进行数据通讯。</li><li>客户必须再次回应服务段一个 ACK 报文，这是报文段3。</li></ol><h5 id="四次握手终止连接"><a href="#四次握手终止连接" class="headerlink" title="四次握手终止连接"></a>四次握手终止连接</h5><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个TCP连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li>TCP客户端发送一个 FIN ，用来关闭客户到服务器的数据传送(报文段4)。</li><li>服务器收到这个 FIN ，它发回一个 ACK ，确认序号为收到的序号加1(报文段5)。和 SYN 一样，一个 FIN 将占用一个序号。</li><li>服务器关闭客户端的连接，发送一个 FIN 给客户端(报文段6)。</li><li>客户段发回 ACK 报文确认，并将确认序号设置为收到序号加1(报文段7)。</li></ol><h4 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h4><p>TCP通信过程中，各个阶段涉及的具体的状态如下图所示：</p><img src="/FuckCode/2019/01/17/Linux系统编程之TCP-UDP协议/TCP状态转换图.png" class="TCP状态转换图"><p>其图示中涉及的具体状态点如下解释：</p><ol><li>CLOSED: 这个没什么好说的了,表示初始状态。</li><li>LISTEN: 这个也是非常容易理解的一个状态,表示服务器端的某个SOCKET处于监听状态,可以接受连接了。</li><li>SYN_RCVD: 这个状态表示接受到了SYN报文,在正常情况下,这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态,很短暂,基本上用netstat你是很难看到这种状态的,除非你特意写了一个客户端测试程序,故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时,当收到客户端的ACK报文<br>后,它会进入到ESTABLISHED状态。</li><li>SYN_SENT: 这个状态与SYN_RCVD遥想呼应,当客户端SOCKET执行CONNECT连接时,它首先发送 SYN 报文,因此也随即它会进入到了SYN_SENT状态,并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送 SYN 报文。</li><li>ESTABLISHED:这个容易理解了,表示连接已经建立了。</li><li>FIN_WAIT_1: 这个状态要好好解释一下,其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是:FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时,它想主动关闭连接,向对方发送了 FIN 报文,此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应 ACK 报文后,则进入到FIN_WAIT_2状态,当然在实际的正常情况下,无论对方何种情况下,都应该马上回应ACK报文,所以FIN_WAIT_1状态一般是比较难见到的,而FIN_WAIT_2状态还有时常常可以用netstat看到。</li><li>FIN_WAIT_2:上面已经详细解释了这种状态,实际上FIN_WAIT_2状态下的SOCKET,表示半连接,也即有一方要求close连接,但另外还告诉对方,我暂时还有点数据需要传送给你,稍后再关闭连接。</li><li>TIME_WAIT: 表示收到了对方的FIN报文,并发送出了ACK报文,就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下,收到了对方同时带 FIN 标志和 ACK 标志的报文时,可以直接进入到TIME_WAIT状态,而无须经过FIN_WAIT_2状态。</li><li>CLOSING: 这种状态比较特殊,实际情况中应该是很少见,属于一种比较罕见的例外状态。正常情况下,当你发送 FIN 报文后,按理来说是应该先收到(或同时收到)对方的  ACK 报文,再收到对方的 FIN 报文。但是CLOSING状态表示你发送FIN报文后,并没有收到对方的ACK报文,反而却也收到了对方的 FIN 报文。什么情况下会出现此种情况<br>呢?其实细想一下,也不难得出结论:那就是如果双方几乎在同时close一个SOCKET的话,那么就出现了双方同时发送 FIN 报文的情况,也即会出现CLOSING状态,表示双方都正在关闭SOCKET连接。</li><li>CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢?当对方close一个SOCKET后发送 FIN 报文给自己,你系统毫无疑问地会回应一个ACK报文给对方,此时则进入到CLOSE_WAIT状态。接下来呢,实际上你真正需要考虑的事情是察看你是否还有数据发送给对方,如果没有的话,那么你也就可以close这个SOCKET,发送 FIN 报文给对方,也即关闭连接。所以你在CLOSE_WAIT状态下,需要完成的事情是等待你去关闭连接。</li><li>LAST_ACK: 这个状态还是比较容易好理解的,它是被动关闭一方在发送 FIN 报文后,最后等待对方的 ACK 报文。当收到 ACK 报文后,也即可以进入到CLOSED可用状态了。</li></ol><p>以上分析需要结合上面两张图一起观察，此种涉及到了通信过程中的种种细节，尤其是客户端和服务端发送相应数据后的状态变化，其中还有一些对未知情况的响应处理策略，需要认真回味。</p><h3 id="TCP流量控制（滑动窗口）"><a href="#TCP流量控制（滑动窗口）" class="headerlink" title="TCP流量控制（滑动窗口）"></a>TCP流量控制（滑动窗口）</h3><p>在介绍UDP时，我们描述了这样的问题:如果发送端发送的速度较快，接收端接收到数据后 处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。TCP协议可以通过’滑动窗口 (Sliding Window)’机制解决这一问题。看下图的通讯过程。</p><img src="/FuckCode/2019/01/17/Linux系统编程之TCP-UDP协议/TCP滑动窗口.png" class="TCP滑动窗口"><p>提下对图示进行解释：</p><ol><li>发送端发起连接，声明最大段尺寸mss是1460，初始序号是0，窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三方握手结束。</li><li>发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。</li><li>接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K（取走数据2k，就剩下了2k的空余窗口大小）。</li><li>接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。</li><li>发送端发出段12-13，每个段带1K数据，段13同时还包含FIN位。</li><li>接收端应答接收到的2K数据(6145-8192)，再加上 FIN 位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K（原剩余空间4k-2k接受新的数据，剩余大小2k）。</li><li>接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。</li><li>接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为 6K。</li><li>接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含 FIN 位，发送端应答，连接完全关闭。</li></ol><p>上图在接收端用小方块表示1K数据，实心的小方块表示已接收到的数据，虚线框表示接 收缓冲区，因此套在虚线框中的空心小方块表示窗口大小，从图中可以看出，随着应用程序提走数据，虚线框是向右滑动的，因此称为滑动窗口。</p><p>从这个例子还可以看出，发送端是1K、1K地发送数据，而接收端的应用程序可以2K、2K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流(stream)，在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。</p><h3 id="TCP半链接状态"><a href="#TCP半链接状态" class="headerlink" title="TCP半链接状态"></a>TCP半链接状态</h3><p>当TCP链接中A发送 FIN 请求关闭，另一段B回应 ACK 后，B没有立即发送 FIN 给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。</p><p>如下函数原型</p><pre><code>#include &lt;sys/socket.h&gt;int shutdown(int sockfd, int how)sockfd: 需要关闭的socket的描述符how: 允许为shutdown操作选择以下几种方式:        SHUT_RD:关闭连接的读端。也就是该套接字不再接受数据,任何当前在套接字接受缓冲区的数据将被丢弃。进程将不能对该套接字发出任何读操作。对TCP套接字该调用之后接受到的任何数据将被确认然后无声的丢弃掉。        SHUT_WR:关闭连接的写端,进程不能在对此套接字发出写操作        SHUT_RDWR:相当于调用shutdown两次:首先是以SHUT_RD,然后以SHUT_WR</code></pre><p>使用close中止一个连接，但它只是减少描述符的参考数，并不直接关闭连接，只有当描述符的参考数为0时才关闭连接。shutdown可直接关闭描述符，不考虑描述符的参考数，可选择中止一个方向的连接。</p><p>注意: </p><ol><li>如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。</li><li>在多进程中如果一个进程中shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。如果一个进程close(sfd)将不会影响到其它进程。</li></ol><h3 id="2MSL-TIME-WAIT"><a href="#2MSL-TIME-WAIT" class="headerlink" title="2MSL/TIME_WAIT"></a>2MSL/TIME_WAIT</h3><p>TIME_WAIT状态的存在有两个理由:</p><ol><li>让4次握手关闭流程更加可靠;4次握手的最后一个 ACK 是由主动关闭方发送出去的，若这个 ACK 丢失，被动关闭方会再次发一个 FIN 过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的 ACK 被再次发送出去。</li><li>防止lost duplicate对后续新建正常链接的传输造成破坏。lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失;要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。lost duplicate加上incarnation connection，则会对我们的传输造成致命的错误。大家都知道TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接;假设一个incarnation connection这时收到的seq=1000, 来了一个lost duplicate为seq=1000, len=1000, 则tcp认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。</li></ol><p>该状态为什么设计在主动关闭这一方:</p><ol><li>发最后 ACK 的是主动关闭一方</li><li>只要有一方保持TIME_WAIT状态，就能起到避免incarnation connection在2MSL内的重新建立，不需要两方都有</li></ol><p>如何正确对待2MSL TIME_WAIT?</p><p>RFC要求socket pair在处于TIME_WAIT时,不能再起一个incarnation connection。但绝大部分TCP实现,强加了更为严格的限制。在2MSL等待期间,socket中使用的本地端口在默认情况下不能再被使用。若A 10.234.5.5:1234和B 10.55.55.60:6666建立了连接,A主动关闭,那么在A端只要port为1234,无论对方的port和ip是什么,都不允许再起服务。显而易见这是比RFC更为严格的限制,RFC仅仅是要求socket pair不一致,而实现当中只要这个port处于TIME_WAIT,就不允许起连接。这个限制对主动打开方来说是无所谓的,因为一般用的是临时端口;但对于被动打开方,一般是server,就悲剧了,因为server一般是熟知端口。比如http,一般端口是80,不可能允许这个服务在2MSL内不能起来。解决方案是给服务器的socket设置SO_REUSEADDR选项,这样的话就算熟知端口处于TIME_WAIT状态,在这个端口上依旧可以将服务启动。当然,虽然有了SO_REUSEADDR选项,但sockt pair这个限制依旧存在。比如上面的例子,A通过SO_REUSEADDR选项依旧在1234端口上起了监听,但这时我们若是从B通过6666端口去连它,TCP协议会告诉我们连接失败,原因为Address already in use.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本博文涉及众多细节知识点，基本梳理了邢文鹏老师的Linux教学资料中的内容，也相当于自己对这些方面的知识点的回顾。有了之前网络的基础知识，以及这些TCP、UDP通讯细节，对下面的Socket变成来说就能够更加游刃有余。</p><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 TCP UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之网络基础</title>
      <link href="/FuckCode/2019/01/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/FuckCode/2019/01/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><strong>本章节主要介绍网络基础知识，包括OSI模型，TCP/IP模型，以太网帧、ARP、IP等协议数据包，TCP/IP三次握手等，集中介绍网络编程中遇到的专业名词，为后续Socket编程以及高并发服务器模型大下基础。</strong><br><a id="more"></a></p><h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>OSI七层模型，有上及下分别为应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。如下图所示：</p><img src="/FuckCode/2019/01/16/Linux系统编程之网络基础/OSI模型.png" class="OSI模型"><p>图中已经将OSI模型对应的部分，以TCP/IP模型的方式进行了归类，具体每个层的含义如下：</p><ol><li>物理层: 主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流(就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换)。这一层的数据叫做比特，最原始的数据。</li><li>数据链路层: 定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。</li><li>网络层: 在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</li><li>传输层: 定义了一些传输数据的协议和端口号(WWW端口80等)，如:TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，UDP(用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的)。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</li><li>会话层: 通过传输层(端口号:传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求(设备之间需要互相认识可以是IP也可以是MAC或者是主机名)。</li><li>表示层: 可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码 (EBCDIC)，而另一台则使用美国信息交换标准码(ASCII)来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li><li>应用层: 是最靠近用户的OSI层。这一层为用户的应用程序(例如电子邮件、文件传输和终端仿真)提供网络服务。</li></ol><h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p>单纯将OSI模型拿出来讲，就已经很复杂了。然而对于我们开发人员来说，TCP/IP模型就显得更亲切了，如下图：</p><img src="/FuckCode/2019/01/16/Linux系统编程之网络基础/TCPIP模型.png" class="TCPIP模型"><p>从图中可以看出，理解TCP/IP模型相对OSI模型来说，就相对简单了，其适当对OSI模型进行抽象，分为四层：</p><ol><li>应用层，和用户直接打交道的一层，如Telnet，FTP和e-mail等</li><li>传输层，和程序员打交道最多的一层，设计Socket编程，如TCP，UDP</li><li>网络层，此层应该是网络中的设备，例如路由器，交换机的部分工作</li><li>链路层，此层接近于硬件设备，驱动模块以及接口卡</li></ol><h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示：</p><img src="/FuckCode/2019/01/16/Linux系统编程之网络基础/TCPIP通信过程.png" class="TCPIP通信过程"><p>其实在链路层之下还有物理层，指的是电信号的传递方式，比如现在以太网通用的网线 (双绞线)、早期以太网采用的的同轴电缆(现在主要用于有线电视)、光纤等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等。集线器(Hub)是工作在物理层的网络设备，用于双绞线的连接和信号中继(将已衰减的信号再次放大使之传得更远)。</p><img src="/FuckCode/2019/01/16/Linux系统编程之网络基础/跨路由通信过程.png" class="跨路由通信过程"><p>链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步(就是说从网线上检测到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧(比如十兆以太网和百兆以太网之间、以太网和令牌环网之间)，由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。</p><p>网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Internet上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。</p><p>网络层负责点到点(point-to-point)的传输(这里的“点”指主机或路由器)，而传输层负责端到端(end-to-end)的传输(这里的“端”指源主机和目的主机)。传输层可选择TCP或UDP协议。</p><p>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。</p><p>UDP协议不面向连接，也不保证可靠性，有点像寄信，写好信放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件是按顺序寄到目的地的。 使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</p><p>目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢?整个过程如下图所示：</p><img src="/FuckCode/2019/01/16/Linux系统编程之网络基础/Multiplexing过程.png" class="Multiplexing过程"><p>以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷 (payload，指除去协议首部之外实际传输的数据)是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</p><p>注意，虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。</p><h2 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h2><h3 id="数据包封装"><a href="#数据包封装" class="headerlink" title="数据包封装"></a>数据包封装</h3><p>传输层及其以下的机制由内核提供，应用层由用户进程提供，应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部(header)，称为封装 (Encapsulation)，如下图所示</p><p>不同的协议层对数据包有不同的称谓，在传输层叫做段(segment)，在网络层叫做数据报(datagram)，在链路层叫做帧(frame)。</p><p>数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理，可以将其过程理解为发送快递，快递过程中的打包、投递以及拆包过程对应到数据的各个阶段。</p><h3 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h3><p>以太网帧从名字可以看出其处于数据链路层，其中的源地址和目的地址是指网卡的硬件地址(也叫MAC地址)，长度是48位，是在网卡出厂时固化的，全球唯一标识。用ifconfig命令看一下，“HWaddr 00:15:F2:14:9E:3F”部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧末尾是CRC校验码。</p><img src="/FuckCode/2019/01/16/Linux系统编程之网络基础/以太网帧.png" class="以太网帧"><p>以太网帧中的数据长度（注意是数据长度，而不是全部长度）规定最小46字节，最大1500字节，由于ARP和RARP数据包的长度不够46字节，要在后面补填充位。例如类型为0806的ARP协议，其数据区必须达到最小规定字节数，28+18=46字节。</p><p>最大值1500称为以太网的最大传输单元(MTU)，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU了，则需要对数据包进行分片(fragmentation)。ifconfig命令的输出中也有“MTU: 1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。</p><h3 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h3><p>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。</p><p>源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段(以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播)，目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。</p><p>每台主机都维护一个ARP缓存表，可以用 arp -a 命令查看。缓存表中的表项有过期时间 (一般为20分钟)，如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发 ARP 请求来获得目的主机的硬件地址。</p><p>ARP数据报的格式如下所示</p><img src="/FuckCode/2019/01/16/Linux系统编程之网络基础/ARP数据报格式.png" class="ARP数据报格式"><p>注意到源 MAC 地址、目的 MAC 地址在以太网首部和 ARP 请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4(字节)，op字段为1表示ARP请求，op字段为2表示ARP应答。</p><p>具体通信流程这里不做过多解释。</p><h3 id="IP段格式"><a href="#IP段格式" class="headerlink" title="IP段格式"></a>IP段格式</h3><p>直接看图：</p><img src="/FuckCode/2019/01/16/Linux系统编程之网络基础/IP段格式.png" class="IP段格式"><p>IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节（4*8=32位）为单位的，最小值为5（5列数据），也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。</p><p>8位TOS字段有3个位用来指定IP数据报的优先级(目前已经废弃不用)，还有4个位表示可选的服务类型(最小延迟、最大吞吐量、最大可靠性、最小成本)， 还有一个位总是0。总长度是整个数据报(包括IP首部和IP层payload)的字节数。每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。</p><p>TTL(Time to live)是这样用的:源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳(hop)。协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。选项字段的解释从略。</p><h3 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h3><p>这里忽略，后续博文详细分析。</p><h3 id="TCP数据包格式"><a href="#TCP数据包格式" class="headerlink" title="TCP数据包格式"></a>TCP数据包格式</h3><p>这里忽略，后续博文详细分析。</p><h2 id="网络术语"><a href="#网络术语" class="headerlink" title="网络术语"></a>网络术语</h2><h3 id="路由route"><a href="#路由route" class="headerlink" title="路由route"></a>路由route</h3><ol><li>网络信息从信源到信宿的路径.路由是指路由器从一个接口上收到数据包，根据数据包的目的地址进行定向并转发到另一个接口的过程。</li><li>路由通常与桥接来对比，在粗心的人看来，它们似乎完成的是同样的事。它们的主要区别在于桥接发生在OSI参考模型的第二层(数据链路层)，而路由发生在第三层(网络层)。这一区别使二者在传递信息的过程中使用不同的信息，从而以不同的方式来完成其任务。</li><li>确定最佳路径,通过网络传输信息。</li></ol><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器(Router)是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号的设备。</p><p>传统地，路由器工作于OSI七层协议中的第三层，其主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址。因此，路由器首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个 MAC 地址，同时IP数据包头的 TTL(Time To Live)域也开始减数，并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。</p><p>路由器在工作时能够按照某种路由通信协议查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优(或最经济)的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新。</p><p>网络中，每个路由器的基本功能都是按照一定的规则来动态地更新它所保持的路由表，以便保持路由信息的有效性。为了便于在网络间传送报文，路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包，再将这些数据包分别通过相同或不同路径发送出去。当这些数据包按先后秩序到达目的地后，再把分解的数据包按照一定顺序包装成原有的报文形式。</p><p>路由器的分层寻址功能是路由器的重要功能之一，该功能可以帮助具有很多节点站的网络来存储寻址信息，同时还能在网络间截获发送到远地网段的报文，起转发作用;选择最合理的路由，引导通信也是路由器基本功能;多协议路由器还可以连接使用不同通信协议的网络段，成为不同通信协议网络段之间的通信平台。</p><p>路由和交换之间的主要区别就是交换发生在OSI参考模型第二层(数据链路层)，而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程中需使用不同的控制信息，所以两者实现各自功能的方式是不同的。</p><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>在计算机网络中，路由表或称路由择域信息库(RIB)是一个存储在路由器或者联网计 算机中的电子表格(文件)或类数据库。路由表存储着指向特定网络地址的路径</p><h3 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h3><p>以太网交换机是基于以太网传输数据的交换机，以太网采用共享总线型传输媒体方式的局域网。以太网交换机的结构是每个端口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。</p><p>以太网交换机工作于OSI网络参考模型的第二层(即数据链路层)，是一种基于 MAC(Media Access Control，介质访问控制)地址识别、完成以太网数据帧转发的网络设备。</p><h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3><p>DNS是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址串。</p><p>它是由解析器以及域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。</p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网</p><ol><li>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>使用专门铺设的传输介质进行联网，数据传输速率高(10Mb/s~10Gb/s) </li><li>通信延迟时间短，可靠性较高</li><li>局域网可以支持多种传输介质</li></ol><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><p>一种用来实现不同地区的局域网或城域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网。</p><p>覆盖的范围比局域网(LAN)和城域网(MAN)都广。广域网的通信子网主要使用分组交换技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如互联网是世界范围内最大的广域网。</p><ol><li>适应大容量与突发性通信的要求; </li><li>适应综合业务服务的要求; </li><li>开放的设备接口与规范化的协议; </li><li>完善的通信服务与网络管理。</li></ol><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。</p><ol><li>端口号小于256的定义为常用端口，服务器一般都是通过常用端口号来识别的。</li><li>客户端只需保证该端口号在本机上是惟一的就可以了。客户端口号因存在时间很短暂又称临时端口号;</li><li>大多数TCP/IP实现给临时端口号分配1024—5000之间的端口号。大于5000的端口<br>号是为其他服务器预留的。</li></ol><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><p>MTU:通信术语，最大传输单元(Maximum Transmission Unit，MTU)</p><p>是指一种通信协议的某一层上面所能通过的最大数据包大小(以字节为单位)。最大传输单元这个参数通常与通信接口有关(网络接口卡、串口等)。以下是一些协议的MTU</p><pre><code>FDDI协议：4352字节以太网（Ethernet）协议：1500字节PPPoE（ADSL）协议：1492字节X.25协议（Dial Up/Modem）：576字节Point-to—Point：4470字节</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章节集中介绍了网络中涉及的基础内容，包括OSI模型，TCP/IP模型，各层次之间数据包组织形式，以及网络中各种专业名次的相关解释，基本对网络能有有一个简单的认识，至于对我们最重要的TCP，UDP协议数据报的相关内容，后续会专门展开说明。</p><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之线程同步</title>
      <link href="/FuckCode/2019/01/15/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/FuckCode/2019/01/15/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p><strong>本章节着重介绍多线程下资源同步的问题，之前章节介绍了Linux多线程编程的有关知识，由于多线程下容易产生资源互抢情况，所以必须对共享资源进行统一规划，其涉及到的概念有互斥量，条件变量，信号量，文件锁以及进程间锁。</strong><br><a id="more"></a></p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>多线程下共享资源的争夺很是普遍的，对于为什么要进行线程同步，有如下几点：</p><ol><li>共享资源，多个线程都可对共享资源操作 </li><li>线程操作共享资源的先后顺序不确定 </li><li>处理器对存储器的操作一般不是原子操作</li></ol><h4 id="互斥量-pthread-mutex-t"><a href="#互斥量-pthread-mutex-t" class="headerlink" title="互斥量 pthread_mutex_t"></a>互斥量 pthread_mutex_t</h4><p>在多线程中，当多个线程访问同一个共享资源时候，这时候系统提供一把锁和一个钥匙，当线程A请求访问公共资源，那么线程A就申请系统拿到钥匙并上锁，此时如果另外一个线程B也想访问这个共享资源的话，也要向系统申请钥匙开锁，此时系统发现锁已经被线程A持有，就告诉线程B等待线程A访问完成后，锁被归还再通知线程B可以拿钥匙上锁，继而访问公共资源。</p><p>针对以上模型，互斥量就是这么个概念。可以把互斥变量值置为常量PTHREAD_MUTEX_INITIALIZER(针对静态分配的互斥量)，或调用pthread_mutex_init函数进行初始化。如果动态的分配互斥量（如调用malloc函数），那么在释放内存前需要调用pthread_mutex_destory。</p><h5 id="操作原语"><a href="#操作原语" class="headerlink" title="操作原语"></a>操作原语</h5><pre><code>// 初始化，动态初始化int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr)// 动态初始化后，手动回收int pthread_mutex_destroy(pthread_mutex_t *mutex)// 拿钥匙上锁，如果拿到钥匙，锁就被持有，外部再调用拿钥匙访问就会阻塞等待int pthread_mutex_tlock(pthread_mutex_t *mutex)// 尝试拿钥匙上锁，如果已经被锁，直接返回EBUSY，不阻塞int pthread_mutex_trylock(pthread_mutex_t *mutex)// 释放锁资源int pthread_mutex_unlock(pthreadd_mutex_t *mutex)</code></pre><p>对于锁的初始化有两种方式，静态和动态，如下：</p><ol><li><p>静态，直接使用常量 PTHREAD_MUTEX_INITIALIZER 初始化</p><pre><code>// 锁静态声明定义pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;pthread_mutex_lock(&amp;mutex);//do sometingpthread_mutex_unlock(&amp;mutex);</code></pre></li><li><p>动态初始化</p><pre><code>pthread_mutex_t mutex;// 默认方式初始化 mutex，属性值 NULLpthread_mutex_init(&amp;mutex, NULL);pthread_mutex_lock(&amp;mutex);//do sometingpthread_mutex_unlock(&amp;mutex);// 释放锁资源pthread_mutex_destroy(&amp;mutex)</code></pre></li></ol><h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><p>保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。</p><p>临界区的选定</p><pre><code>临界区的选定因尽可能小，如果选定太大会影响程序的并行处理性能。</code></pre><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>在使用互斥量时候，要避免死锁的发生，死锁产生原因：</p><ol><li>同一个线程在拥有A锁的情况下再次请求获得A锁 </li><li>线程一拥有A锁，请求获得B锁;线程二拥有B锁，请求获得A锁</li></ol><p>避免发生死锁的方法： </p><ol><li>按顺序加锁，例如加锁 lock1, lock2,lock3，在加锁 lock3 之前，必须先加 lock2 ,以此类推。释放 lock 时必须按倒序来</li><li>如果无法确定锁的顺序，尽量用 pthread_mutex_trylock 代替 pthread_mutex_lock 以避免死锁</li><li>用串行代替并行</li></ol><h5 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h5><pre><code>#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/*    互斥量    同一时间为 1 或者 0    保持共享数据的完整正确性*/#define NLOOP 5000// 共享数据int counter;// 锁静态声明定义pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;void *pthread_do(void * arg){    int i, val;    for (int i = 0; i &lt; NLOOP; ++i)    {        // 加锁，否则数据值丢失一半        pthread_mutex_lock(&amp;counter_mutex);        val = counter;        printf(&quot;%x: %d\n&quot;, (unsigned int)pthread_self(), val + 1);        counter = val + 1;        // 解除锁        pthread_mutex_unlock(&amp;counter_mutex);    }    return NULL;}int main(int argc, int *argv[]){    pthread_t tidA,tidB;    // 创建两个线程，争抢共享资源，通过互斥量保持数据的正确性    pthread_create(&amp;tidA,NULL,pthread_do,NULL);    pthread_create(&amp;tidB,NULL,pthread_do,NULL);    // 回收线程数据    pthread_join(tidA, NULL);    pthread_join(tidB, NULL);    return 0;}</code></pre><h4 id="读写锁-pthread-rwlock-t"><a href="#读写锁-pthread-rwlock-t" class="headerlink" title="读写锁 pthread_rwlock_t"></a>读写锁 pthread_rwlock_t</h4><p>百度百科如下解释读写锁：</p><pre><code>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。</code></pre><h5 id="读写锁原语"><a href="#读写锁原语" class="headerlink" title="读写锁原语"></a>读写锁原语</h5><pre><code>// 初始化读写锁int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr)// 销毁读写锁int pthread_rwlock_destroy(pthread_rwlock_t *rwlock)// 获取读锁int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)// 获取写锁int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)// 解锁（读锁后调用解读锁，写锁同样）int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)// 尝试拿读锁，非阻塞int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock)// 尝试拿写锁，非阻塞int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock)</code></pre><p>读写锁机制：读共享，写独占</p><h5 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h5><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;/*    读写锁    读时共享    写时独占*/int counter;// 定义读写锁pthread_rwlock_t rwlock;// 读线程，读共享void *th_read(void *arg){    int i = 100;    while(i--){        // 获取读锁        pthread_rwlock_rdlock(&amp;rwlock);        printf(&quot;read: %x, %d \n&quot;,pthread_self(),counter);        // 解除读锁        pthread_rwlock_unlock(&amp;rwlock);        usleep(100);    }}// 写线程，写独占void *th_write(void *arg){    int t;    int i = 100;    while(i--){        // 获取写锁        pthread_rwlock_wrlock(&amp;rwlock);        t = counter;        // usleep(100);        printf(&quot;write: %x, counter=%d, ++counter=%d \n&quot;,pthread_self(), t,++counter );        // 解除写锁        pthread_rwlock_unlock(&amp;rwlock);        usleep(100);    }}int main(int argc, char *argv[]){    pthread_t tid[8];    // 初始化读写锁    pthread_rwlock_init(&amp;rwlock,NULL);    // 3线程写    for (int i = 0; i &lt; 3; ++i)    {        pthread_create(&amp;tid[i],NULL,th_write,NULL);    }    // 5线程读    for (int i = 0; i &lt; 5; ++i)    {        pthread_create(&amp;tid[i+3],NULL,th_read,NULL);    }    // 销毁读写锁    pthread_rwlock_destroy(&amp;rwlock);    for (int i = 0; i &lt; 8; ++i)    {        /* code */        // 回收线程资源        pthread_join(tid[i],NULL);    }    return 0;}</code></pre><h4 id="条件变量-pthread-cond-t"><a href="#条件变量-pthread-cond-t" class="headerlink" title="条件变量 pthread_cond_t"></a>条件变量 pthread_cond_t</h4><p>条件变量是利用线程间共享全局变量进行同步的一种机制。条件变量上的基本操作有：触发条件(当条件变为 true 时)；等待条件，挂起线程直到其他线程触发条件。</p><p>条件变量一般和互斥量同步使用，其给多个线程提供了一个汇合的场所。例如典型的生产者和消费者，条件变量作为有产品的先决条件，而产品本身就可以看作互斥量，因为消费者也可能是多个线程同时争抢生产者生产出来的产品。</p><h5 id="条件变量原语"><a href="#条件变量原语" class="headerlink" title="条件变量原语"></a>条件变量原语</h5><p>初始化条件变量<br>　　<br>        int pthread_cond_init(pthread_cond_t <em>cond,pthread_condattr_t </em>cond_attr)</p><pre><code>尽管POSIX标准中为条件变量定义了属性，但在Linux中没有实现，因此cond_attr值通常为NULL，且被忽略。</code></pre><p>有两个等待函数 </p><pre><code>// 无条件等待int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex)// 超时等待int pthread_cond_timewait(pthread_cond_t *cond,pthread_mutex *mutex,const timespec *abstime);如果在给定时刻前条件没有满足，则返回ETIMEOUT，结束等待，其中abstime以与time()系统调用相同意义的绝对时间形式出现，0表示格林尼治时间1970年1月1日0时0分0秒。</code></pre><p>　<br>无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求。mutex互斥锁在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()），而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。</p><p>激发条件</p><pre><code>// 激活一个等待该条件的线程（存在多个等待线程时按入队顺序激活其中一个）　　int pthread_cond_signal(pthread_cond_t *cond);// 激活所有等待线程int pthread_cond_broadcast(pthread_cond_t *cond); </code></pre><p>销毁条件变量</p><pre><code>int pthread_cond_destroy(pthread_cond_t *cond);只有在没有线程在该条件变量上等待的时候才能销毁这个条件变量，否则返回EBUSY</code></pre><p>说明：</p><ol><li><p>pthread_cond_wait 自动解锁互斥量(如同执行了pthread_unlock_mutex)，并等待条件变量触发。这时线程挂起，不占用CPU时间，直到条件变量被触发（变量为ture）。在调用 pthread_cond_wait之前，应用程序必须加锁互斥量。pthread_cond_wait函数返回前，自动重新对互斥量加锁(如同执行了pthread_lock_mutex)。</p></li><li><p>互斥量的解锁和在条件变量上挂起都是自动进行的。因此，在条件变量被触发前，如果所有的线程都要对互斥量加锁，这种机制可保证在线程加锁互斥量和进入等待条件变量期间，条件变量不被触发。条件变量要和互斥量相联结，以避免出现条件竞争——个线程预备等待一个条件变量，当它在真正进入等待之前，另一个线程恰好触发了该条件（条件满足信号有可能在测试条件和调用pthread_cond_wait函数（block）之间被发出，从而造成无限制的等待）。</p></li><li><p>条件变量函数不是异步信号安全的，不应当在信号处理程序中进行调用。特别要注意，如果在信号处理程序中调用 pthread_cond_signal 或 pthread_cond_boardcast 函数，可能导致调用线程死锁</p></li></ol><p><a href="https://blog.csdn.net/jkx01whg/article/details/78119189" target="_blank" rel="noopener">参考链接</a></p><h5 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h5><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;/*    条件变量    条件变量给多个线程提供了一个汇合的场所    生产与消费模式*/// 产品信息struct msg{    struct msg *next;    int num;};struct msg *head;// 存在生产条件变量pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;// 互斥量pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;;// 消费者void *consumer(void *arg){    struct msg *msg;    for(;;){        // 先加锁，访问共享资源head，如果为空，则进入等待条件变量        pthread_mutex_lock(&amp;lock);        // 阻塞等待生产条件变量存在，此时还是加锁状态        while(head == NULL)            // 进入阻塞等待条件变量，此时线程挂起进入等待，锁被解开，生产者可以获取并生产            pthread_cond_wait(&amp;has_product,&amp;lock);        msg = head;        head = msg-&gt;next;        // 获取产品信息后，解锁以避免别的线程争抢资源        pthread_mutex_unlock(&amp;lock);        printf(&quot;Consume %d \n&quot;,msg-&gt;num);        free(msg);        sleep(rand()%5);    }}// 生产者void *producer(void *arg){    struct msg *msg;    for (;;)    {        // 新建产品内容        msg = malloc(sizeof(struct msg));        msg-&gt;num = rand() %1000 + 1;        printf(&quot;Produce %d \n&quot;,msg-&gt;num);        // 上锁，生产产品        pthread_mutex_lock(&amp;lock);        msg-&gt;next = head;        head = msg;        // 解锁，生产完成        pthread_mutex_unlock(&amp;lock);        // 传递生产条件变量到消费者，进行条件变量通知        pthread_cond_signal(&amp;has_product);        sleep(rand() % 5);    }}int main(int argc, char *argv[]){    pthread_t tidA,tidB;    // 利用系统时间产生随机数种子值，生产随机数    srand(time(NULL));    // 创建两个线程，测试消费和生产之间资源传递关系    pthread_create(&amp;tidA,NULL,producer,NULL);    pthread_create(&amp;tidB,NULL,consumer,NULL);    // 回收线程资源    pthread_join(tidA,NULL);    pthread_join(tidB,NULL);    return 0;}</code></pre><p>在消费者中，需要注意一下情况：</p><ol><li>消费者在消费之前，需要上锁获取共享资源生产的产品，此时产品在消费者线程中处于被锁状态，生产者此时无法获取，只能阻塞。当消费者监测无生产产品是，死循环等待条件变量 pthread_cond_wait 的产生。</li><li>pthread_cond_wait 进入之前，原语保证必须本线程处于锁状态中，此时线程进入挂起等待时刻，锁被解开，其他线程可以访问生产产品。</li><li>当生产者拿到锁生产处产品后，在调用 pthread_cond_signal 通知条件变量变化时，必须解锁共享产品资源，因为一旦通知后，消费者线程中就立即对生产产品的锁状态进行恢复，以确保代码往下继续进行。</li></ol><h4 id="信号量-sem-t"><a href="#信号量-sem-t" class="headerlink" title="信号量 sem_t"></a>信号量 sem_t</h4><p>信号量原理上等同于多个互斥量，同时提供多把锁和钥匙，丰富多线程下共享资源访问的并发行。</p><h5 id="信号量原语"><a href="#信号量原语" class="headerlink" title="信号量原语"></a>信号量原语</h5><p>头文件</p><pre><code>#include &lt;semaphore.h&gt;</code></pre><p>初始化信号量</p><pre><code>int sem_init (sem_t *sem , int pshared, unsigned int value)sem - 指定要初始化的信号量pshared - 信号量 sem 的共享选项，linux只支持0，表示它是当前进程的局部信号量value - 信号量 sem 的初始值</code></pre><p>信号量值加1</p><pre><code>int sem_post(sem_t *sem)给参数sem指定的信号量值加1</code></pre><p>信号量值减1</p><pre><code>int sem_wait(sem_t *sem)给参数sem指定的信号量值减1，如果sem所指的信号量的数值为0，函数将会阻塞等待直到有其它线程使它不再是0为止</code></pre><p>销毁信号量</p><pre><code>int sem_destroy(sem_t *sem)销毁指定的信号量</code></pre><h5 id="代码实例-2"><a href="#代码实例-2" class="headerlink" title="代码实例"></a>代码实例</h5><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;/*    信号量，互斥量的升级版，同时多把锁*/// 数据内容大小#define NUM 5// 队列　５int queue[NUM];// 信号量sem_t blank_number, product_number;// 生产者void *producer(void *arg){    int n = 0;    while(1){        //　取锁，blank_number内锁自减一；为０则阻塞等待        sem_wait(&amp;blank_number);        queue[n] = rand() % 1000 + 1;        printf(&quot;Produce %d num:%d \n&quot;,n,queue[n]);        // 释放锁，blank_number内锁自加一        sem_post(&amp;product_number);        // 队列数据补足，形成环形队列        n = (n+1) % NUM;        sleep(rand() % 5);    }}// 消费者void *consumer(void *arg){    int n = 0;    while(1){        sem_wait(&amp;product_number);        printf(&quot;Consume %d num: %d\n&quot;,n,queue[n]);        queue[n] = 0;        sem_post(&amp;blank_number);        n = (n+1) % NUM;        sleep(rand() % 5);    }}int main(int argc, char *argv[]){    pthread_t tidA, tidB;    // 初始化信号量，    // blank_number: 信号量数值５, 0等同于互斥量（存在一个锁）    // 中间参数: ０ 代表的是局部线程间共享信号量    sem_init(&amp;blank_number, 0, NUM);    sem_init(&amp;product_number, 0, 0);    // 两个线程间调度生产与消费内容    pthread_create(&amp;tidA, NULL, producer, NULL);    pthread_create(&amp;tidB, NULL, consumer, NULL);    // 回收线程资源    pthread_join(tidA, NULL);    pthread_join(tidB, NULL);    // 销毁信号量    sem_destroy(&amp;blank_number);    sem_destroy(&amp;product_number);    return 0;}</code></pre><p>相关解释：</p><ol><li>生产者持有的信号量5个，容器数组正好有5个缓冲区。每次生产调用sem_wait，信号量值自减少1（为0阻塞等待），生产完成调用sem_post释放。也就是同时可以5个生产者并发生产。</li><li>消费者对于数据的读取串行处理，其信号量值为0，等同于互斥量。数组内容一次读取，通过取余数进行矫正位。</li><li>消费者中对于信号量（初始值0，相当于互斥量，只能进入一次）首次调用sem_wait进入处理，此时信号量为0，其他线程再次获取及阻塞等待，获取数组内数据后，调用sem_post进行释放。</li></ol><h4 id="进程间锁-pthread-mutex-attr-t"><a href="#进程间锁-pthread-mutex-attr-t" class="headerlink" title="进程间锁 pthread_mutex_attr_t"></a>进程间锁 pthread_mutex_attr_t</h4><p>进程间共享内存互斥量，可以通过 pthread_mutex_attr_t 来配置。通过 pthread_mutex_attr_t 可以让进程之间访问共享的互斥量，从而进行资源的有序调度。</p><h5 id="共享互斥量操作原语"><a href="#共享互斥量操作原语" class="headerlink" title="共享互斥量操作原语"></a>共享互斥量操作原语</h5><p>初始化共享互斥量</p><pre><code>pthread_mutexattr_init(pthread_mutex_attr_t *attr)</code></pre><p>操作共享互斥量属性</p><pre><code>// 获得共享互斥量属性，由shared带出intpthread_mutexattr_getpshared(const pthread_mutexattr_t *restrictattr, int *restrictshared );// 设置共享互斥属性，有shard决定，默认为PTHREAD_PROCESS_PRIVATE，即线程共享intpthread_mutexattrattr_ setpshared (  constpthread_mutexattr_t *restrict attr,int pshared);若成功返回0，若失败返回错误编号。注意：shared的取值可以是        PTHREAD_PROCESS_SHARED  存在共享内存中，可以被多个进程中的线程共享        PTHREAD_PROCESS_PRIVATE 只有和创建这个互斥锁的线程在同一个进程中的线程才能访问这个互斥锁</code></pre><p>销毁共享互斥量</p><pre><code>pthread_mutex_attr_t_destroy(pthread_mutex_attr_t *attr)</code></pre><h5 id="代码实例-3"><a href="#代码实例-3" class="headerlink" title="代码实例"></a>代码实例</h5><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;/*    自定义进程间锁结构体*/struct mutex_lock{    int num;    // 互斥量    pthread_mutex_t mutex;    // 共享互斥量属性    pthread_mutexattr_t mutexattr;};int main(void){    int fd ,i;    struct mutex_lock *mlock;    pid_t pid;    fd = open(&quot;temp&quot;,O_CREAT | O_RDWR, 0777);    // 拓展文件大小    ftruncate(fd,sizeof(*mlock));    // 内存映射，进程间读写数据    mlock = mmap(NULL,sizeof(*mlock), PROT_READ | PROT_WRITE, MAP_SHARED, fd,0);    close(fd);    // 清空内存    memset(mlock,0,sizeof(*mutex_lock));    // 初始化进程间锁属性    pthread_mutexattr_init(&amp;mlock-&gt;mutexattr);    // 设置进程间锁为进程间共享（默认为线程共享）    pthread_mutexattr_setpshared(&amp;mlock-&gt;mutexattr, PTHREAD_PROCESS_SHARED);    // 初始化锁    pthread_mutex_init(&amp;mlock-&gt;mutex,&amp;mlock-&gt;mutexattr);    pid = fork();    // 通过父子不同进程，共同访问共享互斥量中 num 数据，对其进行修改    if(pid == 0){        // 子进程，临界区内执行10次 +1 操作        for (int i = 0; i &lt; 10; ++i)        {            // 取锁            pthread_mutex_lock(&amp;mlock-&gt;mutex);            (mlock-&gt;num)++;            printf(&quot;Child process num: %d\n&quot;,mlock-&gt;num);            // 释放锁            pthread_mutex_unlock(&amp;mlock-&gt;mutex);            sleep(1);        }    }    else {        for (int i = 0; i &lt; 10; ++i)        {            // 父进程，临界区内执行10次 +2 操作            pthread_mutex_lock(&amp;mlock-&gt;mutex);            mlock-&gt;num += 2;            printf(&quot;Parent process num: %d\n&quot;,mlock-&gt;num);            pthread_mutex_unlock(&amp;mlock-&gt;mutex);            sleep(1);        }        // 主线程阻塞等待子线程处理完毕        wait(NULL);    }    // 释放锁资源    pthread_mutexattr_destroy(&amp;mlock-&gt;mutexattr);    pthread_mutex_destroy(&amp;mlock-&gt;mutex);    // 解除内存文件映射    munmap(mlock,sizeof(*mlock));    // 删除临时文件    unlink(&quot;temp&quot;);    return 0;}</code></pre><p>代码说明：</p><ol><li>自定义结构体 mutex_lock 提供不同进程访问的数据基础。</li><li>初始化共享互斥量时候，通过内存映射将 mutex_lock 结构体置位进程共享（MAP_SHARED），同时其内部互斥量属性设置为进程共享（PTHREAD_PROCESS_SHARED）</li><li>父子进程访问结构体 mutex_lock 中的 num 时，都进行上锁，修改数据，解锁等操作，其互斥量能够进程间访问，依赖于之前内存映射以及互斥量属性中的都进行了进程共享属性设置。</li></ol><h4 id="文件锁-fcntl"><a href="#文件锁-fcntl" class="headerlink" title="文件锁 fcntl"></a>文件锁 fcntl</h4><p>文件锁是用于解决资源的共享使用的一种机制：当多个用户需要共享一个文件时，Linux通常采用的方法是给文件上锁，来避免共享的资源产生竞争的状态。</p><p>之前在文件I/O章节中介绍过这个函数，当时只是提到了如何使用 fcntl 进行对一大文件描述符进行权限位的更改，现在我们来了解如何通过 fcntl 对文件进行加锁访问。</p><p>文件锁机制中同样采用的是读共享，写排斥。</p><p>再了解 fcntl 函数之前，先来了解一下结构体 flock</p><pre><code>struct flock {... short l_type; // 文件锁操作类型: F_RDLCK（读锁）,F_WRLCK（写锁）, F_UNLCK（解锁）short l_whence; // 上锁内容的规定: SEEK_SET（开始）, SEEK_CUR（游标当前）, SEEK_END（结尾 off_t l_start; // 文件锁内容开始位置off_t l_len; // 文件锁区域长度，0代表全部 pid_t l_pid; //获取上锁进程pid（仅对F_GETLK有效）...        }; </code></pre><h5 id="fcntl-原语"><a href="#fcntl-原语" class="headerlink" title="fcntl 原语"></a>fcntl 原语</h5><pre><code>#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* arg */ )例如： int ret = fcntl(fd, F_SETLKW, &amp;lock);</code></pre><p>cmd命令解释： </p><ol><li>F_SETLK：设置锁（读锁F_RDLCK，写锁F_WRLCK）或者释放所（F_UNLCK），如果无法获取，直接返回error。</li><li>F_SETLKW：功能和F_SETLK一样，区别是阻塞等待</li><li>F_GETLK：这个接口是获取锁的相关信息：这个接口会修改我们传入的struct flock</li></ol><p>通过函数参数功能可以看出 fcntl(相对于lockf)是功能最强大的，它既支持共享锁又支持排他锁，即可以锁住整个文件，又能只锁文件的某一部分。</p><p>操作方式，通过结构体指定锁文件内容区域以及锁方式，然后通过命令 fcntl 将结构体锁属性提交到指定文件中。</p><h5 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h5><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;/*    文件锁    通过结构体 struct flock 来设置文件锁的具体属性，通过fcntl提交文件锁到文件    读锁共享，写锁互斥*/void sys_err(char *err){    perror(err);    exit(1);}int main(int argc, char *argv[]){    int fd;    struct flock f_lock;    if(argc &lt; 2){        printf(&quot; ./app must need filename\n&quot;);        exit(1);    }    if((fd = open(argv[1],O_RDWR))&lt;0){        sys_err(&quot;open&quot;);    }    // 写入文件锁，互斥    f_lock.l_type = F_WRLCK;    // 读文件锁，共享    // f_lock.l_type = F_RDLCK;    // 文件锁的游标指针    f_lock.l_whence = SEEK_SET;    // 文件锁的锁区开始位置    f_lock.l_start = 0;    // 文件锁锁区的大小，0代表全部锁住    f_lock.l_len = 0;    // 提交文件锁属性到文件    fcntl(fd,F_SETLKW, &amp;f_lock);    printf(&quot;lock file! \n&quot;);    sleep(30);    // 解除文件锁    f_lock.l_type = F_UNLCK;    fcntl(fd,F_SETLKW, &amp;f_lock);    printf(&quot;unlock flile! \n&quot;);    close(fd);    return 0;}</code></pre><p>以上代码可以采用以下方式测试：</p><ol><li><p>读共享</p><p> 注释 f_lock.l_type = F_WRLCK;<br> 打开 f_lock.l_type = F_RDLCK;<br> 新建txt文件到程序目录下，其内容自定义<br> 运行程序 ./app <em>.txt<br> 程序运行期间（30s），新建并运行程序对 </em>.txt 进行内容读取，测试是否成功</p></li><li><p>写排斥</p><p> 打开 f_lock.l_type = F_WRLCK;<br> 注释 f_lock.l_type = F_RDLCK;<br> 新建txt文件到程序目录下，其内容自定义<br> 运行程序 ./app <em>.txt<br> 程序运行期间（30s），新建并运行程序对 </em>.txt 进行内容修改，测试是否成功</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本博文主要介绍了如何对多线程下产生各种资源同步问题应对方式，主要集中介绍了互斥量，条件变量，信号量，文件锁以及进程间共享锁集中处理方式。</p><p>从上面的分析中，我们可以得出：</p><ol><li>单一的线程同步可以产用互斥量，条件变量和互斥量一同使用，可以控制共享资源的访问序列。</li><li>信号量机制提供了多把锁，进一步提升多线程下共享资源访问的并发性。</li><li>对于进程间同步，可以采用共享互斥量方式，通过设置互斥量属性实现，其机制上仍需要共享内存的帮助。</li><li>文件锁可以对文件进行锁同步，机制上依旧是读共享，写排斥方式。</li></ol><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程同步 锁机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之线程</title>
      <link href="/FuckCode/2019/01/14/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B/"/>
      <url>/FuckCode/2019/01/14/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>本章节介绍Linux下多线程编程方面的知识，涉及到线程和进程的关系，优缺点，线程基础背景，线程原语以及线程属性等方面内容，后续还会进阶的介绍多线程而引申出来的线程同步问题。让我们更加清晰的了解到多线程编程带来的魅力。</strong><br><a id="more"></a></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h4><p>典型的UNIX/Linux进程可以看成只有一个控制线程：一个进程在同一时刻只做一件事情。有了多个控制线程后，在程序设计时可以把进程设计成在同一时刻做不止一件事，每个线程各自处理独立的任务。　　</p><p>进程是程序执行时的一个实例，是担当分配系统资源（CPU时间、内存等）的基本单位。在面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。</p><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程包含了表示进程内执行环境必须的信息，其中包括进程中表示线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno常量以及线程私有数据。进程的所有信息对该进程的所有线程都是共享的，包括可执行的程序文本、程序的全局内存和堆内存、栈以及文件描述符。在Unix和类Unix操作系统中线程也被称为轻量级进程<br>（lightweight processes），但轻量级进程更多指的是内核线程（kernel thread），而把用户线程（user thread）称为线程。</p><p>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><h5 id="线程间共享资源"><a href="#线程间共享资源" class="headerlink" title="线程间共享资源"></a>线程间共享资源</h5><p>线程几乎共享进程中的任何资源，因为都是同属一个容器内。具体罗列如下：</p><ol><li>文件描述符表 </li><li>每种信号的处理方式 </li><li>当前工作目录 </li><li>用户ID和组ID </li><li>内存地址空间</li><li>代码段中的 Text data bss 堆 共享库</li></ol><img src="/FuckCode/2019/01/14/Linux系统编程之线程/线程共享资源.png" class="线程共享资源"><h5 id="线程间非共享资源"><a href="#线程间非共享资源" class="headerlink" title="线程间非共享资源"></a>线程间非共享资源</h5><p>但是线程间也有不共享的资源，如：</p><ol><li>线程id </li><li>处理器现场和栈指针(内核栈) </li><li>独立的栈空间(用户空间栈) </li><li>errno变量</li><li>信号屏蔽字</li><li>调度优先级</li></ol><h5 id="线程与进程有缺点"><a href="#线程与进程有缺点" class="headerlink" title="线程与进程有缺点"></a>线程与进程有缺点</h5><p>使用多线程的理由之一是和进程相比，它是一种非常”节俭”的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。</p><p>使用多线程的理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。</p><p>优点：</p><pre><code>提高程序的并发性，提高应用程序响应开销小，不用重新分配内存通信、共享数据方便使多CPU系统更加有效，操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分</code></pre><p>缺点：</p><pre><code>线程不如进程来的稳定（库实现）多进程下调试困难（gdb支持不好）无法使用unix经典事件，信号（线程下信号处理共享）</code></pre><h5 id="线程库安装"><a href="#线程库安装" class="headerlink" title="线程库安装"></a>线程库安装</h5><p>Linux下的线程实现基于库的方式，因此使用编译过程中都需要额外指定编译库 -lpthread</p><ol><li><p>查看 pthread 函数 Manpage</p><p> man -k pthread</p></li><li><p>安装 pthread 相关的 Manpage</p><p> sudo apt-get install manpages-posix manpages-posix-dev</p></li></ol><h4 id="线程原语"><a href="#线程原语" class="headerlink" title="线程原语"></a>线程原语</h4><p>一下介绍多线程编程中涉及的线程原语。</p><h5 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h5><pre><code>#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)pthread_t *thread： 传递一个pthread_t变量地址，用于保存新线程的tidpthread_attr_t *attr： 线程属性设置，默认为 NULLvoid *(*start_routine)(void *)： 函数指针，新线程加载后执行的函数模块void *arg：  加载函数调用的参数返回值： 成功返回0，失败返回错误号；（注意其他函数失败返回 -1， 设置errno，这里的pthread时库函数实现，返回值返回错误号，其线程中存在errno是为了兼容其他函接口而提供，pthread并不使用他）</code></pre><p>编译时，添加控制项 -lpthread</p><p>在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create() 返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针 start_routine 决定。start_routine 函数接收一个参数，是通过 pthread_create 的 arg 参数传递给它的，该参数的类型为void <em>，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void </em>，这个指针的含义同样由调用者自己定义。start_routine 返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态。</p><p>pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2) 可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值， 也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用 pthread_self(3)可以获得当前线程的id。</p><p>代码实例：<br>测试进程可以创建多少个线程</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;void *pthread_fun(void *arg){    while(1){        sleep(1);    }}int main(void){    pthread_t tid;    int i =1,err;    while(1){        err = pthread_create(&amp;tid, NULL,pthread_fun,NULL);        if(err != 0){            printf(&quot;%s \n&quot;, strerror(err));            exit(1);        }        printf(&quot;%x   %d\n&quot;,tid,i++);    }    return 0;}</code></pre><h5 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h5><p>获取调用线程tid</p><pre><code>pthread_t pthread_self(void)</code></pre><p>实例测试：</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;// 线程家在函数，必须规定：返回值 void *， 参数 void *void* pthread_fun(void* arg){    printf(&quot;pthread pid: %d\n&quot;, getpid());    printf(&quot;pthread id: %x\n&quot;, (unsigned int)pthread_self());    printf(&quot;pthread arg: %d\n&quot;,(int *)arg);}int main(void){    pthread_t ptid;    int n = 10;    int err;    if((err = pthread_create(&amp;ptid, NULL, pthread_fun, (void *)n))!=0){        fprintf(stderr,&quot;can not create thread: %s\n&quot;,strerror(err));        exit(1);    }    printf(&quot;main return ptid: %x\n&quot;, (unsigned int)ptid);    printf(&quot;main pid: %d\n&quot;, getpid());    printf(&quot;main thread id: %x\n&quot;, pthread_self());    // 等待1s，子线程处理    sleep(1);}</code></pre><p>由于pthread_create 的错误码不保存在 errno 中，因此不能直接用 perror(3) 打印错误信 息，可以先用 strerror(3) 把错误码转换成错误信息再打印。</p><p>如果任意一个线程调用了 exit 或 _exit ，则整个进程的所有线程都终止，由于从 main 函数 return 也相当于调用 exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行。</p><h5 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h5><p>调用线程退出函数，注意和 exit 函数的区别，任何线程里 exit 导致进程退出，其他线程未工作结束，主控线程退出时不能 return 或 exit 。</p><pre><code>void pthread_exit(void *value_ptr)void *value_ptr： 线程退出时传出的参数，可以指值或者地址，地址不可以是线程内部申请的局部地址</code></pre><p>需要注意，pthread_exit 或者 return 返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</p><h5 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h5><p>将线程挂起，等待处理结束。</p><pre><code>int pthread_join(pthread_t thread, void **value_ptr)pthread_t thread： 需要挂起监测的线程void **value_ptr： 存放线程中止状态值</code></pre><p>调用该函数的线程将挂起等待，直到 id 为 thread 的线程终止。thread 线程以不同的方法终止，通过 pthread_join 得到的终止状态是不同的，总结如下:</p><ol><li>如果 thread 线程通过 return 返回， retval 所指向的单元里存放的是 thread 线程函数的返回值。</li><li>如果 thread 线程被别的线程调用 pthread_cancel 异常终止掉，retval 所指向的单元里存放的是常数 PTHREAD_CANCELED。</li><li>如果 thread 线程是自己调用 pthread_exit 终止的，retval 所指向的单元存放的是传给 pthread_exit 的参数。</li><li>如果对 thread 线程的终止状态不感兴趣，可以传 NULL 给 retval 参数。</li></ol><h5 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h5><p>在进程内某个线程可以取消另一个线程。</p><pre><code>int pthread_cancel(pthread_t thread)pthread_t thread： 被取消的线程退出值，定义在Linux的pthread库中，常数 PTHREAD_CANCELED 的值是 -1</code></pre><p>代码实例：<br>通过 return，pthread_exit，pthread_cancel分别控制线程结束</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;// 正常return方式返回void* pthread_fun1(void* arg){    printf(&quot;thread 1 return \n&quot;);    return (void*)1;}// 通过pthread_exit方式返回void* pthread_fun2(void* arg){    printf(&quot;thread 2 pthread_exit \n&quot;);    pthread_exit((void*)2);}// 通过其他线程调用pthread_cancel返回void* pthread_fun3(void* arg){    while(1){        printf(&quot;thread 3 do while - sleep\n&quot;);        sleep(1);    }}    int main(void){    pthread_t tid;    void* tret;    pthread_create(&amp;tid, NULL, pthread_fun1, NULL);    pthread_join(tid,&amp;tret);    printf(&quot;thread 1 exit code with return %d\n&quot;,(int)tret);    pthread_create(&amp;tid, NULL, pthread_fun2, NULL);    pthread_join(tid,&amp;tret);    printf(&quot;thread 2 exit code with pthread_exit %d\n&quot;,(int)tret);    pthread_create(&amp;tid, NULL, pthread_fun3, NULL);    sleep(3);    pthread_cancel(tid);    pthread_join(tid,&amp;tret);    printf(&quot;thread 3 exit code with pthread_cancel %d\n&quot;,(int)tret);    return 0;}</code></pre><h5 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h5><p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用 pthread_join 获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。</p><pre><code>int pthread_detach(pthread_t thread)pthread_t thread： 需要分离态的线程id</code></pre><p>不能对一个已经处于detach状态的线程调用 pthread_join，这样的调用将返回 EINVAL。如果已经对一个线程调用了 pthread_detach 就不能再调用 pthread_join（互斥） 了。</p><p>如果子线程的资源需要主线程来回收的话，那么主线程就一定要等子线程结束，因为子线程结束，你就不能去回收；但是如果子线程资源要自动回收的话，那么主线程就不必等了。</p><p>代码实例：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;void *pthread_fun(void *arg){    int i = 3;    while(i--){        printf(&quot;thread count %d\n&quot;, i);        sleep(1);    }    return (void *)1;}int main(void){    pthread_t tid;    void *tret;    int err;    pthread_create(&amp;tid, NULL, pthread_fun, NULL);    // 分两次运行，一次打开以下代码编译运行，一次注释代码运行，查看结果    pthread_detach(tid);    // 已分离态，禁止调用 pthread_join    // pthread_join(tid,NULL);    while(1){        err = pthread_join(tid, &amp;tret);        if(err != 0){            fprintf(stderr,&quot;thread %s \n&quot;, strerror(err));        }else{            fprintf(stderr, &quot;thread exit code %d\n&quot;,(int)tret);        }        sleep(1);    }    return 0;}</code></pre><p>上述代码，第一次使用 pthread_detach 将线程置于分离态，此时 pthread_join 失败，走打印 strerror(err)；不使用 pthread_detach，等待子线程运行结束，打印输出正常运行结束返回值。</p><h5 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h5><p>比较两个线程是否相等</p><pre><code>int pthread_equal(pthread_t t1, pthread_t t2)pthread_t t1： 比较线程id 1pthread_t t2： 比较线程id 2 </code></pre><h4 id="线程终止方式"><a href="#线程终止方式" class="headerlink" title="线程终止方式"></a>线程终止方式</h4><p>如果需要只终止某个线程而不终止整个进程，可以有三种方法:</p><ol><li>从线程主函数 return。这种方法对主控线程不适用，从 main 函数 return 相当于调用 exit。</li><li>一个线程可以调用 pthread_cancel 终止同一进程中的另一个线程。 </li><li>线程可以调用 pthread_exit 终止自己。</li></ol><p>注意：同一个进程中，pthread_cancel 向另一个线程发送终止信号，系统并不会马上关闭被终止的线程，只有在终止线程下次系统调用时，才会真正的结束。或者调用 pthread_testcancel，让内核去检测是否需要取消当前线程。</p><h4 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h4><p>linux下线程的属性是可以根据实际项目需要进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</p><pre><code>typedef struct{    int                           detachstate;     线程的分离状态    int                          schedpolicy;   线程调度策略    struct sched_param      schedparam;   线程的调度参数    int                          inheritsched;    线程的继承性    int                          scope;          线程的作用域    size_t                      guardsize; 线程栈末尾的警戒缓冲区大小    int                          stackaddr_set;    void *                     stackaddr;      线程栈的位置    size_t                      stacksize;       线程栈的大小}pthread_attr_t;</code></pre><p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为 pthread_attr_init。这个函数必须在 pthread_create 函数之前调用。之后须用 pthread_attr_destroy 函数来释放资源。</p><p>线程属性主要包括如下属性:作用域(scope)、栈尺寸(stack size)、栈地址 (stack address)、优先级(priority)、分离的状态(detached state)、调度策略和参数(scheduling policy and parameters)。</p><p>默认的属性为非绑定、非分离、缺省M的堆栈、与父进程同样级别的优先级。</p><h5 id="线程属性初始化"><a href="#线程属性初始化" class="headerlink" title="线程属性初始化"></a>线程属性初始化</h5><p>先初始化线程属性，再 pthread_create 创建线程，最后 pthread_attr_destroy 回收属性。</p><pre><code>int pthread_attr_init(pthread_attr_t *attr)int pthread_attr_destroy(pthread_attr_t *attr)pthread_attr_t *attr： 线程属性结构体地址</code></pre><h5 id="线程的分离状态-detached-state"><a href="#线程的分离状态-detached-state" class="headerlink" title="线程的分离状态(detached state)"></a>线程的分离状态(detached state)</h5><p>线程的分离状态决定一个线程以什么样的方式来终止自己。</p><p>非分离状态: 线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当 pthread_join 函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</p><p>分离状态: 分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</p><p>int pthread_attr_setdetachstate(pthread_attr_t <em>attr, int detachstate)<br>int pthread_attr_getdetachstate(const pthread_attr_t </em>attr, int *detachstate)</p><p>pthread_attr_t *attr： 线程属性结构体地址<br>int detachstate： 分离 PTHREAD_CREATE_DETACHED，非分离状态 THREAD_CREATE_JOINABLE</p><p>这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在 pthread_create 函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用 pthread_create 的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用 pthread_cond_timedwait 函数，让这个线程等待一会儿，留出足够的时间让函数 pthread_create 返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait 之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p><p>代码实例：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;void *pthread_fun(void *arg){    int i = 30;    while(i--){        printf(&quot;%x   %d\n&quot;,pthread_self(),i);        sleep(1);    }    return (void *)1;}int main(void){    pthread_t tid;    pthread_attr_t attr; // attr里面保存的是垃圾值    int err;    pthread_attr_init(&amp;attr); // 设置线程属性    // int detachstate:     // PTHREAD_CREATE_DETACHED, PTHREAD_CREATE_JOINABLE    // 设置线程为分离状态    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);    pthread_create(&amp;tid, &amp;attr,pthread_fun,NULL);    err = pthread_join(tid,NULL);    while(1){        if(err != 0){            printf(&quot;%s \n&quot;, strerror(err));            sleep(15);            pthread_exit((void *)1);        }    }    return 0;}</code></pre><h5 id="线程的栈地址-stack-address"><a href="#线程的栈地址-stack-address" class="headerlink" title="线程的栈地址(stack address)"></a>线程的栈地址(stack address)</h5><p>POSIX.1定义了两个常量 _POSIX_THREAD_ATTR_STACKADDR 和 _POSIX_THREAD_ATTR_STACKSIZE 检测系统是否支持栈属性。也可以给sysconf函数传递 _SC_THREAD_ATTR_STACKADDR或 _SC_THREAD_ATTR_STACKSIZE 来进行检测。</p><p>当进程栈地址空间不够用时，指定新建线程使用由 malloc 分配的空间作为自己的栈空间。通过 pthread_attr_setstackaddr 和 pthread_attr_getstackaddr 两个函数分别设置和获取线程的栈地址。传给 pthread_attr_setstackaddr 函数的地址是缓冲区的低地址(不一定是栈的开始地址，栈可能从高地址往低地址增长)。</p><pre><code>int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackaddr)int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr)pthread_attr_t *attr： 线程属性结构体*stackaddr： 获取的栈地址成功返回0，错误返回错误号</code></pre><p>此函数已过时，使用 pthread_attr_getstacksize 替换</p><h5 id="线程的栈大小-stack-size"><a href="#线程的栈大小-stack-size" class="headerlink" title="线程的栈大小(stack size)"></a>线程的栈大小(stack size)</h5><p>当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用,当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。</p><p>函数 pthread_attr_getstacksize 和 pthread_attr_setstacksize 提供设置。</p><pre><code>int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize)int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize)pthread_attr_t *attr： 指向一个线程属性的指针size_t *stacksize： 返回线程的堆栈大小返回值： 成功返回0，错误返回错误号</code></pre><p>除上述对栈设置的函数外，还有以下两个函数可以获取和设置线程栈属性</p><pre><code>int pthread_attr_getstack(const pthread_attr_t *attr, void **stackaddr, size_t *stacksize)int pthread_attr_setstacksize(pthread_attr_t *attr, void *stackaddr, size_t stacksize)pthread_attr_t *attr： 指向一个线程属性的指针void *stackaddr： 返回获取的栈地址size_t *stacksize： 返回获取的栈大小返回值： 成功返回0，错误返回错误号</code></pre><h5 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h5><p>使用线程属性，指定线程栈大小，测试系统可以创建线程数量。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;// 指定栈大小#define SIZE 0x1000int print_ntimes(char *str){    sleep(1);    printf(&quot;%s\n&quot;,str);    return 0;}// 线程载入实体函数void* pthread_fun(void *arg){    int n = 3;    while(n--){        print_ntimes(&quot;hello allies \n&quot;);    }}int main(void){    pthread_t tid;    int err, detachstate, i =1;    // 线程属性结构体    pthread_attr_t attr;    // 栈大小    size_t stacksize;    // 栈地址    void *stackaddr;    // 初始化线程属性    pthread_attr_init(&amp;attr);    // 获取并打印默认的栈信息    pthread_attr_getstack(&amp;attr, &amp;stackaddr,&amp;stacksize);    printf(&quot;stackaddr = %p\n&quot;,stackaddr );    printf(&quot;stacksize = %x\n&quot;, (int)stacksize);    // 获取分离状态    pthread_attr_getdetachstate(&amp;attr, &amp;detachstate);    if(detachstate == PTHREAD_CREATE_DETACHED)        printf(&quot;thread detached \n&quot;);    else if(detachstate == PTHREAD_CREATE_JOINABLE)        printf(&quot;thread join\n&quot;);    else        printf(&quot;thread uknown\n&quot;);    // 设置分离态属性    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);    while(1){        // 手动分配栈内存        stackaddr = malloc(SIZE);        if(stackaddr == NULL){            perror(&quot;malloc error!&quot;);            exit(1);        }        stacksize = SIZE;        // 设置栈属性        pthread_attr_setstack(&amp;attr,stackaddr,stacksize);        // 线程属性设置完成，在创建线程，此时传入属性参数 attr        err = pthread_create(&amp;tid, &amp;attr, pthread_fun, NULL);        if(err != 0){            printf(&quot;%s\n&quot;,strerror(err));            exit(1);        }        printf(&quot;%d\n&quot;,i++);    }    // 回收线程属性    pthread_attr_destory(&amp;attr);    return 0;}</code></pre><p>输出打印：</p><pre><code>Allies:xiancheng rememberme$ ./pthread_attr_stackstackaddr = 0x0stacksize = 80000thread join123...40944095Resource temporarily unavailable</code></pre><h4 id="若干注意"><a href="#若干注意" class="headerlink" title="若干注意"></a>若干注意</h4><p>多线程虽然给我提供很多便利，但是还是要注意一下几点：</p><ol><li>主线程退出其他线程不退出，主线程应调用ptrhed_exit </li><li>避免僵线程，使用join，分离态等手动回收或者自动释放资源</li><li>malloc 和 mmap 申请的内存可以被其他线程释放 </li><li>如果线程终止时没有释放加锁的互斥量，则该互斥量不能再被使用 </li><li>应避免在多线程模型中调用 fork，除非马上 exec，子进程中只有调用 fork 的线程存在，其他线程在子进程中均 pthread_exit </li><li>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本博客主要集中的介绍了 Linux 下多线程编程的内容，设计线程进程之间的比较，线程创建销毁原语以及更高级的线程属性原语。对于线程原语也仅仅是停留在理论入门阶段，更高级的方法需要在以后实际工作中切实落实。最后，毕竟 Linux 下的多线程是基于库实现的，使用时需要自己主机安装响应的线程库，之后在编译过程中添加 -lpthread 条件。</p><p>对于多线程编程带来的资源抢夺问题，而产生的同步问题，再下一篇博客中集中说明 Linux 下各种同步锁机制，让我们拭目以待。</p><p><a href="https://www.cnblogs.com/xiehongfeng100/p/4620852.html" target="_blank" rel="noopener">更多参考</a></p><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之守护进程</title>
      <link href="/FuckCode/2019/01/14/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
      <url>/FuckCode/2019/01/14/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>本章节介绍Linux系统中特殊的进程-守护进程（Daemon），其类似于安卓中后台服务的存在，生存周期足够长，能够长期运行于后台，周期的执行某些任务或事件。其次，在介绍守护进程模型之前，我们还需要了解进程间几个重要的概念，例如控制终端、进程组和会话等。</strong></p><a id="more"></a><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>Daemon(精灵)进程,是Linux中的后台服务进程,生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</p><p>它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。</p><p>守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。</p><p>守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。</p><p>守护进程的名称通常以d结尾，比如sshd、xinetd、crond等。</p><p>对于守护进程的创建过程，需要了解进程中几个重要概念，控制终端、进程组和会话。</p><h4 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h4><p>在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端(Controlling Terminal)。</p><p>控制终端是保存在PCB中的信息，而我们知道fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。</p><p>默认情况下(没有重定向)，每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输 出写也就是输出到显示器上。</p><p>文件与I/O中讲过，每个进程都可以通过一个特殊的设备文件/dev/tty访问它的控制终端。事实上每个终端设备都对应一个不同的设备文件，/dev/tty提供了一个通用的接口，一个进程要访问它的控制终端既可以通过/dev/tty也可以通过该终端设备所对应的设备文件来访问。ttyname函数可以由文件描述符查出对应的文件名，该文件描述符必须指向一个终端设备而不能是任意文件。</p><h5 id="终端数据执行流程"><a href="#终端数据执行流程" class="headerlink" title="终端数据执行流程"></a>终端数据执行流程</h5><p>数据流在终端中执行流程如下图：</p><img src="/FuckCode/2019/01/14/Linux系统编程之守护进程/终端设备模块.png" class="终端设备模块"><p>硬件驱动程序负责读写实际的硬件设备，比如从键盘读入字符和把字符输出到显示器， 线路规程像一个过滤器，对于某些特殊字符并不是让它直接通过，而是做特殊处理，比如在 键盘上按下Ctrl-Z，对应的字符并不会被用户程序的read读到，而是被线路规程截获，解释成SIGTSTP信号发给前台进程，通常会使该进程停止。线路规程应该过滤哪些字符和做哪些<br>特殊处理是可以配置的。</p><h5 id="网络终端"><a href="#网络终端" class="headerlink" title="网络终端"></a>网络终端</h5><p>虚拟终端或串口终端的数目是有限的，虚拟终端(字符控制终端)一般就是/dev/tty1 ∼ /dev/tty6六个，串口终端的数目也不超过串口的数目。然而网络终端或图形终端窗口的数目却是不受限制的，这是通过伪终端(Pseudo TTY)实现的。一套伪终端由一个主设备(PTY Master)和一个从设备(PTY Slave)组成。主设备在概念上相当于键盘和显示器，只不过它不是真正的硬件而是一个内核模块，操作它的也不是用户而是另外一个进程。从设备和上面介绍的/dev/tty1这样的终端设备模块类似，只不过它的底层驱动程序不是访问硬件而是访问主设备。网络终端或图形终端窗口的Shell进程以及它启动的其它进程都会认为自己的控制终端是伪终端从设备，例如/dev/pts/0、/dev/pts/1等。下面以telnet为例说明网络登录和使用伪终端的过程。</p><p>如果telnet客户端和服务器之间的网络延迟较大，我们会观察到按下一个键之后要过几秒钟才能回显到屏幕上。这说明我们每按一个键telnet客户端都会立刻把该字符发送给服务器，然后这个字符经过伪终端主设备和从设备之后被Shell进程读取，同时回显到伪终端从设备，回显的字符再经过伪终端主设备、telnetd服务器和网络发回给telnet客户端，显示给用户看。也许你会觉得吃惊，但真的是这样:每按一个键都要在网络上走个来回!</p><p>其网络终端中数据流导向如下图所示：</p><img src="/FuckCode/2019/01/14/Linux系统编程之守护进程/网络终端.png" class="网络终端"><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><p>进程组： 一个或多个进程的集合,进程组ID是一个正整数。</p><h5 id="获取进程组id"><a href="#获取进程组id" class="headerlink" title="获取进程组id"></a>获取进程组id</h5><p>用来获得当前进程进程组ID的函数</p><pre><code>pid_t getpgid(pid_t pid)pid_t getpgrp(void)</code></pre><h5 id="获取进程组实例"><a href="#获取进程组实例" class="headerlink" title="获取进程组实例"></a>获取进程组实例</h5><p>获取父子进程的进程组</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(void){    pid_t pid;    if((pid = fork()) &lt; 0){        perror(&quot;fork&quot;);        exit(1);    }else if(pid == 0){        printf(&quot;child process PID is %d\n&quot;, getpid());        printf(&quot;Group ID is %d\n&quot;, getpgrp());        printf(&quot;Group ID is %d\n&quot;, getpgid(0));        printf(&quot;Group ID is %d\n&quot;, getpgid(getpid()));        exit(0);    }    sleep(3);    printf(&quot;parent process PID is %d\n&quot;,getpid());    printf(&quot;Group ID is %d\n&quot;, getpgrp());    return 0;}</code></pre><p>注意：</p><ol><li>组长进程标识:其进程组ID == 其进程ID</li><li>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止,只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关</li><li>进程组生存期:进程组创建到最后一个进程离开(终止或转移到另一个进程组)</li><li>一个进程可以为自己或子进程设置进程组ID</li></ol><h5 id="创建或设置进程组"><a href="#创建或设置进程组" class="headerlink" title="创建或设置进程组"></a>创建或设置进程组</h5><p>setpgid()加入一个现有的进程组或创建一个新进程组,如改变父子进程为新的组</p><pre><code>int setpgit(pid_t pid, pid_t pgid)如改变子进程为新的组，应在fork后，exec之前非root进程只能改变自己创建的子进程，或者有权限操作的进程</code></pre><h5 id="设置进程组实例"><a href="#设置进程组实例" class="headerlink" title="设置进程组实例"></a>设置进程组实例</h5><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(void){    pid_t pid;    if((pid = fork()) &lt; 0){        perror(&quot;fork&quot;);        exit(1);    }else if(pid == 0){        printf(&quot;child process PID is %d\n&quot;, getpid());        // 返回当前的组id        printf(&quot;Group ID is %d\n&quot;, getpgid(0));        sleep(5);        // 返回改变之后的组id        printf(&quot;Group ID of child is changed to %d\n&quot;, getpgid(0));         exit(0);    }    sleep(1);    printf(&quot;parent process PID is %d\n&quot;,getpid());    printf(&quot;Group ID is %d\n&quot;, getpgrp());    setpgid(pid, pid);    sleep(5);    printf(&quot;parent process PID is %d\n&quot;,getpid());    printf(&quot;parent of parent process PID is %d\n&quot;,getppid());    printf(&quot;Group ID of parent is %d\n&quot;, getpgid(0));    // 改变父进程的组id为父进程的父进程    setpgid(getpid(), getpgid());    printf(&quot;Group ID of parent is changed to %d\n&quot;, getpgid(0));    return 0;}</code></pre><h4 id="会话session"><a href="#会话session" class="headerlink" title="会话session"></a>会话session</h4><p>其实叫做会话期(session)，它包括了期间所有的进程组，一般一个会话期开始于用户login，一般login的是shell终端，所以shell终端又是此次会话期的首进程，会话一般结束于logout。对于非进程组长，它可以调用setsid()创建一个新的会话。</p><pre><code>pid_t setsid(void)</code></pre><p>注意：</p><ol><li>调用进程不能是进程组组长,该进程变成新会话首进程(session header) </li><li>该进程成为一个新进程组的组长进程。 </li><li>需有root权限(ubuntu不需要) </li><li>新会话丢弃原有的控制终端,该会话没有控制终端 </li><li>该调用进程是组长进程，则出错返回 </li><li>建立新会话时，先调用 fork, 父进程终止，子进程调用</li></ol><p>获取会话id</p><pre><code>pid_t getsid(pid_t pid)</code></pre><p>pid 为 0 表示察看当前进程session ID</p><p>ps ajx命令查看系统中的进程。</p><pre><code>参数a表示不仅列当前用户的进程，也列出所有其他用户的进程，参数x表示不仅列有控制终端的进程，也列出所有无控制终端的进程，参数j表示 列出与作业控制相关的信息。</code></pre><p>组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</p><h5 id="会话实例"><a href="#会话实例" class="headerlink" title="会话实例"></a>会话实例</h5><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(void){    pid_t pid;    if((pid = fork()) &lt; 0){        perror(&quot;fork&quot;);        exit(1);    }else if(pid == 0){        printf(&quot;child process PID is %d\n&quot;, getpid());        printf(&quot;Group ID is %d\n&quot;, getpgid(0));        printf(&quot;Session ID of child is %d\n&quot;, getsgid(0));        sleep(10);        // 子进程非组长进程，故其成为新会话首进程，且为组长进程。        // 该进程组id极为会话进程。        setsid();        printf(&quot;Changed: \n&quot;);        printf(&quot;parent process PID is %d\n&quot;,getpid());        printf(&quot;Group ID is %d\n&quot;, getpgrp());        printf(&quot;Session ID of child is %d\n&quot;,getsid(0));        sleep(20);        exit(0);    }    return 0;}</code></pre><h4 id="守护进程模型"><a href="#守护进程模型" class="headerlink" title="守护进程模型"></a>守护进程模型</h4><p>守护进程的创建有一定的规律，如下总结：</p><ol><li><p>创建子进程，父进程退出<br> 任务工作于子进程中，形式上脱离控制终端</p></li><li><p>子进程创建新会话，独立出来<br> setsid()</p></li><li><p>改变当前工作目录为根目录（也可以其他路径），防止占用可卸载的文件系统<br> chdir()</p></li><li><p>重设文件权限掩码值，防止继承的文件创建屏蔽字拒绝某些权限，增减守护进程的灵活性<br> umask()</p></li><li><p>关闭文件描述符，减少系统资源浪费<br> 由于子进程继承父进程的文件描述符，关闭他们</p></li><li><p>开始执行守护进程的核心工作<br> while()死循环处理</p></li><li><p>守护进程退出处理（非必要）<br> 释放必要的资源</p></li></ol><h4 id="守护进程代码模型"><a href="#守护进程代码模型" class="headerlink" title="守护进程代码模型"></a>守护进程代码模型</h4><p>通过以上模型介绍，我们可以代码实现Daemon守护进程的模型。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;/*Daemon 精灵 守护进程编程实现步骤*/void daemonize(void){    pid_t pid;    //1. 创建子进程，父进程退出    if((pid = fork()) &lt; 0){        perror(&quot;fork error!&quot;);        exit(1);    }    else if(pid !=0){        exit(0);    }    // 子进程，创建新会话，独立终端，父进程成为init    setsid();    // 更改当期那路径为根路径，或者其他路径，避免占用可卸载文件系统    if(chdir(&quot;/&quot;) &lt; 0){        perror(&quot;chdir error!&quot;);        exit(1);    }    // 设置umask，防止继承文件系统创建屏蔽字拒绝某些权限    umask(0);    // 关闭文件描述符，较少系统资源浪费    close(0);    open(&quot;/dev/null&quot;, O_RDWR);    dup2(0,1);    dup2(0,2);}int main(void){    daemonize();    while(1){        /* do something here!!!*/    }}</code></pre><p>运行这个程序，它变成一个守护进程，不再和当前终端关联。用ps命令看不到，必须运行带x参数的ps命令才能看到。</p><p>另外还可以看到，用户关闭终端窗口或注销也不会影响守护进程的运行。</p><h4 id="守护进程参考实例"><a href="#守护进程参考实例" class="headerlink" title="守护进程参考实例"></a>守护进程参考实例</h4><p>创建一个守护进程，定时的记录时间到文件 /tmp/daemon.log 中。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;  #include &lt;string.h&gt;#define FILEPATH &quot;/tmp/daemon.log&quot;#define NEWLINE &quot;\n&quot;/*Daemon 精灵 守护进程编程实现步骤*/void daemonize(void){    pid_t pid;    //1. 创建子进程，父进程退出    if((pid = fork()) &lt; 0){        perror(&quot;fork error!&quot;);        exit(1);    }else if(pid !=0){        exit(0);    }    // 子进程，创建新会话，独立终端，父进程成为init    setsid();    // 更改当期那路径为根路径，或者其他路径，避免占用可卸载文件系统    if(chdir(&quot;/&quot;) &lt; 0){        perror(&quot;chdir error!&quot;);        exit(1);    }    // 设置umask，防止继承文件系统创建屏蔽字拒绝某些权限    umask(0);    // 关闭文件描述符，较少系统资源浪费    close(0);    open(&quot;/dev/null&quot;, O_RDWR);    dup2(0,1);    dup2(0,2);}int testFile(){    return access(FILEPATH,F_OK);}int createFile(){    int fd;    if((fd = open(FILEPATH, O_CREAT, 0644)) &lt; 0){        perror(&quot;open file error!&quot;);        exit(1);    }    close(fd);    return 0;}int getTime(char *buf){    time_t t;    if(time(&amp;t) != -1)        return 0;    else         retrun -1;}int saveTime2file(char *buf){    int fd;    if((fd = open(FILEPATH,O_RDWR | O_APPEND)) &gt; 0){        // strcat(buf,NEWLINE);        write(fd,buf,strlen(buf));        close(fd);        printf(&quot;write time to file %s\n&quot;,buf);    }}int main(void){    char buf[1024] = {0};    // 文件不存在，创建    if(testFile() == -1){        createFile();    }    daemonize();    while(1){        /* do something here!!!*/        // 每10s记录一次        sleep(10);        if(getTime(buf)==0){            saveTime2file(buf);            memset(buf,0,1024);        }    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本博文主要介绍了Linux下进程组、会话以及守护进程方面的内容，对于守护进程，其有一套约定俗成的编程模版，不必死记，只需要了解起工作原理，脱离终端，孤儿进程，新会话，长期运行等特性，其特殊性也就决定了他和其他进程的不同。在以后用到的时候，回过头来看一下模版，即可迅速的实现Daemon守护进程的。</p><p><a href="https://blog.csdn.net/a511244213/article/details/79625801" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 守护进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之信号后记</title>
      <link href="/FuckCode/2019/01/10/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%90%8E%E8%AE%B0/"/>
      <url>/FuckCode/2019/01/10/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%90%8E%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>前面两章节基本将Linux系统下信号知识都介绍了一遍，这里对信号机制进行补充。虽然信号给我们编程带来了极大的方便，但是其原则还是异步操作，内核在调度进程上不可能像我们预期想象的那样运行，因此会额外带来其他问题，这里就进行统一的阐述。</strong><br><a id="more"></a></p><h3 id="信号引起的竞态"><a href="#信号引起的竞态" class="headerlink" title="信号引起的竞态"></a>信号引起的竞态</h3><h4 id="普通版sleep"><a href="#普通版sleep" class="headerlink" title="普通版sleep"></a>普通版sleep</h4><p>先来看一下信号机制中普通版本的sleep函数是如何实现的：</p><pre><code>#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;void sig_alrm(int i){}unsigned int mysleep(unsigned int nsecs){    struct sigaction newact, oldact;    unsigned int unslept;    // 注册捕捉函数    newact.sa_handler = sig_alrm;    newact.sa_flags = 0;    sigemptyset(&amp;newact.sa_mask);    // 注册阻塞捕捉信号 SIGALRM    sigaction(SIGALRM, &amp;newact, &amp;oldact);    // alarm定时开启    alarm(nsecs);    // 挂起等待，知道被唤醒    pause();    unslept = alarm(0);    // 恢复原来信号屏蔽字，否则 SIGALRM 信号一直被程序阻塞    sigaction(SIGALRM, &amp;oldact, NULL);    return unslept;}int main(void){    while(1){        mysleep(2);        printf(&quot;Two seconds passed\n&quot;);    }    return 0; }</code></pre><p>通过之前的捕捉函数处理流程可以得知，程序最大的缺点是：系统运行的时序并不像我们写程序时所设想的那样，虽然alarm紧接着下一步就是pause，但是无法保证pause一定会在调用alarm之后的指定秒之内被调用，因为捕捉函数的调用是由内核返回用户态监测时后调用的。因此这种情况下就导致了时序竞态的产生。</p><p>竞态条件： 由于异步事件在任何时候都有可能会发生（异步事件在这里指的是更高优先级的进程），如果我们写程序时考虑不周密，就可能由于时序问题而导致错误，这就是竞态条件。</p><h4 id="避免时序竞态sleep"><a href="#避免时序竞态sleep" class="headerlink" title="避免时序竞态sleep"></a>避免时序竞态sleep</h4><p>设想如何将解除信号屏蔽与挂起等待信号合并成一个原子操作就可以避免因时序问题导致的错误，因此引入sigsuspend函数。它不仅用于pause函数的挂起等待功能，而且解决了竞态条件产生的时序问题。</p><p>sugsuspeng 原理： 用于在接收到某个信号之前，临时用mask替换进程的信号掩码，并暂停进程执行，直到收到信号为止。调用sigsuspend后，进程就挂在那里，等待着开放的信号的唤醒。系统在接收到信号后，马上就把现在的信号集还原为原来的，然后调用处理函数。</p><pre><code>int sigsuspend(const sigset_t *mask);mask：指定进程的信号屏蔽字，可以临时解除对某一个信号的屏蔽，然后挂起等待。当suspend返回时，进程的信号屏蔽字恢复原先的值，如果原先对信号是屏蔽的，返回后仍然屏蔽。返回值：返回值与pause一致，永远返回-1，errno设置为EINTR。</code></pre><p>sigsuspend的整个原子操作过程为：</p><ol><li>设置新的mask阻塞当前进程；</li><li>挂起等待，收到信号，恢复原先mask；</li><li>调用该进程设置的信号处理函数；</li><li>待信号处理函数返回后，sigsuspend返回。</li></ol><p>使用sigsuspend解决时序竞态sleep函数代码</p><pre><code>#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;void sig_alrm(int i){}unsigned int mysleep(unsigned int nsecs){    struct sigaction newact, oldact;    sigset_t newmask, oldmask, suspmask;    unsigned int unslept;    newact.sa_handler = sig_alrm;    newact.sa_flags = 0;    sigemptyset(&amp;newact.sa_mask);    // 注册信号捕追    sigaction(SIGALRM, &amp;newact, &amp;oldact);    // 信号捕追时，启动信号屏蔽字    sigemptyset(&amp;newmask);    // 添加指定信号屏蔽字 SIGALRM    sigaddset(&amp;newmask,SIGALRM);    // 更改信号屏蔽字，已阻的方式开启定时    sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);    alarm(nsecs);    // 开始定时后，删除原有 mask 中 SIGALRM，只有 SIGALRM 才能通过    suspmask = oldmask;    sigdelset(&amp;suspmask,SIGALRM);    // 使用sigsuspend 替换 pause，使用新的 mask     // 此时信号屏蔽字更改临时的suspmask，非阻塞信号SIGALRM，挂起等待    // 一旦有信号SIGALRM立即唤醒，恢复原来信号屏蔽字oldmask（阻塞SIGALRM），便立即进入捕捉函数处理    sigsuspend(&amp;suspmask);    // 检查定时剩余时间    unslept = alarm(0);    sigaction(SIGALRM, &amp;oldact, NULL);    // 信号捕追完毕，恢复信号原有 mask    sigprocmask(SIG_SETMASK, &amp;oldmask, NULL);    return unslept;}int main(void){    while(1){        mysleep(2);        printf(&quot;Two seconds passed\n&quot;);    }    return 0; }</code></pre><p>以上通过函数 sigsuspend 避免了时序竞态引起的问题，其主要流程是：能够在信号 SIGALRM 到达时立即响应处理，通过实现不阻塞 SIGALRM 唤醒进程，然后恢复原来设置的信号屏蔽字后（阻塞捕捉 SIGALRM），直接进入信号捕捉函数，然后返回。</p><h3 id="可重入函数与不可重入函数"><a href="#可重入函数与不可重入函数" class="headerlink" title="可重入函数与不可重入函数"></a>可重入函数与不可重入函数</h3><p>函数是一段载入到内存的代码。函数的代码可长可短，执行时间长度也不确定。在多线程中，线程之间是可以进行切换的。函数是一段写好的代码，属于程序公有的代码段。一个进程中有多个线程，每一个线程都可以调用这段函数代码执行。而在多线程环境中，线程的切换是无法预料的，你不知道下一秒是哪个线程在执行，每时每刻的运行环境都不一样，因为线程切换也是变化莫测的。这是操作系统调度进程线程的范围，不是我们能够掌控的。</p><p>信号作为一种软中断，能够被进程给捕获，因而也就中断进程的正常执行，转而去执行信号处理程序，最后再返回到原进程继续正常执行。因此就会涉及到可重入函数问题了。</p><h4 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h4><p>一个函数在执行的过程中被打断，然后会再被再重头执行一次，执行完后，再回来把刚才没执行完的部分执行完。这就相当于嵌套的执行了。函数是公共代码，这样的执行是允许的。函数的执行可以被打断，打断之后还可以再重头执行，执行完后接着执行刚才没有执行的代码，然后第一次执行的代码（被打断的函数）执行结果还是正确的。也就是说，这个函数执行，无论中间把这个函数再嵌入执行多少遍，怎么嵌入，最终执行完，执行的结果都是正确的，这样的函数就是可重入函数。</p><p>常用的可重入函数的方法有：</p><ol><li>不要使用全局变量，防止别的代码覆盖这些变量的值。</li><li>调用这类函数之前先关掉中断，调用完之后马上打开中断。防止函数执行期间被中断进入别的任务执行。</li><li>使用信号量（互斥条件）。</li></ol><p>总而言之：要保证中断是安全的。<br>使用 man 7 signal 查看</p><h4 id="不可重入函数"><a href="#不可重入函数" class="headerlink" title="不可重入函数"></a>不可重入函数</h4><p>在函数执行期间被中断，从头执行这个函数，执行完毕后再返回刚才的中断点继续执行，此时由于刚才的中断导致了现在从新在中断点执行时发生了不可预料的错误。那么这类函数就是不可重入函数。</p><p>常见的不可重入函数：</p><ol><li>使用了静态数据结构</li><li>调用了malloc和free等</li><li>调用了标准I/O函数</li><li>进行了浮点运算</li></ol><h4 id="如何避免写出不可重入函数"><a href="#如何避免写出不可重入函数" class="headerlink" title="如何避免写出不可重入函数"></a>如何避免写出不可重入函数</h4><ol><li>不使用或者互斥使用全局变量</li><li>不使用静态局部变量，只是用局部变量，</li><li>在函数中动态分配的内存只在本函数中使用，不会传递函数外使用，</li></ol><p>只要保证局部特性，函数中使用的所有东西都只有局部性，对外不公开，用完即释放，就可以保证可重入。这样，不管怎么重叠，反正本层的函数的东西只有本层能够使用，其他层的函数无法使用。</p><h4 id="信号中的可重入函数"><a href="#信号中的可重入函数" class="headerlink" title="信号中的可重入函数"></a>信号中的可重入函数</h4><p>信号捕捉函数内部，禁止调用不可重入函数。</p><p>strtok就是一个不可重入函数，因为strtok内部维护了一个内部静态指针，保存上一次切割到的位置，如果信号的捕捉函数中也去调用strtok函数，则会造成切割字符串混乱， 应用strtok_r版本，r表示可重入。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过三篇信号博文，信号的部分就告一段落了。从信号的基础认识，到信号相关函数的介绍，以及后续对信号机制带来的其他问题等方面，系统的阐述了Linux下信号的内容，相信读完三篇内容的你，应该会对信号有更深层次的了解。</p><p>我们知道信号机制可以在多进程中进行通信，当然在多线程中使用也是可以的。但是这对开发者来说并非好事，使用时必须要严格控制管理，否则会造成不可预估的后果。</p><p><a href="https://blog.csdn.net/liuchenxia8/article/details/79961851" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之信号进阶</title>
      <link href="/FuckCode/2019/01/08/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BF%A1%E5%8F%B7%E8%BF%9B%E9%98%B6/"/>
      <url>/FuckCode/2019/01/08/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BF%A1%E5%8F%B7%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>本章节继续介绍关于Linux系统下信号相关的知识点，介于之前介绍了信号的基础，了解了信号的产生、缘由以及工作流程，这里就对信号的相关函数进行统一的分析，之后在用实例进行说明。</strong></p><a id="more"></a><h3 id="信号产生函数"><a href="#信号产生函数" class="headerlink" title="信号产生函数"></a>信号产生函数</h3><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>kill 函数可以给一个特定的进程发送指定的信号</p><pre><code>#include &lt;signal.h&gt;int kill(pid_t pid, int sig) pid &gt; 0     sig发送给ID为pid的进程 pid == 0    sig发送给与发送进程同组的所有进程 pid &lt; 0     sig发送给组ID为|-pid|的进程，并且发送进程具有向其发送信号的权限 pid == -1   sig发送给发送进程有权限向他们发送信号的系统上的所有进程 sig为发送的信号值，当sig为0时，用于检测特定为pid进程是否存在，如不存在，返回-1。</code></pre><h4 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h4><p>raise函数可以给当前进程发送指定的信号（自己也可以给自己发送信号）</p><pre><code>#include &lt;signal.h&gt;int raise(int sig);</code></pre><h4 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h4><p>abort函数通过向当前进程发送信号值 SIGABRT，使当前进程接收到信号而异常终止，但是abort会认为进程不安全。</p><pre><code>#include &lt;stdlib.h&gt; void abort(void);</code></pre><p>类似于exit函数一样，abort函数总是成功的，因此没有返回值。</p><h4 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h4><p>由软件条件产生信号，进程可以通过调用alarm向它自己发送SIGALRM信号</p><pre><code>#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds);参数seconds：alarm函数安排内核在seconds秒内发送一个SIGALRM信号给调用进程，如果soconds等于0，那么不会调度新的闹钟（alarm）返回值：前一次闹钟剩余的秒数，若以前没有设定闹钟，则为0</code></pre><p>在使用时，alarm只设定为发送一次信号，如果要多次发送，就要多次使用alarm调用。</p><h4 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer"></a>setitimer</h4><p>现在的系统中很多程序不再使用alarm调用，而是使用setitimer调用来设置定时器，用getitimer来得到定时器的状态，这两个调用的声明格式如下：</p><pre><code>#include &lt;sys/time.h&gt;int getitimer(int which, struct itimerval *value);int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue);</code></pre><p>该系统调用给进程提供了三个定时器，它们各自有其独有的计时域，当其中任何一个到达，就发送一个相应的信号给进程，并使得计时器重新开始。三个计时器由参数which指定，如下所示：</p><pre><code>ITIMER_REAL：按实际时间计时，计时到达将给进程发送SIGALRM信号。ITIMER_VIRTUAL：仅当进程执行时才进行计时。计时到达将发送SIGVTALRM信号给进程。ITIMER_PROF：当进程执行时和系统为该进程执行动作时都计时。与ITIMER_VIRTUAL是一对，该定时器经常用来统计进程在用户态和内核态花费的时间。计时到达将发送SIGPROF信号给进程。</code></pre><p>定时器中的参数value用来指明定时器的时间，其结构如下：</p><pre><code>struct itimerval {        struct timeval it_interval; /* 下一次的取值 */        struct timeval it_value; /* 本次的设定值 */};</code></pre><p>该结构中timeval结构定义如下：</p><pre><code>struct timeval {        long tv_sec; /* 秒 */        long tv_usec; /* 微秒，1秒 = 1000000 微秒*/};</code></pre><p>在setitimer 调用中，参数ovalue如果不为空，则其中保留的是上次调用设定的值。定时器将it_value递减到0时，产生一个信号，并将it_value的值设定为it_interval的值，然后重新开始计时，如此往复。当it_value设定为0时，计时器停止，或者当它计时到期，而it_interval 为0时停止。调用成功时，返回0；错误时，返回-1，并设置相应的错误代码errno：</p><pre><code>EFAULT：参数value或ovalue是无效的指针。EINVAL：参数which不是ITIMER_REAL、ITIMER_VIRT或ITIMER_PROF中的一个。</code></pre><p>下面是关于setitimer调用的一个简单示范，在该例子中，每隔一秒发出一个SIGALRM，每隔0.5秒发出一个SIGVTALRM信号：</p><pre><code>#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;int sec;void sigroutine(int signo) {    switch (signo) {        case SIGALRM:            printf(&quot;Catch a signal -- SIGALRM\n&quot;);            break;        case SIGVTALRM:            printf(&quot;Catch a signal -- SIGVTALRM\n&quot;);            break;    }    return;}int main(){    struct itimerval value,ovalue,value2;    sec = 5;    printf(&quot;process id is %d\n&quot;,getpid());    signal(SIGALRM, sigroutine);    signal(SIGVTALRM, sigroutine);    value.it_value.tv_sec = 1;    value.it_value.tv_usec = 0;    value.it_interval.tv_sec = 1;    value.it_interval.tv_usec = 0;    setitimer(ITIMER_REAL, &amp;value, &amp;ovalue);    value2.it_value.tv_sec = 0;    value2.it_value.tv_usec = 500000;    value2.it_interval.tv_sec = 0;    value2.it_interval.tv_usec = 500000;    setitimer(ITIMER_VIRTUAL, &amp;value2, &amp;ovalue);    for (;;) ;}</code></pre><p>程序运行结果如下：</p><pre><code>$ ./app process id is 104501 Catch a signal -- SIGVTALRMCatch a signal -- SIGALRMCatch a signal -- SIGVTALRMCatch a signal -- SIGVTALRMCatch a signal -- SIGALRMCatch a signal -- SIGVTALRMCatch a signal -- SIGVTALRM...</code></pre><h4 id="sigqueue"><a href="#sigqueue" class="headerlink" title="sigqueue"></a>sigqueue</h4><p>sigqueue是比较新的发送信号系统调用，主要是针对实时信号提出的（当然也支持前32种），支持信号带有参数，与函数sigaction配合使用，后续详细介绍。</p><h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><p>信号集被定义为一种数据类型：</p><pre><code>typedef struct {    unsigned long sig[_NSIG_WORDS]；} sigset_t</code></pre><p>信号集用来描述信号的集合，每个信号占用一位。Linux所支持的所有信号可以全部或部分的出现在信号集中，主要与信号阻塞相关函数配合使用。</p><h4 id="sigset-t-信号集"><a href="#sigset-t-信号集" class="headerlink" title="sigset_t 信号集"></a>sigset_t 信号集</h4><p>下面是为信号集 sigset_t 操作定义的相关函数：</p><pre><code>int sigemptyset(sigset_t *set)  初始化由set指定的信号集，信号集里面的所有信号被清空；int sigfillset(sigset_t *set)   调用该函数后，set指向的信号集中将包含linux支持的64种信号；int sigaddset(sigset_t *set, int signo) 在set指向的信号集中加入signum信号；int sigdelset(sigset_t *set, int signo) 在set指向的信号集中删除signum信号；int sigismember(const sigset_t *set, int signo) 判定信号signum是否在set指向的信号集中。 </code></pre><h4 id="信号集模型"><a href="#信号集模型" class="headerlink" title="信号集模型"></a>信号集模型</h4><p>如果在进程解除对某信号的阻塞之前这种信号产生过多次，将如何处理?POSIX.1允许系统递送该信号一次或多次。Linux是这样实现的:常规信号在递达之前产生多次只计一次，而实时信号在递达之前产生多次可以依次放在一个队列里。本章不讨论实时信号。每个信号只有一个bit的未决标志，非0即1，不记录该信号产生了多少次，阻塞标志也是这样表示的。因此，未决和阻塞标志可以用相同的数据类型 sigset_t 来存储，sigset_t 称为信号集，这个类型可以表示每个信号的“有效”或“无效”状态， 在阻塞信号集中“有效”和“无效”的含义是该信号是否被阻塞，而在未决信号集中“有效”和“无效”的含义是该信号是否处于未决状态。</p><p>阻塞信号集也叫做当前进程的信号屏蔽字(Signal Mask)，这里的“屏蔽”应该理解 为阻塞而不是忽略。下图展示了PCB中信号集模型：</p><img src="/FuckCode/2019/01/08/Linux系统编程之信号进阶/pcb信号集模型.png" class="pcb信号集模型"><ol><li>PCB进程控制块中有信号屏蔽状态字(block)，信号未决状态字(pending)还有是否忽略标识</li><li>信号屏蔽状态字(block)：1代表阻塞，0代表不阻塞；信号未决状态字(pending)：1代表未决，0代表信号递达</li><li>向进程发送SIGINT，内核首先判断信号屏蔽状态字是否阻塞，如果信号屏蔽状态字阻塞，信号未决状态字(pengding)相应位置1；<br>若阻塞解除，信号未决状态字(pending)相应位置0，表示信号可以递达了。</li><li>block状态字，pending状态都是64bit，分别代表Linux系统中的64个信号。例如SIGINT是2号信号，对应block状态字中的第二位</li><li>block状态字用户可以读写，pending状态字用户只能读，这是新号的设计机制。</li></ol><p>内核将信号传递到PEND集合中，置位相应的未决态1，之后，经过用户设置过的阻塞信号集屏蔽字处理，如果信号被阻塞，那么未决集内对应位还是1，如果没有阻塞，信号成为递达，经过handler处理，默认、忽略以及捕捉，此时未决集中对应的标志位转为0.</p><h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><p>在信号集中，用户可通过sigprocmask设置阻塞信号集，通过sigpending获取未决态信号集</p><h4 id="sigprocmask"><a href="#sigprocmask" class="headerlink" title="sigprocmask"></a>sigprocmask</h4><p>调用函数sigprocmask可以读取或更改进程的信号屏蔽字。</p><pre><code>#include &lt;signal.h&gt;int sigprocmask(int how,const sigset_t *set,sigset * oset);成功返回0，出错返回-1</code></pre><p>如果oset是非空指针，则读取进程的当前信号屏蔽状态字通过oset参数传出，如果set是非空指针，则更改进程的信号屏蔽状态字，参数how控制如何更改。</p><p>如果oset和set都是非空指针，则先将原来的信号屏蔽字备份到oset里，然后根据set和how参数更改信号屏蔽字。</p><p>参数 how 的含义</p><pre><code>--SIG_BLOCK    set包含了我们希望添加到当前信号屏蔽字的信号，相当于mask=mask|set(位或运算)--SIG_UNBLOCK    set包含了我们希望从当前信号屏蔽字中解除阻塞的信号，相当于mask=mask^set(位异或运算)--SIG_SETMASK    设置当前信号屏蔽字为set所指向的值，相当于mask=set</code></pre><p>如果调用sigprocmask解除了对当前若干个未决信号的阻塞，则在sigprocmask返回前， 至少将其中一个信号递达。</p><h4 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending"></a>sigpending</h4><p>sigpending函数用来读取当前进程的信号未决集，通过set参数传出。</p><pre><code>#include &lt;signal.h&gt;int sigpending(sigset_t *set);成功返回0，出错返回-1。</code></pre><p>sigpending读取当前进程的未决信号集，通过set参数传出，调用成功返回0，失败返回-1。</p><h4 id="信号集代码示例"><a href="#信号集代码示例" class="headerlink" title="信号集代码示例"></a>信号集代码示例</h4><pre><code>#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void printsigset(const sigset_t *set){    int i;    for(i =1; i&lt;32;i++)    {        if(sigismember(set, i)==1)            putchar(&apos;1&apos;);        else            putchar(&apos;0&apos;);    }    puts(&quot;&quot;);}int main(void){    sigset_t s,p;    int i = 0;    //  清空信号集    sigemptyset(&amp;s);    // 捕捉信号屏蔽字    sigaddset(&amp;s, SIGINT); // ctrl + c    sigaddset(&amp;s, SIGQUIT); // ctrl + z    sigaddset(&amp;s, SIGTSTP); // ctrl + \    // 补充设置部分信号屏蔽字    sigprocmask(SIG_BLOCK, &amp;s, NULL);    while(1)    {        // 获取未决信号集        sigpending(&amp;p);        printsigset(&amp;p);        if (i==10)        {            // 解除信号屏蔽字 SIGQUIT            sigdelset(&amp;s, SIGQUIT);            sigprocmask(SIG_UNBLOCK, &amp;s, NULL);        }        sleep(1);        i++;    }    return 0;}</code></pre><p>注意，SIGKUILL 和 SIGSTOP 两个信号屏蔽字 无法捕捉、阻塞以及忽略。<br><br>程序执行结果：</p><pre><code>Allies:signal rememberme$ ./sigprocmask  0000000000000000000000000000000^Z0000000000000000010000000000000  0000000000000000010000000000000^C0100000000000000010000000000000^\0110000000000000010000000000000  0110000000000000010000000000000  ...</code></pre><h3 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h3><h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h4><p>注册信号捕捉函数sigaction，POSIX标准定义了sigaction函数，它允许像Linux和Solaris这样与POSIX兼容的系统上的用户，明确地指出它们想要的信号处理语义。</p><p>sigaction函数可以读取或者指定信号相关联的处理动作，signal与其功能类似，但signal是标准C的信号接口，对不同的操作系统有不同的行为，所以一般尽量不使用signal，取而代之的是sigaction函数。函数原型如下：</p><pre><code>#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);signum： 指定信号的编号（利用kill -l命令可以查看）；*act： 若act指针非空，则根据act修改该信号的处理动作；*oldact： 若oldact指针非空，则通过oldact传出该信号原来的处理动作；返回值：成功返回0，失败返回-1；</code></pre><p>对于其中的结构体 struct sigaction 的定义如下: </p><pre><code>struct sigaction {    void void sigset_t int    void    (*sa_handler)(int);    (*sa_sigaction)(int, siginfo_t *, void *);    sa_mask;    sa_flags; (*sa_restorer)(void);};sa_handler : 早期的捕捉函数，SIG_DEF（默认）,SIG_IGN（忽略）,自定义函数指针sa_sigaction : 新添加的捕捉函数，可以传参 , 和sa_handler互斥，两者通过sa_flags选择采用哪种捕捉函数 sa_mask : 在执行捕捉函数时，设置阻塞其它信号，sa_mask | 进程阻塞信号集，退出捕捉函数后，还原回原有的 阻塞信号集sa_flags : SA_SIGINFO 或者 0sa_restorer : 保留，已过时</code></pre><h4 id="捕捉代码示例"><a href="#捕捉代码示例" class="headerlink" title="捕捉代码示例"></a>捕捉代码示例</h4><pre><code>#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;// 捕捉函数处理，接受捕捉的信号值void sigHandler(int signum){    printf(&quot;\nsigHandler: %d\n&quot;,signum);}int main(void){    // 声明结构体 sigaction    struct  sigaction sa;    // 使用 sa_handler 函数指针捕捉处理，参数 0    sa.sa_flags = 0;    // 设置函数指针指向函数体    sa.sa_handler = sigHandler;    // sa.sa_handler = SIG_DFL;    // sa.sa_handler = SIG_IGN;    // 清空函数捕捉时的 mask 值    sigemptyset(&amp;sa.sa_mask);    // 注册捕捉函数    sigaction(SIGINT, &amp;sa, NULL);    while(1){        printf(&quot;......\n&quot;);        sleep(1);    }    return 0;}</code></pre><p>程序运行结果：</p><pre><code>Allies:signal rememberme$ ./sigaction..................^CsigHandler: 2............^CsigHandler: 2............</code></pre><p> 注意:子进程继承了父进程的信号屏蔽字和信号处理动作。</p><p>库函数 signal 原型如下：</p><pre><code>typedef void (*sighandler_t)(int)sighandler_t signal(int signum, sighandler_t handler)int system(const char *command) 集合fork，exec，wait一体</code></pre><h4 id="信号捕捉传参"><a href="#信号捕捉传参" class="headerlink" title="信号捕捉传参"></a>信号捕捉传参</h4><p>通常的sigaction结构体中 sa.sa_flags 设置为 时，信号捕捉只能够得到捕捉的信号值，然而向进程本身发送信号，并传递指针参数则需要修改标志位 sa.sa_flags 为 SA_SIGINFO。发送信号时候就用之前提到的函数 sigqueue 添加而外信息。先来回顾一下信号捕捉流程</p><img src="/FuckCode/2019/01/08/Linux系统编程之信号进阶/信号捕捉.png" class="信号捕捉流程"><h5 id="sigqueue-函数原型"><a href="#sigqueue-函数原型" class="headerlink" title="sigqueue 函数原型"></a>sigqueue 函数原型</h5><p>sigqueue 功能和 kill 相同，都可以向制定进程发送信号，其次还可以额外夹杂数据。</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;int sigqueue(pid_t pid, int sig, const union sigval val)调用成功返回 0；否则，返回 -1。</code></pre><p>sigqueue 是比较新的发送信号系统调用，主要是针对实时信号提出的（当然也支持前32种），支持信号带有参数，与函数sigaction()配合使用。</p><p>sigqueue的第一个参数是指定接收信号的进程ID，第二个参数确定即将发送的信号，第三个参数是一个联合数据结构union sigval，指定了信号传递的参数，即通常所说的4字节值。</p><pre><code>typedef union sigval {    int  sival_int;    void *sival_ptr;}sigval_t;</code></pre><p>sigqueue 比kill 传递了更多的附加信息，但 sigqueue 只能向一个进程发送信号，而不能发送信号给一个进程组。如果signo=0，将会执行错误检查，但实际上不发送任何信号，0值信号可用于检查pid的有效性以及当前进程是否有权限向目标进程发送信号。</p><p>在调用 sigqueue 时，sigval_t 指定的信息会拷贝到对应 sig 注册的3参数信号处理函数的 siginfo_t 结构中，这样信号处理函数就可以处理这些信息了。由于 sigqueue 系统调用支持发送带参数信号，所以比 kill 系统调用的功能要灵活和强大得多。</p><pre><code>#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;void new_op(int,siginfo_t*,void*);int main(int argc,char**argv){    struct sigaction act;      union sigval mysigval;    int i;    int sig;    pid_t pid;             char data[10];    memset(data,0,sizeof(data));    for(i=0;i &lt; 5;i++)            data[i]=&apos;2&apos;;    mysigval.sival_ptr=data;    sig=atoi(argv[1]);    pid=getpid();    sigemptyset(&amp;act.sa_mask);    act.sa_sigaction=new_op;//三参数信号处理函数    act.sa_flags=SA_SIGINFO;//信息传递开关，允许传说参数信息给new_op    if(sigaction(sig,&amp;act,NULL) &lt; 0)    {            printf(&quot;install sigal error\n&quot;);    }    while(1)    {            sleep(2);            printf(&quot;wait for the signal\n&quot;);            sigqueue(pid,sig,mysigval);//向本进程发送信号，并传递附加信息    }}void new_op(int signum,siginfo_t *info,void *myact)//三参数信号处理函数的实现{    int i;    for(i=0;i&lt;10;i++)    {            printf(&quot;%c\n &quot;,(*( (char*)((*info).si_ptr)+i)));    }    printf(&quot;handle signal %d over;&quot;,signum);}</code></pre><p>程序运行结果</p><pre><code>$ ./sigqueue 7wait for the signalSSSSShandle signal 7 over;wait for the signalSSSSShandle signal 7 over;wait for the signalSS...</code></pre><p>sigqueue 也可以夸进程通信，但是其传递的数据一半以整型等具体的基本数据。不同进程间收发信号，不在同一地址空间,不适合传地址。</p><h3 id="SIGCHLD-信号处理"><a href="#SIGCHLD-信号处理" class="headerlink" title="SIGCHLD 信号处理"></a>SIGCHLD 信号处理</h3><h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><p>SIGCHLD的产生条件有一下三点：</p><ol><li>子进程终止时 </li><li>子进程接收到SIGSTOP信号停止时 </li><li>子进程处在停止态，接受到SIGCONT后唤醒时</li></ol><h4 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h4><p>父进程回收子进程时，对status的处理方式</p><pre><code>pid_t waitpid(pid_t pid, int *status, int options) options    1. WNOHANG 没有子进程结束，立即返回    2. WUNTRACED   如果子进程由于被停止产生的SIGCHLD， waitpid则立即返回    3. WCONTINUED  如果子进程由于被SIGCONT唤醒而产生的SIGCHLD， waitpid则立即返回获取status     1. WIFEXITED(status) 子进程正常exit终止，返回真 WEXITSTATUS(status)返回子进程正常退出值    2. WIFSIGNALED(status) 子进程被信号终止，返回真    3. WTERMSIG(status)    返回终止子进程的信号值     4. WIFSTOPPED(status)  子进程被停止，返回真 WSTOPSIG(status)返回停止子进程的信号值    5. WIFCONTINUED(status)    子进程由停止态转为就绪态，返回真</code></pre><h4 id="SIGCHLD-代码示例"><a href="#SIGCHLD-代码示例" class="headerlink" title="SIGCHLD 代码示例"></a>SIGCHLD 代码示例</h4><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;void do_sig(int n){    int status;    pid_t pid;    // 收到子进程发送的 SIGCHILD 信号，捕捉函数至此    while((pid = waitpid(0,&amp;status,WNOHANG)) &gt; 0){        // 子进程正常退出        if(WIFEXITED(status))            // 打印出正常退出值            printf(&quot;child %d exit %d\n&quot;,pid,WEXITSTATUS(status));        // 子进程被信号终止退出        else if(WIFSIGNALED(status))            // 打印终止子进程的信号值            printf(&quot;child %d received signal %d\n&quot;,pid,WTERMSIG(status));    }}int main(void){    pid_t pid;    int i;    // 父子进程均设置 SIGCHLD 信号屏蔽字，方便捕捉    sigset_t newmask,oldmask;    sigemptyset(&amp;newmask);    sigaddset(&amp;newmask,SIGCHLD);    // 修改信号屏蔽字    sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask);    // fork子进程5个，全部捕捉 SIGCHLD 信号值    for (i = 0; i &lt; 5; i++)    {        if((pid = fork() )== 0){            break;        }        else if(pid &lt; 0){            perror(&quot;fork error!&quot;);            exit(1);        }    }    // 子进程 10 次循环打印， 10s 后结束    if(pid == 0){        int n = 10;        while(n--){            printf(&quot;child ID %d\n&quot;, getpid());            sleep(1);        }        return i;    } else if(pid &gt; 0){        // 父进程添加捕追函数        struct sigaction act;        act.sa_handler = do_sig;        act.sa_flags = 0;        sigemptyset(&amp;act.sa_mask);        // 注册信号捕捉函数        sigaction(SIGCHLD,&amp;act, NULL);        // 恢复初始信号屏蔽字的状态        sigprocmask(SIG_SETMASK,&amp;oldmask,NULL);        while(1){            printf(&quot;Parent ID %d\n&quot;,getpid());            sleep(5);        }    }    return 0;}</code></pre><p>程序运行结果：</p><pre><code>...child ID 1421child ID 1422child ID 1423child ID 1420Parent ID 1418child ID 1421child ID 1422child ID 1419child 1423 exit 4child 1422 exit 3child 1421 exit 2child 1420 exit 1child 1419 exit 0Parent ID 1418...</code></pre><p>此时通过 kill -9 ？ 向指定的子进程（？）发信号杀死子进程，那么打印log便会将指定的子进程退出信号值打印出来（9）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章节继前面章节，系统从函数方面阐述了信号的发送，拦截以及捕捉。对于父子进程而言，信号屏蔽字，信号集等在父子进程中都会的到继承，因此再处理父子进程间信号时，需要优先设置相应的信号屏蔽字后，再fork子进程，然后在父进程中进行监听。</p><p><a href="https://blog.csdn.net/ypt523/article/details/80365108" target="_blank" rel="noopener">参考链接1</a><br><a href="https://www.cnblogs.com/subo_peng/p/5325326.html" target="_blank" rel="noopener">参考链接2</a></p><blockquote><p>邢文鹏Linux系统教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之信号基础</title>
      <link href="/FuckCode/2019/01/08/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%9F%BA%E7%A1%80/"/>
      <url>/FuckCode/2019/01/08/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><strong>Linux下信号涉及知识点非常多，本章节先做一个铺垫，简单介绍一下信号种类及其含义，信号的几种默认处理方式等，后续再来介绍具体的信号处理函数以及注意事项也就方便很多了。工欲善其事，必先利其器。Let us get it！</strong><br><a id="more"></a></p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号，通俗来讲就是给予一种提示，告知一方发生了啥。Linux下的信号指的是操作系统给进程发送信号，告知进程在合适的时间内去处理所接受的信号。其本质给发送信号的进程内的PCB中写入数据，修改相应的PCB字段，内核在返回处理时候得知信号记录再予以操作。</p><p>如下模拟场景：</p><ol><li><p>用户输入一个命令，在shell下启动一个前台进程；</p></li><li><p>用户按下Ctrl+c，通过键盘输入产生一个硬件中断；</p></li><li><p>如果CPU当前正在运行此进程的代码，则该进程的用户空间的代码将暂停执行，CPU从用户态切换至内核态处理中断；</p></li><li><p>终端驱动程序将Ctrl+c解释为一个SIGINT信号，记在该进程的PCB中；</p></li><li><p>当某个时刻从内核返回至该进程的用户空间代码继续执行之前，首先处理PCB中记录的信号；SIGINT信号的默认处理动作为终止信号，所以直接终止进程而不再返回到它的用户空间代码；</p></li></ol><p><a href="https://blog.csdn.net/ypt523/article/details/80290208" target="_blank" rel="noopener">示例参考</a></p><h4 id="信号种类"><a href="#信号种类" class="headerlink" title="信号种类"></a>信号种类</h4><p>信号可以按照可靠性和时间关系划分，如下表：</p><table><thead><tr><th style="text-align:center">划分</th><th style="text-align:center">Item1</th><th style="text-align:center">Item2</th></tr></thead><tbody><tr><td style="text-align:center">可靠性</td><td style="text-align:center">可靠信号</td><td style="text-align:center">不可靠信号</td></tr><tr><td style="text-align:center">时间关系</td><td style="text-align:center">普通信号</td><td style="text-align:center">实时信号</td></tr></tbody></table><h5 id="可靠信号"><a href="#可靠信号" class="headerlink" title="可靠信号"></a>可靠信号</h5><p>信号值位于SIGRTMIN和SIGRTMAX之间的信号都是可靠信号，信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。</p><h5 id="实时信号"><a href="#实时信号" class="headerlink" title="实时信号"></a>实时信号</h5><p>通过命令查看信号种类</p><pre><code>kill -l1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR213) SIGPIPE     14) SIGALRM     15) SIGTERM     17) SIGCHLD18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO30) SIGPWR      31) SIGSYS      33) SIGRTMIN    34) SIGRTMIN+135) SIGRTMIN+2  36) SIGRTMIN+3  37) SIGRTMIN+4  38) SIGRTMIN+539) SIGRTMIN+6  40) SIGRTMIN+7  41) SIGRTMIN+8  42) SIGRTMIN+943) SIGRTMIN+10 44) SIGRTMIN+11 45) SIGRTMIN+12 46) SIGRTMIN+1347) SIGRTMIN+14 48) SIGRTMIN+15 49) SIGRTMAX-14 50) SIGRTMAX-1351) SIGRTMAX-12 52) SIGRTMAX-11 53) SIGRTMAX-10 54) SIGRTMAX-955) SIGRTMAX-8  56) SIGRTMAX-7  57) SIGRTMAX-6  58) SIGRTMAX-559) SIGRTMAX-4  60) SIGRTMAX-3  61) SIGRTMAX-2  62) SIGRTMAX-163) SIGRTMAX </code></pre><p>前32种信号已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作，为普通信号。后32个信号表示实时信号，等同于前面阐述的可靠信号。这保证了发送的多个实时信号都被接收。</p><p>非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。</p><h4 id="信号产生"><a href="#信号产生" class="headerlink" title="信号产生"></a>信号产生</h4><h5 id="产生来源"><a href="#产生来源" class="headerlink" title="产生来源"></a>产生来源</h5><p>信号事件的发生有两个来源：</p><ol><li><p>终端特殊按键</p><pre><code>ctl+c SIGINT    暂停ctl+z SIGTSTP   停止ctl+\ SIGQUIT   退出</code></pre></li><li><p>软件来源,包括发送信号相关函数和硬件异常产生信号</p><pre><code>函数：killraisealarmsetitimersigqueue硬件异常除0操作 SIGFPE访问非法内存    SIGSEGV</code></pre></li></ol><h5 id="信号产生缘由"><a href="#信号产生缘由" class="headerlink" title="信号产生缘由"></a>信号产生缘由</h5><p>以下罗列了各种信号产生的缘由</p><ol><li>SIGHUP:当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程 </li><li>SIGINT:当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止里程。</li><li>SIGQUIT:当用户按下&lt;ctrl+>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。</li><li>SIGILL:CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件 </li><li>SIGTRAP:该信号由断点指令或其他trap指令产生。默认动作为终止里程并产生core文件。</li><li>SIGABRT:调用abort函数时产生该信号。默认动作为终止进程并产生core文件。 </li><li>SIGBUS:非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。 8. SIGFPE:在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。 </li><li>SIGKILL:无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。</li><li>SIGUSE1:用户定义的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。 </li><li>SIGSEGV:指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。 </li><li>SIGUSR2:这是另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</li><li>SIGPIPE:Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。</li><li>SIGALRM:定时器超时，超时的时间由系统调用alarm设置。默认动作为终止进程。 </li><li>SIGTERM:程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行 shell命令Kill时，缺省产生这个信号。默认动作为终止进程。 </li><li>SIGCHLD:子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。 </li><li>SIGCONT:停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为终止进程。 </li><li>SIGTTIN:后台进程读终端控制台。默认动作为暂停进程。 </li><li>SIGTSTP:停止进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。 </li><li>SIGTTOU:该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。 </li><li>SIGURG:套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。</li><li>SIGXFSZ:进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程。默认动作为终止进程。</li><li>SIGXFSZ:超过文件的最大长度设置。默认动作为终止进程。 </li><li>SIGVTALRM:虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。 </li><li>SGIPROF:类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。</li><li>SIGWINCH:窗口变化大小时发出。默认动作为忽略该信号。 </li><li>SIGIO:此信号向进程指示发出了一个异步IO事件。默认动作为忽略。 </li><li>SIGPWR:关机。默认动作为终止进程。 </li><li>SIGSYS:无效的系统调用。默认动作为终止进程并产生core文件。 </li><li>SIGRTMIN~(64)SIGRTMAX:LINUX的实时信号，它们没有固定的含义(可以由用户自定义)。所有的实时信号的默认动作都为终止进程。</li></ol><h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><h5 id="信号处理行为"><a href="#信号处理行为" class="headerlink" title="信号处理行为"></a>信号处理行为</h5><p>进程处理信号的行为分为以下几种方式：</p><ol><li><p>SIG_DFL  忽略信号</p></li><li><p>默认操作；由内核预定义的默认操作取决于信号的类型，可以是以下类型之一：</p><p> Treminate：进程被终止（杀死）</p><p> Dump：进程被终止（杀死），如果可能，创建包含进程执行上下文的核心转储文件</p><p> Ignore：信号被忽略</p><p> Stop：进程被停止，即把进程置为TASK_STOPPED状态</p><p> Continue：如果进程被停止，就把它设置为TASK_RUNNING状态</p></li><li><p>通过调用相应的信号处理函数捕捉信号（自定义信号捕捉）</p></li></ol><h5 id="信号处理流程"><a href="#信号处理流程" class="headerlink" title="信号处理流程"></a>信号处理流程</h5><p>信号的处理动作是用户自定义的函数，在信号递达时就调用这个函数，这称为信号捕捉。由于信号处理函数的代码是在用户空间执行的，处理过程较为复杂，我们画图来进行解释：</p><img src="/FuckCode/2019/01/08/Linux系统编程之信号基础/信号捕捉.png" class="信号捕捉"><p>上图很好的说明了信号捕捉时用户态和内核态的切换（用户处理信号最好的时机是程序从内核态切换至用户态的时候），下面就上图的一系列操作作以解释说明：</p><ol><li>用户程序注册了SIGQUIT信号的处理函数sighandler（自定义信号处理函数）。</li><li>当前正在执行main函数，这里发生中断、异常或者系统调用切换至内核态。</li><li>在内核中断处理完毕后要返回用户态的main函数之前，检查进程中有信号SIGQUIT递达。</li><li>内核决定返回用户态后不是恢复main函数的上下文信息继续执行，而是执行sighandler函数，sighandler函数和main函数使用不同的堆栈空间，两者之间不存在调用和被调用的关系，属于两个独立的控制流程。</li><li>sighandler函数返回后自动执行特殊的系统调用，调用4的sigreturn再次进入内核态。</li><li>内核中如果没有新的信号要递达，再返回用户态就是恢复main函数的上下文继续向下执行。</li></ol><p><a href="https://blog.csdn.net/ypt523/article/details/80365108" target="_blank" rel="noopener">参考链接</a></p><p>从上面可以看出，对于信号捕捉函数的调用时机是异步的，简而言之，就是进程收到信号了不一定马上执行，只有调度的进程处于内核状态中，在即将返回用户空间时候，才会监测进程中PCB对应的信号区域是否有待处理信号存在，如果存在，先返回到信号处理函数，处理完成返回内核再次检测，之后才真正返回原来程序被中断的位置。</p><p>由此可以看出，如果进程处于长时间用户空间中，即长时间无中断、异常或系统调用进入内核态，也就是说无法由内核态转到用户空间，这种情况下，即使信号区域有信号记录，也不会调用信号捕捉函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章节大概介绍了信号基本知识，后续会介绍信号编程函数以及信号机制带来的若干问题。</p><p><a href="www...">链接</a></p><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之静态/动态库生成实战</title>
      <link href="/FuckCode/2019/01/07/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E5%BA%93%E7%94%9F%E6%88%90%E5%AE%9E%E6%88%98/"/>
      <url>/FuckCode/2019/01/07/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E5%BA%93%E7%94%9F%E6%88%90%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><strong>本节就如何创建和使用程序库进行论述。所谓” 程序库”，简单说，就 是包含了数据和执行码的文件。其不能单独执行，可以作为其它执行程序的一部分来完成某些功能。库的存在，可以使得程序模块化，可以加快程序的再编译，可以实现代码重用，可以使得程序便于升级。程序库可分静态库 (static library) 和共享库 (shared object)。</strong><br><a id="more"></a></p><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>静态库是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。静态库可以认为是一些目标代码的集合。按照习惯，一般以”.a” 做为文件后缀名。使用 ar(archiver) 命令可以创建静态库。因为共享库有着更大的优势，静态库已经不经常使用。但静态库使用简单，仍有使用的余地，并会一直存在。有些 Unix 系统，如 Solaris 10，已经基本废弃了静态库。<br>静态库在应用程序生成时，可以不必再编译，节省再编译时间。但在编译器越来越快的今天，这一点似乎已不重要。如果其他开发人员要使用你的程序，而你又不想给其源码，提供静态库是一种选择。从理论上讲，应用程序使用了静态库，要比使用动态加载库速度快 1-5%，但实际上可能并非如此。由此看来，除了使用方便外，静态库可能并非一种好的选择。</p><p>要创建一个静态库，或要将目标代码加入到已经存在的静态库中，可以 使用以下命令:** 静态库</p><pre><code>ar rcs libmylib.a file1.o file2.o </code></pre><p>以上表示要把目标码 file1.o 和 file2.o 加入到静态库 libmylib.a 中 (ar 的参数 r)。若 libmylib.a 不存在，会自动创建 (ar 的参数 c)。然后更新.a 文件的索引，使之包含新加入的.o 文件的内容 (ar 的参数 s)。</p><p>静态库创建成功后，需要链接到应用程序中使用。使用 gcc 的 -l 选项来指定静态库，使用 -L 参数来指定库文件的搜索路径。比如上述例子应指定 -lmylib，所有库文件名都以 lib 开头，开头的 lib 在指定参数时应省略。-l 和 -L 之后都直接带参数而不跟空格。<br>在使用 gcc 时，要注意其参数的顺序。-l 是链接器选项，一定要放在被编译的文件名称之后;若放在文件名称之前则会连接失败，并会出现莫名其妙的错误。下面来实战一下。</p><h4 id="生成实例"><a href="#生成实例" class="headerlink" title="生成实例"></a>生成实例</h4><p>通用步骤：</p><ol><li><p>通过代码生成 *.o 编译后文件 </p><pre><code>gcc -c -fPIC (-Iinclude) *c -I 为包含头文件路径，include 为 *.c 源码包含的头文件路径</code></pre></li><li><p>使用 ar 将 <em>.o 打包成 </em>.a 静态库</p><pre><code>ar rcs lib*.a *.o可以使用 nm -a *.a 查看静态库内容</code></pre></li><li><p>将 *.a 打包到应用程序中直接使用</p><pre><code>gcc main.c (-Iinclude) lib/lib*.a -o app-I 包含头文件路径，lib*.a 为静态库名，前面的 lib 为静态库的路径</code></pre></li></ol><h4 id="代码及路径"><a href="#代码及路径" class="headerlink" title="代码及路径"></a>代码及路径</h4><p>库头文件</p><pre><code>路径： /include/math.h#include &lt;stdio.h&gt;int add(int i,int j);int sub(int i, int j);</code></pre><p>库实现文件</p><pre><code>路径： /src/math.c#include &quot;../include/math.h&quot;int add(int i,int j){    return i+j;}int sub(int i,int j){    return i*j;}</code></pre><p>调用文件</p><pre><code>路径： ./main.c#include &lt;stdio.h&gt;#include &quot;include/math.h&quot;int main(void){    int a = add(5,4);    printf(&quot;%d\n&quot;,a);    int s = sub(5,4);    printf(&quot;%d\n&quot;,s);    return 0;}</code></pre><h4 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h4><ol><li><p>将 <em>.c 生成 </em>.o 中间文件</p><pre><code>gcc -c -fPIC -Iinclude ./srcmath.c当前路径位于main.c, 生成 math.o </code></pre></li><li><p>根据 <em>.o 生成对应的 </em>.a 静态库</p><pre><code>ar rcs libmath.a math.o文件下生成 libmath.a 静态库文件查看静态内容    nm -a libmath.a </code></pre></li><li><p>将 *.a 打包进入可执行文件中</p><pre><code>gcc main.c (-Iinclude) lib/libmath.a -o app步骤2将生成静态库放到了主目录下lib下</code></pre></li><li><p>执行查看结果</p><pre><code>执行结果输出Allies:soku rememberme$ ./app920</code></pre></li></ol><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>共享库，是在执行程序启动时加载到执行程序中，可以被多个执行程序共享使用。建议库开发人员创建共享库，比较明显的优势在于库是独立的，便于维护和更新;而静态库的更新比较麻烦，一般不做推荐。然而，它们又各有优点，后面会讲到。</p><p>Linux下的库均采用的是动态库形式，便于更新以及各个程序都可无缝调用，而且还节省空间，优点出众，下面我们来看如何生成动态库并实施运行。</p><p>共享库的创建比较简单，基本有两步。首先使用 -fPIC 或 -fpic 创建目标文件，PIC 或 pic 表示位置无关代码，然后就可以使用以下格式创建共享库了:</p><pre><code>gcc -share -Wl,-soname,lib*.so.1 -o lib*.so.1.01 *.o</code></pre><p>注意：</p><ol><li>-Wl,-soname,lib*.so.1之间没有空格</li><li>*.o 后面可以跟 .o 多个文件</li><li><p>对于 so 库的默认名字的解释</p><pre><code>real name:  lib*.so.1.01    真实的so库名 so name:    lib*.so.1       只含有大版本的so库名link name:  lib*.so         编译链接阶段使用，方便Makefile管理link name 使用命令 ln -s lib*.so.1.01 lib.*.so 来创建</code></pre></li></ol><h4 id="生成实例-1"><a href="#生成实例-1" class="headerlink" title="生成实例"></a>生成实例</h4><p>通用步骤：</p><ol><li><p>源库文件 <em>.c 生成 </em>.o 中间文件</p><pre><code>gcc -c -fPIC (-Include) *.c</code></pre></li><li><p>将 <em>.o 生成动态库 </em>.so</p><pre><code>gcc -share -Wl,-soname,lib*.so.1 -o lib*.so.1.01 *.o</code></pre></li><li><p>将动态库链接到可执行主文件中</p><pre><code>gcc main.c lib/lib*.so -o app已建立动态库 real name 的 link name 库</code></pre></li><li><p>设置共享库配置文件</p><pre><code>1. 打开指定配置文件sudo vim /etc/ld.conf2. 添加动态库所在路径3. 更新动态库配置文件sudo ldconfig -v </code></pre></li></ol><h4 id="编译流程-1"><a href="#编译流程-1" class="headerlink" title="编译流程"></a>编译流程</h4><ol><li><p>源库文件 <em>.c 生成 </em>.o 中间文件</p><pre><code>gcc -c -fPIC -Include ./src/math.c</code></pre></li><li><p>将 <em>.o 生成动态库 </em>.so</p><pre><code>gcc -shared -Wl,-soname,libmath.so.1 -o libmath.so.1.01 math.olinux端测试成功，mac端失败，使用如下命令（不含版本号信息）gcc -shared -Wl -o libmath.so math.o</code></pre></li><li><p>将动态库链接到可执行主文件中</p><pre><code>gcc main.c lib/lib*.so -o app1已建立动态库 real name 的 link name 库ldd app1 测试程序可否找到共享库</code></pre></li><li><p>设置共享库配置文件（Linux配置，Mac测试无需配置）</p><pre><code>1. 打开指定配置文件sudo vim /etc/ld.conf2. 添加动态库所在的绝对路径/home/allies/linux/shared/lib3. 更新动态库配置文件sudo ldconfig -v </code></pre></li><li><p>运行查看结果</p><pre><code>Allies:soku rememberme$ ./app1920</code></pre></li></ol><h4 id="Linux下共享库的加载"><a href="#Linux下共享库的加载" class="headerlink" title="Linux下共享库的加载"></a>Linux下共享库的加载</h4><p>在所有基于 GNUglibc 的系统中，在启动一个 ELF 二进制执行程序时， 一个特殊的程序”程序装载器”会被自动装载并运行。在 linux 中，这个程序装载器就是/lib/ld-linux.so.X(X 是版本号)。它会查找并装载应用程序所依赖的所有共享库。被搜索的目录保存在/etc/ld.so.conf 文件中。当然，如果程序的每次启动，都要去搜索一番，势必效率不堪忍受。Linux 系统已经考虑这一点，对共享库采用了缓存管理。ldconfig 就是实现这一功能的工具，其缺省读取/etc/ld.so.conf 文件，对所有共享库按照一定规范建立符号连接，然后将信息写入 /etc/ld.so.cache。/etc/ld.so.cache 的存在大大加快了程序的启动速度。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>共享库下静态库和动态库都已实现，总结一下两者的优缺点：</p><table><thead><tr><th style="text-align:center">共享库</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">静态库</td><td style="text-align:center">库文件直接打入代码中，linux下无需修改动态库配置文件直接使用</td><td style="text-align:center">代码体积比较大，升级迭代麻烦</td></tr><tr><td style="text-align:center">动态库</td><td style="text-align:center">代码中使用相对地址寻址，值友符号记录表和库版本号，升级迭代容易，代码体积小</td><td style="text-align:center">主机必须含有共享库，且版本一致，linux下需要修改动态库搜寻配置文件</td></tr></tbody></table><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 共享库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之进程间通信</title>
      <link href="/FuckCode/2019/01/07/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/FuckCode/2019/01/07/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>之前文件介绍了Linux下进程的创建，执行以及回收，此章节就进程间通信进行详细介绍。Linux提供了多种进程间通信机制，本文会分别介绍匿名管道pipe，有名管道fifo，内存共享映射机制以及Socket套接字等。通过其中任意一种机制，都能够方便两个进程间进行通信操作，极大方便开发者的开发效率。</strong><br><a id="more"></a></p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>在Linux中，每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不 到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用 户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程 间通信(IPC，InterProcess Communication)。</p><p>Linux多进程间通信有多种方式，最简单的就是父子间的管道通信（父子进程共享文件描述符），然后是升级版的有名管道（指定管道描述符），其次是高效的内存共享映射和基于网络的Socket套接字。</p><h4 id="pipe管道"><a href="#pipe管道" class="headerlink" title="pipe管道"></a>pipe管道</h4><p>管道pipe提供了父子间进行通信的简单方式，使用起来也是相反方便。管道作用于有血缘关系的进程之间,通过fork来传递。</p><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><pre><code>#include &lt;unistd.h&gt;int pipe(int filedes[2]);</code></pre><h5 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h5><p>filedes[2]:  整型数组2个大小，一个为读端，一个为写端。pipe的单条管道只能实现单工通信，如果要实现双向通信，需要创建两条pipe管道。</p><h5 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h5><p>先调用pipe函数时在内核中开辟一块缓冲区(称为管道)用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端。之后通过fork得到子进程，共享之前创建的文件描述符实现父子血缘进程之间通信。</p><p>编程流程：</p><ol><li>父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。 </li><li>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。 </li><li>父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。</li></ol><p>使用限制：</p><ol><li>只支持单向数据流；</li><li>只能用于具有亲缘关系的进程之间；</li><li>没有名字；</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li><li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li></ol><p>4种特殊情况(假设都是阻塞I/O操作，没有设置O_NONBLOCK标志):</p><ol><li>所有指向管道写端的文件描述符都关闭了(管道写端的引用计数等于0)，而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</li><li>存在指向管道写端的文件描述符没关闭(管道写端的引用计数大于0)，而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</li><li>所有指向管道读端的文件描述符都关闭了(管道读端的引用计数等于0)，这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。</li><li>存在指向管道读端的文件描述符没关闭(管道读端的引用计数大于0)，而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</li></ol><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><p>阻塞式通信</p><pre><code>#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;wait.h&gt;#define SIZE 64int main(){    int pipeFd[2];    char str[] = &quot;This is test pipe content!\n&quot;;    char red[SIZE];    // 创建管道    int ret = pipe(pipeFd);    if(ret &lt; 0)    {        perror(&quot;pipe error!&quot;);        exit(1);    }    pid_t pid = fork();    if(pid &gt;0){        // 父进程，父写子读，关闭父读接口        close(pipeFd[0]);        sleep(3);        write(pipeFd[1],str,strlen(str));        // 阻塞等待子进程退出        wait(NULL);    }    else if(pid == 0)    {        // 子进程，父写子读，关闭子写接口        close(pipeFd[1]);        int len = read(pipeFd[0],red,sizeof(red));        write(STDOUT_FILENO,red,len);    }    return 0;}</code></pre><p>非阻塞式通信</p><pre><code>#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;wait.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define SIZE 64int main(){    int pipeFd[2];    char str[] = &quot;This is test pipe content!\n&quot;;    char msg[] = &quot;Try again!\n&quot;;    char red[SIZE];    // 创建管道    int ret = pipe(pipeFd);    if(ret &lt; 0)    {        perror(&quot;pipe error!&quot;);        exit(1);    }    pid_t pid = fork();    if(pid &gt;0){        // 父进程，父写子读，关闭父读接口        close(pipeFd[0]);        sleep(5);        write(pipeFd[1],str,strlen(str));        close(pipeFd[1]);        // 阻塞等待子进程退出        wait(NULL);    }    else if(pid == 0)    {        // 子进程，父写子读，关闭子写接口        close(pipeFd[1]);        int flag, len;        // 设置管道为非阻塞状态        flag = fcntl(pipeFd[0],F_GETFL);        flag |= O_NONBLOCK;        fcntl(pipeFd[0],F_SETFL, flag);try_again:         len = read(pipeFd[0],red,sizeof(red));        if(len == -1){            if(errno == EAGAIN){                write(STDOUT_FILENO,msg,sizeof(msg));                sleep(1);                goto try_again;            }            else            {                perror(&quot;read error!&quot;);                exit(1);            }        }        write(STDOUT_FILENO,red,len);        close(pipeFd[0]);    }    return 0;}</code></pre><h4 id="fifo有名管道"><a href="#fifo有名管道" class="headerlink" title="fifo有名管道"></a>fifo有名管道</h4><p>管道应用的一个重大限制是它没有名字，因此，只能用于具有亲缘关系的进程间通信，在有名管道（named pipe或FIFO）提出后，该限制得到了克服。FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。值得注意的是，FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。</p><h5 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h5><pre><code>#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode);</code></pre><h5 id="参数解释-1"><a href="#参数解释-1" class="headerlink" title="参数解释"></a>参数解释</h5><p>pathname: 事先规定的节点名称，多个进程间知晓<br>mode: 节点工作方式，可读可写等</p><p>注意：</p><ol><li>当只写打开FIFO管道时，如果没有FIFO没有读端打开，则open写打开会阻塞。</li><li>FIFO内核实现时可以支持双向通信。(pipe单向通信，因为父子进程共享同一个file<br>结构体)</li><li>FIFO可以一个读端，多个写端;也可以一个写端，多个读端。</li><li>FIFO读端和写端需要协同工作，同时打开读写，阻塞式通信。</li><li>FIFO内部数据结构采用严格的先进先出规则。</li><li>其由内核在内核中分配空间，再在磁盘中生成相应的节点，此节点内无任何数据（大小为0），只作为节点凭证。</li></ol><h5 id="相关说明-1"><a href="#相关说明-1" class="headerlink" title="相关说明"></a>相关说明</h5><p>FIFO的打开规则：</p><ol><li><p>如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。</p></li><li><p>如果当前打开操作是为写而打开FIFO时，如果已经有相应进程为读而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该FIFO（当前打开操作设置了阻塞标志）；或者，返回ENXIO错误（当前打开操作没有设置阻塞标志）。</p></li></ol><p>从FIFO中读取数据：</p><p>约定：如果一个进程为了从FIFO中读取数据而阻塞打开FIFO，那么称该进程内的读操作为设置了阻塞标志的读操作。</p><ol><li>如果有进程写打开FIFO，且当前FIFO内没有数据，则对于设置了阻塞标志的读操作来说，将一直阻塞。对于没有设置阻塞标志读操作来说则返回-1，当前errno值为EAGAIN，提醒以后再试。</li><li><p>对于设置了阻塞标志的读操作说，造成阻塞的原因有两种：</p><ul><li><p>当前FIFO内有数据，但有其它进程在读这些数据；</p></li><li><p>另外就是FIFO内没有数据。解阻塞的原因则是FIFO中有新的数据写入，不论信写入数据量的大小，也不论读操作请求多少数据量。</p></li></ul></li><li><p>读打开的阻塞标志只对本进程第一个读操作施加作用，如果本进程内有多个读操作序列，则在第一个读操作被唤醒并完成读操作后，其它将要执行的读操作将不再阻塞，即使在执行读操作时，FIFO中没有数据也一样（此时，读操作返回0）。</p></li><li><p>如果没有进程写打开FIFO，则设置了阻塞标志的读操作会阻塞。</p></li><li>如果FIFO中有数据，则设置了阻塞标志的读操作不会因为FIFO中的字节数小于请求读的字节数而阻塞，此时，读操作会返回FIFO中现有的数据量。</li></ol><p>向FIFO中写入数据：</p><p>约定：如果一个进程为了向FIFO中写入数据而阻塞打开FIFO，那么称该进程内的写操作为设置了阻塞标志的写操作。</p><ul><li><p>对于设置了阻塞标志的写操作：</p><ol><li><p>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。</p></li><li><p>当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO缓冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请求写的数据后返回。</p></li></ol></li><li><p>对于没有设置阻塞标志的写操作：</p><ol><li><p>当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。在写满所有FIFO空闲缓冲区后，写操作返回。</p></li><li><p>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果当前FIFO空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；如果当前FIFO空闲缓冲区不能够容纳请求写入的字节数，则返回EAGAIN错误，提醒以后再写。</p></li></ol></li></ul><p><a href="http://blog.chinaunix.net/uid-25365622-id-3059840.html" target="_blank" rel="noopener">参考链接</a></p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>头文件</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#define FIFO_NAME  &quot;fifo&quot;char str[] = &quot;Test fifo file...\n&quot;;</code></pre><p>写端</p><pre><code>#include &quot;fifo.h&quot;int main(void){    // fifo文件存在检测    if(access(FIFO_NAME, F_OK)){        // 不存在文件，直接创建        int ret = mkfifo(FIFO_NAME,0644);        if (ret != 0)        {            /* code */            perror(&quot;mkfifo error!&quot;);            exit(1);        }    }    // 存在fifo文件，打开    int fd = open(FIFO_NAME,O_RDWR);    if (fd &lt; 0)    {        /* code */        perror(&quot;open fifo error!&quot;);        exit(1);    }    write(fd, str, strlen(str));    printf(&quot;write fifo ok! \n&quot;);    close(fd);    return 0;}</code></pre><p>读端</p><pre><code>#include &quot;fifo.h&quot;int main(void){    char buf[64];    // fifo文件存在检测    if(access(FIFO_NAME, F_OK)){        perror(&quot;fifo file is  not exist!&quot;);        exit(1);    }    // 存在fifo文件，打开    int fd = open(FIFO_NAME,O_RDONLY);    if (fd &lt; 0)    {        /* code */        perror(&quot;open fifo error!&quot;);        exit(1);    }    int len = read(fd, buf, sizeof(buf));    write(STDOUT_FILENO,buf,len);    close(fd);    return 0;}</code></pre><h4 id="内存共享映射"><a href="#内存共享映射" class="headerlink" title="内存共享映射"></a>内存共享映射</h4><p>介于所有的程序都是从磁盘读取到内存，然后由CPU在内存中进行读取修改等。因此，内存共享映射可以提供一个地址即可实现通信功能。mmap可以把磁盘文件的一部分直接映射到内存，这样文件中的位置直接就有对应的内存地址，对文件的读写可以直接用指针来做而不需read/write函数。</p><h5 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h5><pre><code>#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t length);</code></pre><h5 id="参数解释-2"><a href="#参数解释-2" class="headerlink" title="参数解释"></a>参数解释</h5><p>addr: 如果addr参数为NULL，内核会自己在进程地址空间中选择合适的地址建立映射。如果 addr不是NULL，则给内核一个提示，应该从什么地址开始映射，内核会选择addr之上的某个 合适的地址开始映射。建立映射后，真正的映射首地址通过返回值可以得到。</p><p>length: 需要映射的那一部分文件的长度。</p><p>offset: 从文件的什么位置开始映射，必须是页大小的整数倍(在32位体系统结构上通常是4K)。</p><p>filedes: 代表映射文件的描述符。</p><p>prot: 参数有四种取值</p><pre><code>1. PROT_EXEC表示映射的这一段可执行，例如映射共享库2. PROT_READ表示映射的这一段可读3. PROT_WRITE表示映射的这一段可写4. PROT_NONE表示映射的这一段不可访问</code></pre><p>flag: 参数有很多种取值，这里只讲两种，其它取值可查看mmap(2)</p><pre><code>1. MAP_SHARED多个进程对同一个文件的映射是共享的，一个进程对映射的内存做了修 改，另一个进程也会看到这种变化。2. MAP_PRIVATE多个进程对同一个文件的映射不是共享的，一个进程对映射的内存做了修 改，另一个进程并不会看到这种变化，也不会真的写到文件中去。</code></pre><p>如果mmap成功则返回映射首地址，如果出错则返回常数MAP_FAILED，errno被设置。当进程终止时，该进程 的映射内存会自动解除，也可以调用munmap解除映射。munmap成功返回0，出错返回-1。</p><pre><code>EACCES：访问出错EAGAIN：文件已被锁定，或者太多的内存已被锁定EBADF：fd不是有效的文件描述词EINVAL：一个或者多个参数无效ENFILE：已达到系统对打开文件的限制ENOMEM：内存不足，或者进程已超出最大内存映射数量SIGSEGV：试着向只读区写入具体查看 Man Page</code></pre><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><pre><code>#include &lt;sys/mman.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#define MMAP_FILE &quot;hello&quot;int main(void){    char buf[] = &quot;HELLOWORLD&quot;;    // mmap文件存在检测    if(access(MMAP_FILE, F_OK)){        perror(&quot;mmap file is  not exist!&quot;);        exit(1);    }    // 存在mmap文件，打开    int fd = open(MMAP_FILE,O_RDWR);    if (fd &lt; 0)    {        /* code */        perror(&quot;open mmap file error!&quot;);        exit(1);    }    // 获取文件大小    int length = lseek(fd,0,SEEK_END);    int *addr = mmap(NULL, length, PROT_WRITE, MAP_SHARED, fd, 0);    // 修改内存数据，查看是否同步到文件    memcpy(addr,buf,length &gt;= sizeof(buf)?sizeof(buf):length);    // 关闭文件    close(fd);    // 解除内存映射    munmap(addr,length);    return 0;}</code></pre><p>测试代码中，可以事先向hello文件中写入一部分数据，之后调用该程序进行内存映射修改文件数据，之后打开文件查看内容。如果原数据小于写入buf数据，原文件替换成新数据，数据大小增加，如果写入数据buf小于源文件数据，那么只替换原数据中前面需要替换的字节，文件大小不变。</p><p>在内存映射文件时候，可以使用lseek实现对文件读写指针的修改，控制读取写入数据的位置。后续实现多进程或多线程数据拷贝中可以使用到。</p><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>Linux下的Socket套接字需要很大的篇章来介绍，这里险先立个flag，后续会着重介绍。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux下进程间通信通用的七种方式：</p><p>第一类：传统的unix通信机制：</p><ol><li>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li><li>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ol><p>第二类：System V IPC： </p><ol start="4"><li>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li></ol><p>第三类：BSD 套接字：</p><ol start="7"><li>套接字( socket ) ： 套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li></ol><p><a href="http://blog.chinaunix.net/uid-25365622-id-3059840.html" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>邢文鹏Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨进程通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之进程</title>
      <link href="/FuckCode/2019/01/05/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/"/>
      <url>/FuckCode/2019/01/05/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>学习Linux中的进程，主要设计了三个重要的函数：fork（创建子进程），exec（执行命令），wait（回收进程资源）。进程的管理由内核中的task_struct结构体(PCB进程控制块)负责，下面我们来具体了解一下。</strong><br><a id="more"></a></p><h3 id="PCB及进程环境"><a href="#PCB及进程环境" class="headerlink" title="PCB及进程环境"></a>PCB及进程环境</h3><h4 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h4><p>我们知道，每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。现在我们全面了解一下其中都有哪些信息。</p><ul><li>进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</li><li>进程的状态，有运行、挂起、停止、僵尸等状态。</li><li>进程切换时需要保存和恢复的一些CPU寄存器。</li><li>描述虚拟地址空间的信息。</li><li>描述控制终端的信息。</li><li>当前工作目录(Current Working Directory)。</li><li>umask掩码。</li><li>文件描述符表，包含很多指向file结构体的指针。</li><li>和信号相关的信息。</li><li>用户id和组id。</li><li>控制终端、Session和进程组。</li><li>进程可以使用的资源上限(Resource Limit)</li></ul><h4 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h4><p>每个进程在运行时，都会涉及到默认的环境变量。按照惯例，环境变量字符串都是name=value这样的形式，大多数name由大写字母加下划线组成，一般把name的部分叫做环境变量，value的部分则是环境变量的值。环境变量定义了进程的运行环境，一些比较重要的环境变量的含义如下:</p><p>PATH</p><ul><li>可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out，这 是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查 看这个环境变量的值:$ echo $PATH </li></ul><p>SHELL</p><ul><li>当前Shell，它的值通常是/bin/bash。 </li></ul><p>TERM</p><ul><li>当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程序的输 出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。</li></ul><p>LANG</p><ul><li>语言和locale，决定了字符编码以及时间、货币等信息的显示格式。</li></ul><p>HOME</p><ul><li>当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运 行该程序时都有自己的一套配置。</li></ul><h4 id="环境变量相关函数"><a href="#环境变量相关函数" class="headerlink" title="环境变量相关函数"></a>环境变量相关函数</h4><p>libc中定义的全局变量environ指向环境变量表，environ没有包含在任何头文件中，所<br>以在使用时要用extern声明。例如：</p><pre><code>#include &lt;stdio.h&gt;int main(void) {    extern char **environ;    int i;    for(i=0; environ[i]!=NULL; i++)    printf(&quot;%s\n&quot;, environ[i]); return 0;}</code></pre><p>用environ指针可以查看所有环境变量字符串，但是不够方便，如果给出name要在环境变量 表中查找它对应的value，可以用getenv函数。</p><h5 id="获取环境变量getenv"><a href="#获取环境变量getenv" class="headerlink" title="获取环境变量getenv"></a>获取环境变量getenv</h5><pre><code>#include &lt;stdlib.h&gt;char *getenv(const char *name); getenv的返回值是指向value的指针，若未找到则为NULL。</code></pre><h4 id="设置及取消"><a href="#设置及取消" class="headerlink" title="设置及取消"></a>设置及取消</h4><pre><code>#include &lt;stdlib.h&gt;int setenv(const char *name, const char *value, int rewrite); void unsetenv(const char *name);putenv和setenv函数若成功则返回为0，若出错则返回非0。</code></pre><p>setenv将环境变量name的值设置为value。如果已存在环境变量name，那么若rewrite非0，则覆盖原来的定义; 若rewrite为0，则不覆盖原来的定义，也不返回错误。unsetenv删除name的定义。即使name没有定义也不返回错误。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){    // 获取    char* path = getenv(&quot;PATH&quot;);    printf(&quot;PATH : %s \n&quot;, path);    // 设置    setenv(&quot;PATH&quot;,&quot;what fuck you!&quot;,1);    printf(&quot;NEW PATH: %s\n&quot;,getenv(&quot;PATH&quot;));    return 0;}</code></pre><h4 id="进程资源限制"><a href="#进程资源限制" class="headerlink" title="进程资源限制"></a>进程资源限制</h4><p>PCB由内核实施管理，其为每个进程分配的资源大小也是固定有限的，不能无限制的增加，一般来说软限制不得大于硬限制，设置进程资源的函数如下（root权限）：</p><pre><code>#include &lt;sys/time.h&gt; #include &lt;sys/resource.h&gt;int getrlimit(int resource, struct rlimit *rlim);int setrlimit(int resource, const struct rlimit *rlim)；</code></pre><p>查看资源限制</p><pre><code>cat /proc/self/limltsulimit -a</code></pre><p>设置进程打开文件上限值</p><pre><code>ulimit -n ?</code></pre><h3 id="进程原语"><a href="#进程原语" class="headerlink" title="进程原语"></a>进程原语</h3><p>linux涉及进程的函数主要包括复制进程fork，执行命令exec以及回收进程资源wait（waitpid）。程序一般的流程是通过fork得到一个子进程，然后再子进程中执行exec命令操作，之后通过wait或者waitpid回收进程执行的结果。</p><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>linux中进程存在多种状态，运行，就绪，睡眠，停止，各种状态存在转换关系，例如运行态可以切换到任意其他三种状态，具体切换状态如下：</p><p>运行： 可以切换到就绪，睡眠，停止任意状态<br>就绪： 可以切换到就绪，停止，无法直接切换到运行<br>就绪： 同运行，可以切换任意其他状态<br>停止： 无法切换状态</p><h5 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h5><p>查看系统所有程序： ps aux<br>动态查看进程： top<br>进程组查看： ps ajx</p><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>fork的作用是根据一个现有的进程复制出一个新进程，原来的进程称为父进程(Parent Process)，新进程称为子进程(Child Process)。系统中同时运行着很多进程，这些进程都是从最初只有一个进程开始一个一个复制出来的。在Shell下输入命令可以运行一个程序，是因为Shell进程在读取用户输入的命令之后会调用fork复制出一个新的Shell进程，然后新的Shell进程调用exec执行新的程序。</p><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><pre><code>#include &lt;unistd.h&gt;pid_t fork(void);</code></pre><h5 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h5><p>void</p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>fork调用一次，返回两次。调用成功后，父进程中返回0，子进程中返回系统分配的pid（非负整数）。如果调用失败，父进程中返回-1，并且设置errno，子进程不被创建。</p><pre><code>EAGAIN: 当前的进程数已经达到了系统规定的上限，这时errno的值被设置为ENOMEM: 系统内存不足，这时errno的值被设置为</code></pre><h5 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h5><ol><li>fork调用一次，返回两次，成功时，父进程中返回0，子进程中返回进程id。</li><li>fork执行后，父子进程的执行代码直接从返回值处pid开始，父子进程的执行的先后顺序不确定，由操作系统调度。父进程先于子进程结束，子进程的父进程转换成init守护进程。</li><li>父子进程的拷贝采用读时共享，写时复制机制（copy on write）。</li></ol><h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code>#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;int main(void) {    pid_t id = fork();    pid_t pid; char *message; int n;    pid = fork();     if (pid &lt; 0) {        perror(&quot;fork failed&quot;);        exit(1);    }    if (pid == 0) {        message = &quot;This is the child\n&quot;; n = 6;    } else {        message = &quot;This is the parent\n&quot;; n = 3;    }    for(; n &gt; 0; n--) {        printf(message);        sleep(1);     }    return 0; }</code></pre><p>fork调用完成后，此时父子进程都从if判断开始，由于父子进程执行顺序不确定，在各自逻辑处理完成后，睡眠等待 1s 后，在结束父进程，后续可以通过wait函数进行回收进程资源。其代码执行流程见下图：</p><img src="/FuckCode/2019/01/05/Linux系统编程之进程/fork.png" class="fork执行流程"><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>用fork创建子进程后执行的是和父进程相同的程序(但有可能执行不同的代码分支)，子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。其实有六种以exec开头的函数，统称exec函数:</p><pre><code>#include &lt;unistd.h&gt;int execl(const char *path, const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *path, const char *arg, ..., char *const envp[]）; int execv(const char *path, char *const argv[]);int execvp(const char *file, char *const argv[]);int execve(const char *path, char *const argv[], char *const envp[]);</code></pre><p>这些函数如果调用成功则加载新的程序从启动代码开始执行，不再返回，如果调用出错，则返回-1，所以exec函数只有出错的返回值而没有成功的返回值。</p><h5 id="相关说明-1"><a href="#相关说明-1" class="headerlink" title="相关说明"></a>相关说明</h5><p>exec函数族记忆方式：</p><pre><code>l 命令行参数列表p 搜素file时使用path变量v 使用命令行参数数组e 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量execvp常用，使用数组将命令组织，调用时直接使用系统路径进行</code></pre><p>代码举例:</p><pre><code>char *const ps_argv[] ={&quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL}; char *const ps_envp[] ={&quot;PATH=/bin:/usr/bin&quot;, &quot;TERM=console&quot;, NULL}; execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL); execv(&quot;/bin/ps&quot;, ps_argv);execle(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL, ps_envp); execve(&quot;/bin/ps&quot;, ps_argv, ps_envp);execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-o&quot;, &quot;pid,ppid,pgrp,session,tpgid,comm&quot;, NULL);execvp(&quot;ps&quot;, ps_argv);</code></pre><p>事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，所以execve 在man手册第2节，其它函数在man手册第3节。这些函数之间的关系如下图所示:</p><img src="/FuckCode/2019/01/05/Linux系统编程之进程/exec.png" class="fork执行流程"><h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main(){    pid_t id = fork();    if(id == 0)    {        // 子进程执行打开网页        execlp(&quot;firefox&quot;,&quot;firefox&quot;,&quot;www.baidu.com&quot;,NULL);    }    else if(id &gt; 0)    {        // 父进程执行 ls        execl(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-la&quot;, &quot;./../&quot;,NULL);    }    return 0;}</code></pre><h4 id="wait-waitpid"><a href="#wait-waitpid" class="headerlink" title="wait(waitpid)"></a>wait(waitpid)</h4><p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息:如果是正常终止则保存着退出状态，如果是异常终止 则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。</p><p>我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。如果一个进程已经终止，但是它的父进程尚未调用wait或waitpid对它进行清理，这时的进程状态称为僵尸(Zombie)进程。任何进程在刚终止时都是僵尸进程，正常情况下，僵尸进程都立刻被父进程清理了。</p><ul><li>僵尸进程： 子进程退出，父进程没有回收子进程资源(PCB)，则子进程变成僵尸进程</li><li>孤儿进程： 父进程先于子进程结束，则子进程成为孤儿进程</li><li>领养孤儿进程： 成为孤儿的子进程，其父进程变成成为1号init进程</li></ul><h5 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h5><pre><code>#include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt;pid_t wait(int *status);pid_t waitpid(pid_t pid, int *status, int options);对于 waitpid 的 pid 而言：&lt; -1 回收指定进程组内的任意子进程-1 回收任意子进程0 回收和当前调用waitpid一个组的所有子进程 &gt; 0 回收指定ID的子进程</code></pre><p>若调用成功则返回清理掉的子进程id，若调用出错则返回-1。父进程调用 wait或waitpid 时可能出现情况:</p><ul><li>阻塞(如果它的所有子进程都还在运行)。</li><li>带子进程的终止信息立即返回(如果一个子进程已终止，正等待父进程读取其终止信息)。</li><li>出错立即返回(如果它没有任何子进程)</li></ul><p>这两个函数的区别是:</p><ul><li>如果父进程的所有子进程都还在运行，调用wait将使父进程阻塞，而调用waitpid时如果在options参数中指定WNOHANG可以使父进程不阻塞而立即返回0。</li><li>wait等待第一个终止的子进程，而waitpid可以通过pid参数指定等待哪一个子进程。</li></ul><p>可见，调用 wait和waitpid 不仅可以获得子进程的终止信息，还可以使父进程阻塞等待子进程终止，起到进程间同步的作用。如果参数 status 不是空指针，则子进程的终止信息通过这个参数传出，如果只是为了同步而不关心子进程的终止信息，可以将 status 参数指定为 NULL。</p><p>对于子进程退出状态的监测，使用宏函数进行监测，具体参考 Man Page。</p><h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><p>wait阻塞推出监测</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;wait.h&gt;int main(){    pid_t id = fork();    int status;    pid_t ret;    if(id == 0)    {        // 子进程中返回，处理子进程逻辑        printf(&quot;Child is running for 5s! The pid is %d\n&quot;,getpid());        // 延时5s，执行退出        sleep(5);        exit(1);    }    else if(id &gt; 0)    {        // 父进程中返回        printf(&quot;This is parent, the parent id is %d\n&quot;,getppid());    }    while(1)    {        // 阻塞函数，将子进程返回状态存到status中        ret = wait(&amp;status);        if(ret == id)            printf(&quot;Child exits, pid id %d\n&quot;,ret);        else if(ret == -1)        {            printf(&quot;No child is exist\n&quot;);            break;        }        else            break;    }    // 退出状态监测status    if (WIFEXITED(status))        printf(&quot;Child exited with code %d\n&quot;, WEXITSTATUS(status));    else if (WIFSIGNALED(status))        printf(&quot;Child terminated abnormally, signal %d\n&quot;, WTERMSIG(status));    return 0;}</code></pre><p>waitpid指定阻塞监听</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){    pid_t pid;    pid = fork();    if (pid &lt; 0) {        perror(&quot;fork failed&quot;);        exit(1);    }    if (pid == 0) {        int i;        for (i = 3; i &gt; 0; i--) {            printf(&quot;This is the child\n&quot;);            sleep(1);        }        exit(3);    } else {        int stat_val;        // 回收指定id进程资源        waitpid(pid, &amp;stat_val, 0);            if (WIFEXITED(stat_val))                printf(&quot;Child exited with code %d\n&quot;, WEXITSTATUS(stat_val));            else if (WIFSIGNALED(stat_val))                printf(&quot;Child terminated abnormally, signal %d\n&quot;, WTERMSIG(stat_val));    }    return 0;}</code></pre><p>#### 进程相关函数</p><p>获取进程id</p><pre><code>#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;pid_t getpid(void); //返回调用进程的PID号pid_t getppid(void); //返回调用进程父进程的PID号</code></pre><p>获取用户id</p><pre><code>#include &lt;unistd.h&gt; #include &lt;sys/types.h&gt;uid_t getuid(void); //返回实际用户ID uid_t geteuid(void); //返回有效用户ID</code></pre><p>获取组id</p><pre><code>#include &lt;unistd.h&gt; #include &lt;sys/types.h&gt;gid_t getgid(void); //返回实际用户组ID gid_t getegid(void); //返回有效用户组ID</code></pre><h5 id="特殊权限位"><a href="#特殊权限位" class="headerlink" title="特殊权限位"></a>特殊权限位</h5><p>s: 这里的特殊权限位s代表的是动态权限设置位（setuid），方便普通用户可以以root用户的角色运行只有root帐号才能运行的程序或命令。</p><pre><code>whereis passwd/usr/bin/passwdls -la /usr/bin/passwd-rwsr-xr-x  1   root    root    ...</code></pre><p>在设置s权限时文件属主、属组必须先设置相应的x权限，否则s权限并不能正真生效（当我们ls -l时看到rwS，大写S说明s权限未生效）</p><pre><code>执行    sudo chmod * 04755  原权限  -rwxr-xr-x 新权限  -rwsr-xr-x </code></pre><p>t: 设置粘着位，一个文件可读写的用户并一定相让他有删除此文件的权限，如果文件设置了t权限则只用属主和root有删除文件的权限，通过chmod +t filename 来设置t权限。</p><p>i: 不可修改权限。例：chattr u+i filename 则filename文件就不可修改，无论任何人，如果需要修改需要先删除i权限，用chattr -i filename就可以了。查看文件是否设置了i权限用lsattr filename。</p><p>a: 只追加权限，对于日志系统很好用，这个权限让目标文件只能追加，不能删除，而且不能通过编辑器追加。可以使用chattr +a设置追加权限。</p><p><a href="https://blog.csdn.net/LYJwonderful/article/details/80220452" target="_blank" rel="noopener">特殊权限详见</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇博文主要介绍了Linux中涉及进程的三大函数fork、exec以及wait，知晓了一般进程的创建，执行以及回收销毁登，为后续进程间通信提供基础。对于Linux中的进程限制，可以通过手动修改提高程序的并发行，但是此方法也不是万能的，后续还会介绍Linux下的多线程编程基础，涉及到多线程，又不得不提线程同步，东西那么多还是要一点一点的啃，此章节就此告一段落吧！</p><blockquote><p>邢文鹏老师Linux教学资料</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之文件IO进阶</title>
      <link href="/FuckCode/2019/01/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%96%87%E4%BB%B6IO%E8%BF%9B%E9%98%B6/"/>
      <url>/FuckCode/2019/01/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%96%87%E4%BB%B6IO%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>文章概括描述文段</strong><br>上篇文章中介绍了linux中基本的io处理操作，对于一般的文件读取是没有问题的，但是考虑到终端以及网络等可能存在阻塞情况下，这时候就需要我们使用标志位 O_NONBLOCK 。其次，对于文件的阻塞和非阻塞操作，如果是一个已经打开的文件呢又该如何操作，fcntl 便应运而生了。<br><a id="more"></a></p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>读常规文件是不会阻塞的，不管读多少字节，read一定会在有限的时间内返回。从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会阻塞，如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。<br>现在明确一下阻塞(Block)这个概念。当进程调用一个阻塞的系统函数时，该进程被置于睡眠(Sleep)状态，这时内核调度其它进程运行，直到该进程等待的事件发生了(比如网络上接收到数据包，或者调用sleep指定的睡眠时间到了)它才有可能继续运行。与睡眠状态相对的是运行(Running)状态，在Linux内核中，处于运行状态的进程分为两种情况:</p><ol><li>正在被调度执行。CPU处于该进程的上下文环境中，程序计数器(eip)里保存着该进程的指令地址，通用寄存器里保存着该进程运算过程的中间结果，正在执行该进程的指令，正在读写该进程的地址空间。</li><li>就绪状态。该进程不需要等待什么事件发生，随时都可以执行，但CPU暂时还在执行另一个进程，所以该进程在一个就绪队列中等待被内核调度。系统中可能同时有多个就绪的进程，那么该调度谁执行呢?内核的调度算法是基于优先级和时间片的，而且会根据每个进程的运行情况动态调整它的优先级和时间片，让每个进程都能比较公平地得到机会执行，同时要兼顾用户体验，不能让和用户交互的进程响应太慢。</li></ol><h4 id="阻塞读终端"><a href="#阻塞读终端" class="headerlink" title="阻塞读终端"></a>阻塞读终端</h4><p>对于终端设备来说，如果终端没有输入，那么read将一直阻塞，知道用户输入enter后才会返回结果。</p><pre><code>#include &lt;unistd.h&gt; #include &lt;stdlib.h&gt;int main(void) {    char buf[10];    int n;    // 阻塞读终端数据    n = read(STDIN_FILENO, buf, 10);     if (n &lt; 0) {        perror(&quot;read STDIN_FILENO&quot;);        exit(1);     }    // 读成功，写到输出终端    write(STDOUT_FILENO, buf, n);    return 0; }</code></pre><h4 id="非阻塞读终端"><a href="#非阻塞读终端" class="headerlink" title="非阻塞读终端"></a>非阻塞读终端</h4><p>如果在open一个设备时指定了O_NONBLOCK标志，read/write就不会阻塞。以read为例，如果设备暂时没有数据可读就返回-1，同时置errno为EWOULDBLOCK(或者EAGAIN，这两个 宏定义的值相同)，表示本来应该阻塞在这里(would block，虚拟语气)，事实上并有阻塞而是直接返回错误，调用者应该试着再读一次(again)。这种行为方式称为轮询 (Poll)，调用者只是查询一下，而不是阻塞在这里死等，这样可以同时监视多个设备。</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#define DEV_TTY  &quot;/dev/tty&quot;#define MSG_TRY  &quot;try again \n&quot;int main(void){    char buf[10];    int fd,n;    // 以非阻塞方式打开文件设备    fd = open(DEV_TTY,O_RDONLY | O_NONBLOCK);    if(fd&lt;0)    {        perror(&quot;open device error!&quot;);        exit(1);    }// 轮训标志try_again:    // 非阻塞读数据，立即返回    n = read(fd,buf,sizeof(buf));    if(n &lt; 0){        // 未读取到任何数据，重新读取        if(errno == EAGAIN)        {            // 输出重读标志            write(STDOUT_FILENO,MSG_TRY,strlen(MSG_TRY));            // 睡眠一会            sleep(3);            goto try_again;        }        else        {            perror(&quot;read device error!&quot;);            exit(1);        }    }    // 写入输出终端    write(STDOUT_FILENO,buf,n);    close(fd);    return 0;}</code></pre><p>用非阻塞I/O实现等待超时的例子。既保证了超时退出的逻辑又保证了有数据到<br>达时处理延迟较小。</p><h4 id="非阻塞升级，等待超时"><a href="#非阻塞升级，等待超时" class="headerlink" title="非阻塞升级，等待超时"></a>非阻塞升级，等待超时</h4><p>对于非阻塞读取终端数据，逻辑上是采用轮训的方式，这样处理起来有一点不好就是要一直的sleep睡眠等待。在一定程度上造成性能的浪费，。当然排除select，poll以及epoll等高效的异步IO转接方式，另一种可以替代的方式就是规定在一定的时间范围呢进行轮训，如果超时了就直接推出，给出有效提示。</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#define DEV_TTY  &quot;/dev/tty&quot;#define MSG_TRY  &quot;try again \n&quot;#define MSG_TIMEOUT &quot;read device time out!\n&quot;int main(void){    char buf[10];    int fd,n;    fd = open(DEV_TTY,O_RDONLY | O_NONBLOCK);    if(fd&lt;0)    {        perror(&quot;open device error!&quot;);        exit(1);    }    // ls * 10 的超时等待    for (int i = 0; i &lt; 10; ++i)    {        /* code */        n = read(fd,buf,sizeof(buf));        if(n &lt; 0){            if(errno == EAGAIN)            {                // 未读取有效数据，睡眠等待轮训                write(STDOUT_FILENO,MSG_TRY,strlen(MSG_TRY));                sleep(1);            }            else            {                /* code */                perror(&quot;read device error!&quot;);                exit(1);            }        }        else        {            // 读取到有效数据，直接打印输出            write(STDOUT_FILENO,buf,n);            close(fd);            return 0;        }    }    // 读取超时，打印输出超时信息    write(STDOUT_FILENO,MSG_TIMEOUT,strlen(MSG_TIMEOUT));    close(fd);    return 0;}</code></pre><h3 id="使用-fcntl-修改文件状态位"><a href="#使用-fcntl-修改文件状态位" class="headerlink" title="使用 fcntl 修改文件状态位"></a>使用 fcntl 修改文件状态位</h3><p>先前我们以read终端设备为例介绍了非阻塞I/O，为什么我们不直接对STDIN_FILENO做非阻塞read，而要重新open一遍/dev/tty呢?因为STDIN_FILENO在程序启动时已经被自动打开了，而我们需要在调用open时指定O_NONBLOCK标志。这里介绍另外一种办法，可以用 fcntl 函数改变一个已打开的文件的属性，可以重新设置读、写、追加、非阻塞等标志(这些标志称为File Status Flag)，而不必重新open文件。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><pre><code>#include &lt;fcntl.h&gt;int fcntl(int fildes, int cmd, ...);</code></pre><h4 id="参数描述"><a href="#参数描述" class="headerlink" title="参数描述"></a>参数描述</h4><p>filsed: 唯一文件描述符<br>cmd: 操作命令</p><p>根据cmd命令，我们可以选择对一打开文件描述符进行属性操作，例如通过命令 F_GETFD 来获取当前文件描述符的属性，通过 F_SETFD 来设置已经打开的文件描述符的属性，从而避免从新打开时添加对应的属性。</p><table><thead><tr><th>cmd</th><th>描述</th></tr></thead><tbody><tr><td>F_DUPFD</td><td>复制文件描述词</td></tr><tr><td>F_GETFD</td><td>读取文件描述词标志</td></tr><tr><td>F_SETFD</td><td>设置文件描述词标志</td></tr><tr><td>F_GETFL</td><td>读取文件状态标志</td></tr><tr><td>F_SETFL</td><td>设置文件状态标志</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>更多设置参考 Man Page</p><p>在 F_SETFL 命令中，其中O_RDONLY， O_WRONLY， O_RDWR， O_CREAT，  O_EXCL， O_NOCTTY 和 O_TRUNC不受影响，可以更改的标志有 O_APPEND，O_ASYNC， O_DIRECT， O_NOATIME 和 O_NONBLOCK。 </p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>返回值根据命令的不同有不同的返回值，例如 F_DUPFD 会返回一个新的文件描述符，F_GETFL 会返回文件的属性位等，如果出错会反悔 -1， 并且置位 errno，具体参考 Man Page。</p><h4 id="实力代码"><a href="#实力代码" class="headerlink" title="实力代码"></a>实力代码</h4><p>本片主要讲述文件属性值的设置，下面代码展示了如何通过 fctnl 函数对已经打开的文件进行非阻塞读取操作。</p><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#define DEV_TTY  &quot;/dev/tty&quot;#define MSG_TRY  &quot;try again \n&quot;#define MSG_TIMEOUT &quot;read device time out!\n&quot;int main(void){    char buf[10];    int fd,n;    fd = open(DEV_TTY,O_RDONLY);    // 通过fcntl的命令 F_GETFL 获取打开文件的访问属性    int flags = fcntl(fd,F_GETFL);    printf(&quot;flags0 is %d\n&quot;,flags);    // 属性添加 O_NONBLOCK    flags |= O_NONBLOCK;    printf(&quot;flags1 is %d\n&quot;,flags);    // 通过命令 F_SETFL 将新的文件属性设置到文件中去    fcntl(fd,F_SETFL, flags);    if(fd&lt;0)    {        perror(&quot;open device error!&quot;);        exit(1);    }    for (int i = 0; i &lt; 5; ++i){        /* code */        n = read(fd,buf,sizeof(buf));        if(n &lt; 0){            if(errno == EAGAIN){                write(STDOUT_FILENO,MSG_TRY,strlen(MSG_TRY));                sleep(1);            } else {                /* code */                perror(&quot;read device error!&quot;);                exit(1);            }        } else {            write(STDOUT_FILENO,buf,n);            close(fd);            return 0;        }    }    write(STDOUT_FILENO,MSG_TIMEOUT,strlen(MSG_TIMEOUT));    close(fd);    return 0;}</code></pre><p>当然 fctnl 的功能还有很多，比如文件锁（读共享，写私有）等，后续篇幅会在锁机制中统一介绍，这里单纯的介绍一下设置文件非阻塞访问属性。</p><h3 id="lseek修改文件访问指针"><a href="#lseek修改文件访问指针" class="headerlink" title="lseek修改文件访问指针"></a>lseek修改文件访问指针</h3><p>lseek函数的作用是用来重新定位文件读写的位移。</p><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><pre><code>#include &lt;unistd.h&gt;off_t   lseek(int fildes, off_t offset, int whence);</code></pre><h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h4><p>fildes： 文件描述符<br>offset： 为正则向文件末尾移动（向前移），为负数则向文件头部（向后移）<br>whence： 文件便偏移参考值</p><pre><code>SEEK_SET:　　从文件头部开始偏移offset个字节SEEK_CUR：　　从文件当前读写的指针位置开始，增加offset个字节的偏移量SEEK_END：　　文件偏移量设置为文件的大小加上偏移量字节</code></pre><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>如果设备不支持lseek，则lseek返回-1，并将errno设置为ESPIPE。<br>注意 fseek 和 lseek 在返回值上有细微的差别， fseek 成功时返回 0 ，失败时返回 -1 ，要返回当前偏移量需调用 ftell ，而 lseek 成功时返回当前偏移量失败时返回 -1 。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code>// 获取文件大小int lseek(fd,0,SEEK_END)// 扩充文件大小int add_len = 1024*8;int fd=open(&quot;test.txt&quot;,O_RDWR);if(fd == -1){    perror(&quot;open test.txt&quot;);    exit(-1);}lseek(fd,add_len-1,SEEK_END);</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过前面博文中对 open，read，write，close 等函数的介绍，基本能够完成一般文件的 IO 操作，此篇幅有详细介绍了阻塞与非阻塞读取数据，文件属性修改函数 fcntl 的功能，其能够实现对打开文件的属性操作，函数功能非常强大。同时，lseek函数能够获取一打开文件的大小，还可以扩充文件的大小（lseek后必须进行一个write操作）。博文参考刑文鹏老师的Linux系统编程资料，特此记录以备不时之需。</p><blockquote><p>参考学习资料邢文鹏老师</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阻塞 非阻塞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程之文件IO</title>
      <link href="/FuckCode/2019/01/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%96%87%E4%BB%B6IO/"/>
      <url>/FuckCode/2019/01/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<p><strong>在Linux系统中，一切皆是文件。文件相当于操作系统和设备之间的一架桥梁。程序可以像使用文件那样访问磁盘文件，串行口，打印机等其他设备。通常情况下，我们可以通过以下5个函数，即可操作众多设备：open、close、read、write和ioctl。例外的情况： 目录的读写，网络连接等特殊文件</strong></p><a id="more"></a><h3 id="文件IO介绍"><a href="#文件IO介绍" class="headerlink" title="文件IO介绍"></a>文件IO介绍</h3><p>文件和设备</p><pre><code>/dev/console - 系统控制台。  /dev/tty - 访问不同的物理设备。   /dev/null - 空设备，向所有写这个设备的输出都将被丢弃。</code></pre><p>设备驱动程序</p><p>操作系统的核心部分，即内核，是由一组设备驱动程序组成。他们是一组对系统硬件进行控制的底层接口，为了向用户提供一个一致的接口，其封装了所有与硬件相关的特性。<br>硬件特有功能可通过ioctl(用于I/O控制)系统调用来提供。</p><pre><code>/dev 目录下的设备文件都可以被打开、读、写和关闭。1）open : 打开文件或设备。2）read : 从打开的文件或设备里读数据。3）write: 向文件或设备写数据。4）close: 关闭文件或设备。5） ioctl:  把控制信息传递给设备驱动程序,每个驱动都由自己的一组 ioctl 命令。</code></pre><p>库函数</p><p>针对输入输出操作直接使用底层系统调用效率非常低，原因由如下两点。</p><ol><li>使用系统调用会影响系统性能。  </li><li>硬件会对底层系统调用一次所读写的数据块大小做限制。磁盘：至少一个扇区512字节，磁带，一次 10K</li></ol><p>库函数给设备和磁盘文件提供了更高层的接口，即标准函数库。使用它你可以高效读写任意长度的数据块,库函数则在数据满足条件后再安排系统调用。这样极大降低了开销。<br>注：库函数的文档一般放在手册的第三页，每个库函数有其对应的头文件。</p><p>底层文件访问</p><p>运行中的程序称为进程，每个进程都有与之关联的文件描述符。</p><p>文件描述符 － 一些小值整数，通过他们访问打开的文件或设备。一旦一个进程启动，内核就会分配三个文件描述符FILE：</p><pre><code>0:   标准输入   STDIN_FILENO1:   标准输出   STDOUT_FILENO2:   标准错误   STDERR_FILENO</code></pre><p>文件描述符的变化范围是：0~OPEN_MAX-1，默认为1024(可通过ulmit -a 查看)</p><p>查看支持打开文件个数  cat /proc/sys/fs/file_max</p><h3 id="系统函数介绍"><a href="#系统函数介绍" class="headerlink" title="系统函数介绍"></a>系统函数介绍</h3><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><p>作用：打开或者创建一个文件描述符（文件或设备）</p><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);</code></pre><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>通过给定一个文件名或者路径，成功调用后，进程中返回系统能够分配最小的文件描述符。此文件描述符进程内唯一，两个不同进程访问同一个文件所分配的文件描述符不一定相同。</p><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code>pathname - 指示准备打开的文件或设备的名字;flags    - 用于指定打开文件所采取的动作;mode    - 用于指定创建文件的权限，指定动作为 O_CREATE 才使用。</code></pre><p>必须制定的flag操作：</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>以只读方式打开</td></tr><tr><td>O_WRONLY</td><td>以只写方式打开</td></tr><tr><td>O_RDWR</td><td>以读写方式打开</td></tr></tbody></table><p>可选的flag操作</p><ul><li>O_APPEND 表示追加。如果文件已有内容,这次打开文件所写的数据附加到文件的末尾<br>而不覆盖原来的内容。</li><li>O_CREAT 若此文件不存在则创建它。使用此选项时需要提供第三个参数mode,表示该<br>文件的访问权限。</li><li>O_EXCL 如果同时指定了O_CREAT,并且文件已存在,则出错返回。</li><li>O_TRUNC 如果文件已存在,并且以只写或可读可写方式打开,则将其长度截断(Trun-<br>cate)为0字节。</li><li>O_NONBLOCK 对于设备文件,以O_NONBLOCK方式打开可以做非阻塞I/O(Nonblock I/<br>O)，后续博客详细了解阻塞和非阻塞代码编程</li></ul><p>权限位 mode</p><p>可以用八进制数表示,比如0644表示-rw-r-r–,也可以用S_IRUSR、S_IWUSR等宏定义按位或起来表示,详见open(2)的Man Page。<br>注意文件权限由open的mode参数和当前进程的umask掩码共同决定。</p><pre><code>// 查看shell当前umask值allies@allies:~$ umask0002</code></pre><p>用touch命令创建一个文件时,创建权限是0666,而touch进程继承了Shell进程的umask<br>掩码,所以最终的文件权限是0666&amp;∼0002=0664</p><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><pre><code>#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);</code></pre><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>从文件描述符 fd 中读取 count 字节的数据并放入从 buf 开始的缓冲区中</p><h5 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code>fd： 文件唯一描述符buf： 缓冲区数组起始地址count： 读取文件大小</code></pre><p>返回值： 成功返回读取到的字节大小，失败返回-1，并置位 errno。</p><pre><code>EINTR  在读取到数据以前调用被信号所中断.EAGAIN 使用 O_NONBLOCK 标志指定了非阻塞式输入输出,但当前没有数据可读.EFAULT buf 超出用户可访问的地址空间.具体查看 Man Page。</code></pre><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><p>在一个文件描述符上执行写操作</p><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><pre><code>#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t count);</code></pre><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>write 向文件描述符 fd 所引用的文件中写入从 buf 开始的缓冲区中 count 字节的数据。POSIX规定，当使用了write()之后再使用 read()，那么读取到的应该是更新后的数据。</p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>write 向文件描述符 fd 所引用的文件中写入 从 buf 开始的缓冲区中 count 字节的数据。POSIX规定,当使用了write()之后再使用 read(),那么读取到的应该是更新后的数据.失败返回-1，并置位errno</p><pre><code>EBADF  fd 不是一个合法的文件描述符或者没有以写方式打开EINVAL fd 所指向的对象不可写EFAULT buf 不在用户可访问地址空间内EAGAIN 读操作阻塞,但使用 O_NONBLOCK 指定了非阻塞式输入输出EINTR  在写数据以前调用被信号中断具体查看 Man Page</code></pre><h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>关闭一个文件描述符</p><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><pre><code>#include &lt;unistd.h&gt;int close(int fd);</code></pre><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>close 关闭一个文件描述符,使它不在指向任何文件和可以在新的文件操作中被再次使用。任何与此文件相关联的以及程序所拥有的锁,都会被删除 (忽略那些持有锁的文件描述符)<br>假如 fd 是最后一个文件描述符与此资源相关联,则这个资源将被释放。若此描述符是最后一个引用到此文件上的,则文件将使用 unlink(2) 删除。</p><h5 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h5><p>fd： 需要关闭文件的文件描述符</p><h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h5><p>close 返回 0 表示成功，或者 -1 表示有错误发生，置位 errno</p><pre><code>EBADF  fd 不是一个有效的已被打开的文件的描述符EINTR  函数 close() 调用被一信号中断EIO    I/O 有错误发生</code></pre><h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><p>ioctl用于向设备发控制和配置命令,有些命令也需要读写一些数据,但这些数据是<br>不能用read/write读写的,称为Out-of-band数据。也就是说,read/write读写的数据是<br>in-band数据,是I/O操作的主体,而ioctl命令传送的是控制信息,其中的数据是辅助的数<br>据。例如,在串口线上收发数据通过read/write操作,而串口的波特率、校验位、停止位通<br>过ioctl设置,A/D转换的结果通过read读取,而A/D转换的精度和工作频率通过ioctl设置。</p><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><pre><code>#include &lt;sys/ioctl.h&gt;int ioctl(int d, int request, ...);</code></pre><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>d是某个设备的文件描述符。request是ioctl的命令,可变参数取决于request,通常是<br>一个指向变量或结构体的指针。若出错则返回-1,若成功则返回其他值,返回值也是取决于<br>request。</p><h5 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h5><p>调用成功，返回 0 。出错返回 -1 ，置位 errno</p><pre><code>EBADF  fd 不是一个有效的文件描述符EFAULT 参数引用内存溢出EINVAL 无效request或参数更多参考 Man Page</code></pre><p>ioctl提供了一个用于控制设备及其描述行为和配置底层的服务的接口。终端文件描述符、套接字都可以定义他们的ioctl，具体需要参考特定设备的手册。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code>#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include&lt;string.h&gt;int main(int argc, char* argv[]){    printf(&quot;argc = %d\n&quot;, argc);    printf(&quot;argv = %s\n&quot;,argv[1]);    if(argc&lt;2)    {        printf(&quot;open file need  args!\n&quot;);        exit(1);    }    //置位创建文件权限    umask(0000);    int fd = -1;    // 打开文件，不存在创建，并且指定读写方式    fd = open(argv[1],O_CREAT | O_RDWR, 0777);    char buf[512] = &quot;This is a test file!&quot;;    // 将字符数组写入文件中    int size = write(fd, buf,strlen(buf));    printf(&quot;write size = %d\n&quot;,size);    printf(&quot;fd = %d\n&quot;,fd);    close(fd);    // 再次打开用户输入的文件    fd = open(argv[1],O_RDONLY);    // 重新读取文件中的内容    size = read(fd,buf,sizeof(buf));    printf(&quot;size = %d\n&quot;,size);    printf(&quot;read : %s\n&quot;,buf);    close(fd);    return 0;}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇文章为本人第一次接触linux系统编程所学习的，内容设计最直接的文件io操作。文章中的大部分原型代码都可以通过 Linux 自带的 Man Page 进行翻阅。限于篇幅，后续文章会对文件操作的阻塞个非阻塞进行进一步的了解。</p><p><a href="https://www.cnblogs.com/wangkeqin/p/9226825.html" target="_blank" rel="noopener">参考博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析之存储系统启动流程MountService模块</title>
      <link href="/FuckCode/2018/09/28/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8BMountService%E6%A8%A1%E5%9D%97/"/>
      <url>/FuckCode/2018/09/28/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8BMountService%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p><strong>上篇我们介绍了Android的存储系统中native层的Vold的启动流程，Vold在init进程中通过init脚本进行启动，而MountService则是在Java的服务总站SystemServer中配置启动的，下面我们就来看一下Java层的MountService是如何启动的。</strong></p><a id="more"></a><h1 id="MountService启动流程"><a href="#MountService启动流程" class="headerlink" title="MountService启动流程"></a>MountService启动流程</h1><p>Java层的MountService服务是在SystemServer中配置的，我们来分析一下其启动流程。</p><h2 id="SystemServer启动配置"><a href="#SystemServer启动配置" class="headerlink" title="SystemServer启动配置"></a>SystemServer启动配置</h2><pre><code>private static final String MOUNT_SERVICE_CLASS = &quot;com.android.server.MountService$Lifecycle&quot;;private void startOtherServices() {    ...    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {        if (!disableStorage &amp;&amp;            !&quot;0&quot;.equals(SystemProperties.get(&quot;system_init.startmountservice&quot;))) {            try {                /*                 * NotificationManagerService is dependant on MountService,                 * (for media / usb notifications) so we must start MountService first.                 */                //启动MountService服务                mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);                //等价new IMountService.Stub.Proxy()，即获取MountService的proxy对象                mountService = IMountService.Stub.asInterface(                        ServiceManager.getService(&quot;mount&quot;));            } catch (Throwable e) {                reportWtf(&quot;starting Mount Service&quot;, e);            }        }    }    ...}</code></pre><p>这里可以看出，启动MountService并非直接启动，而是通过其静态内部类Lifecycle实现启动，下面我们看一下其内部静态类的实现。</p><h2 id="静态内部类Lifecycle"><a href="#静态内部类Lifecycle" class="headerlink" title="静态内部类Lifecycle"></a>静态内部类Lifecycle</h2><pre><code>// Lifecycle继承SystemService，受制于父类的生命周期方法回调，其为MountService的内部静态类，控制MountService的实例化操作public static class Lifecycle extends SystemService {    private MountService mMountService;    public Lifecycle(Context context) {        super(context);    }    @Override    public void onStart() {        //创建MountService对象【见小节2.3】        mMountService = new MountService(getContext());        //登记Binder服务        publishBinderService(&quot;mount&quot;, mMountService);    }    // 由SystenServer启动到指定阶段进行回调，其内部由mServices持有    @Override    public void onBootPhase(int phase) {        // 由于MountService的内部Lifecycle已添加SystemServiceManager的mServices服务列表；        // 系统启动到PHASE_ACTIVITY_MANAGER_READY时会回调mServices中的onBootPhase方法        if (phase == SystemService.PHASE_ACTIVITY_MANAGER_READY) {            mMountService.systemReady();        }    }    ...}</code></pre><p>静态内部类Lifecycle中实现MountService的初始化操作，然后通过publishBinderService将新建的MountService添加到服务列表中。</p><h2 id="MountService初始化"><a href="#MountService初始化" class="headerlink" title="MountService初始化"></a>MountService初始化</h2><p>MountService在其静态内部类LifeCycle中进行初始化，具体如下：</p><pre><code>public MountService(Context context) {    sSelf = this;    mContext = context;    //FgThread线程名为“&quot;android.fg&quot;，创建IMountServiceListener回调方法（1线程）    mCallbacks = new Callbacks(FgThread.get().getLooper());    // XXX: This will go away soon in favor of IMountServiceObserver    //获取PKMS的Client端对象    mPms = (PackageManagerService) ServiceManager.getService(&quot;package&quot;);    //创建“MountService”线程（2线程）    HandlerThread hthread = new HandlerThread(TAG);    hthread.start();    mHandler = new MountServiceHandler(hthread.getLooper());    // Add OBB Action Handler to MountService thread.    //IoThread线程名为&quot;android.io&quot;，创建OBB操作的handler（3线程）    mObbActionHandler = new ObbActionHandler(IoThread.get().getLooper());    // Initialize the last-fstrim tracking if necessary    File dataDir = Environment.getDataDirectory();    File systemDir = new File(dataDir, &quot;system&quot;);    mLastMaintenanceFile = new File(systemDir, LAST_FSTRIM_FILE);    //判断/data/system/last-fstrim文件，不存在则创建，存在则更新最后修改时间    if (!mLastMaintenanceFile.exists()) {        // Not setting mLastMaintenance here means that we will force an        // fstrim during reboot following the OTA that installs this code.        try {            (new FileOutputStream(mLastMaintenanceFile)).close();        } catch (IOException e) {            Slog.e(TAG, &quot;Unable to create fstrim record &quot; + mLastMaintenanceFile.getPath());        }    } else {        mLastMaintenance = mLastMaintenanceFile.lastModified();    }    mSettingsFile = new AtomicFile(            new File(Environment.getSystemSecureDirectory(), &quot;storage.xml&quot;));    synchronized (mLock) {        readSettingsLocked();    }    //将MountServiceInternalImpl登记到sLocalServiceObjects，区别Binder的RemoteService    LocalServices.addService(MountServiceInternal.class, mMountServiceInternal);    /*     * Create the connection to vold with a maximum queue of twice the     * amount of containers we&apos;d ever expect to have. This keeps an     * &quot;asec list&quot; from blocking a thread repeatedly.     */    //创建用于VoldConnector的NDC(native守护进程连接器)对象    mConnector = new NativeDaemonConnector(this, &quot;vold&quot;, MAX_CONTAINERS * 2, VOLD_TAG, 25,            null);    mConnector.setDebug(true);    //创建线程名为&quot;VoldConnector&quot;的线程，用于跟vold通信,启动（4线程）    Thread thread = new Thread(mConnector, VOLD_TAG);    thread.start();    // Reuse parameters from first connector since they are tested and safe    //创建用于CryptdConnector工作的NDC对象,同上面的一样    mCryptConnector = new NativeDaemonConnector(this, &quot;cryptd&quot;,            MAX_CONTAINERS * 2, CRYPTD_TAG, 25, null);    mCryptConnector.setDebug(true);    //创建线程名为&quot;CryptdConnector&quot;的线程，用于加密（5线程）    Thread crypt_thread = new Thread(mCryptConnector, CRYPTD_TAG);    crypt_thread.start();    //注册监听用户添加、删除的广播    final IntentFilter userFilter = new IntentFilter();    userFilter.addAction(Intent.ACTION_USER_ADDED);    userFilter.addAction(Intent.ACTION_USER_REMOVED);    mContext.registerReceiver(mUserReceiver, userFilter, null, mHandler);    //内部私有volume的路径为/data，该volume通过dumpsys mount是不会显示的    addInternalVolume();    // Add ourself to the Watchdog monitors if enabled.    if (WATCHDOG_ENABLE) {        Watchdog.getInstance().addMonitor(this);    }}</code></pre><p>代码内容比较多，我们梳理一下其主要工作：</p><ul><li>创建线程 Callbacks，线程名android.fg</li><li>创建线程 HandlerThread，线程名MountService，并开启</li><li>创建线程 ObbActionHandler，线程名android.io</li><li>创建 NativeDaemonConnector对象，线程 thread并开启，线程名VoldConnector</li><li>创建 NativeDaemonConnector对象，线程 crypt_thread并开启，线程名CryptdConnector</li><li>注册广播和其他操作</li></ul><p>这里设计线程数量比较多，新建了三个线程：MountService，VoldConnector，CryptdConnector；还有两个额外的系统进程中的线程android.fg和android.io</p><h3 id="Callbacke"><a href="#Callbacke" class="headerlink" title="Callbacke"></a>Callbacke</h3><pre><code>private static class Callbacks extends Handler {    private static final int MSG_STORAGE_STATE_CHANGED = 1;    private static final int MSG_VOLUME_STATE_CHANGED = 2;    private static final int MSG_VOLUME_RECORD_CHANGED = 3;    private static final int MSG_VOLUME_FORGOTTEN = 4;    private static final int MSG_DISK_SCANNED = 5;    private static final int MSG_DISK_DESTROYED = 6;    //通过 register() 方法添加 IMountServiceListener 对象信息到 mCallbacks 成员变量。    // RemoteCallbackList 的内部类 Callback 继承于 IBinder.DeathRecipient，这是死亡通知    //当 binder 服务端进程死亡后，回调 binderDied 方法通知 binder 客户端进行相应地处理    private final RemoteCallbackList&lt;IMountServiceListener&gt;            mCallbacks = new RemoteCallbackList&lt;&gt;();    public Callbacks(Looper looper) {        super(looper);    }    public void register(IMountServiceListener callback) {        mCallbacks.register(callback);    }    public void unregister(IMountServiceListener callback) {        mCallbacks.unregister(callback);    }    @Override    public void handleMessage(Message msg) {        final SomeArgs args = (SomeArgs) msg.obj;        final int n = mCallbacks.beginBroadcast();        for (int i = 0; i &lt; n; i++) {            final IMountServiceListener callback = mCallbacks.getBroadcastItem(i);            try {                invokeCallback(callback, msg.what, args);            } catch (RemoteException ignored) {            }        }        mCallbacks.finishBroadcast();        args.recycle();    }    private void invokeCallback(IMountServiceListener callback, int what, SomeArgs args)            throws RemoteException {        switch (what) {            case MSG_STORAGE_STATE_CHANGED: {                callback.onStorageStateChanged((String) args.arg1, (String) args.arg2,                        (String) args.arg3);                break;            }            ...        }    }    private void notifyStorageStateChanged(String path, String oldState, String newState) {        final SomeArgs args = SomeArgs.obtain();        args.arg1 = path;        args.arg2 = oldState;        args.arg3 = newState;        obtainMessage(MSG_STORAGE_STATE_CHANGED, args).sendToTarget();    }    ...}</code></pre><p>Callback继承自handler，其中Looper采用的是系统进程线程android.fg，其内部还有一个成员变量mCallbacks，通过register()方法添加IMountServiceListener对象信息到mCallbacks成员变量。RemoteCallbackList的内部类Callback继承于IBinder.DeathRecipient，很显然这是死亡通知，当binder服务端进程死亡后，回调binderDied方法通知binder客户端进行相应地处理。</p><h3 id="MountServiceHandler"><a href="#MountServiceHandler" class="headerlink" title="MountServiceHandler"></a>MountServiceHandler</h3><pre><code>class MountServiceHandler extends Handler {    public MountServiceHandler(Looper looper) {        super(looper);    }    @Override    public void handleMessage(Message msg) {        switch (msg.what) {            case H_SYSTEM_READY: {                // 处理system_server主线程发送 H_SYSTEM_READY 消息                handleSystemReady();                break;            }            case H_DAEMON_CONNECTED: {                // Daemon-Socket 已经建立连接                handleDaemonConnected();                break;            }            ...            case H_VOLUME_MOUNT: {                final VolumeInfo vol = (VolumeInfo) msg.obj;                if (isMountDisallowed(vol)) {                    Slog.i(TAG, &quot;Ignoring mount &quot; + vol.getId() + &quot; due to policy&quot;);                    break;                }                try {                    mConnector.execute(&quot;volume&quot;, &quot;mount&quot;, vol.id, vol.mountFlags,                            vol.mountUserId);                } catch (NativeDaemonConnectorException ignored) {                }                break;            }            ...        }    }}</code></pre><p>Handler主线程，负责处理所有的UI事件。</p><h2 id="NativeDaemonConnector初始化"><a href="#NativeDaemonConnector初始化" class="headerlink" title="NativeDaemonConnector初始化"></a>NativeDaemonConnector初始化</h2><pre><code>NativeDaemonConnector(INativeDaemonConnectorCallbacks callbacks, String socket,        int responseQueueSize, String logTag, int maxLogSize, PowerManager.WakeLock wl) {    this(callbacks, socket, responseQueueSize, logTag, maxLogSize, wl,            FgThread.get().getLooper());}// mLooper 为 FgThread.get().getLooper()，即运行在 ”android.fg” 线程NativeDaemonConnector(INativeDaemonConnectorCallbacks callbacks, String socket,        int responseQueueSize, String logTag, int maxLogSize, PowerManager.WakeLock wl,        Looper looper) {    mCallbacks = callbacks;    //socket名为&quot;vold&quot;    mSocket = socket;    // mResponseQueue 对象中成员变量 mPendingCmds 数据类型为 LinkedList    //记录着 vold 进程上报的响应事件，事件个数上限为500    mResponseQueue = new ResponseQueue(responseQueueSize);    mWakeLock = wl;    if (mWakeLock != null) {        mWakeLock.setReferenceCounted(true);    }    mLooper = looper;    mSequenceNumber = new AtomicInteger(0);    // TAG 为&quot;VoldConnector&quot;    TAG = logTag != null ? logTag : &quot;NativeDaemonConnector&quot;;    mLocalLog = new LocalLog(maxLogSize);}</code></pre><p>NativeDaemonConnector使用的线程为android.fg，其主要负责和Native层Vold进程通过Socket进行痛惜，其中mResponseQueue对象中成员变量mPendingCmds数据类型为LinkedList，记录着vold进程上报的响应事件，事件个数上限为500。</p><p>在线程VoldConnector中建立了名为vold的socket的客户端，通过循环方式不断监听Vold服务端发送过来的消息。 另外，同理还有一个线程CryptdConnector也采用类似的方式，建立了cryptd的socket客户端，监听Vold中另个线程发送过来的消息。</p><h3 id="NDC-gt-run"><a href="#NDC-gt-run" class="headerlink" title="NDC-&gt;run"></a>NDC-&gt;run</h3><p>接下来就是NDC的start进入run方法，如下；</p><pre><code>@Overridepublic void run() {    mCallbackHandler = new Handler(mLooper, this);    while (true) {        try {            //监听vold的socket            listenToSocket();        } catch (Exception e) {            loge(&quot;Error in NativeDaemonConnector: &quot; + e);            SystemClock.sleep(5000);        }    }}</code></pre><h3 id="listenToSocket"><a href="#listenToSocket" class="headerlink" title="listenToSocket"></a>listenToSocket</h3><pre><code>// 监听 socket 内数据private void listenToSocket() throws IOException {    LocalSocket socket = null;    try {        socket = new LocalSocket();        LocalSocketAddress address = determineSocketAddress();        // 建立与&quot;/dev/socket/vold&quot;的socket连接        socket.connect(address);        InputStream inputStream = socket.getInputStream();        synchronized (mDaemonLock) {            mOutputStream = socket.getOutputStream();        }        // 建立连接后，回调 MS.onDaemonConnected        mCallbacks.onDaemonConnected();        byte[] buffer = new byte[BUFFER_SIZE];        int start = 0;        while (true) {            int count = inputStream.read(buffer, start, BUFFER_SIZE - start);            if (count &lt; 0) {                loge(&quot;got &quot; + count + &quot; reading with start = &quot; + start);                break;            }            // Add our starting point to the count and reset the start.            count += start;            start = 0;            for (int i = 0; i &lt; count; i++) {                if (buffer[i] == 0) {                    // Note - do not log this raw message since it may contain                    // sensitive data                    final String rawEvent = new String(                            buffer, start, i - start, StandardCharsets.UTF_8);                    boolean releaseWl = false;                    try {                        //解析 socket 服务端发送的 event                        final NativeDaemonEvent event = NativeDaemonEvent.parseRawEvent(                                rawEvent);                        log(&quot;RCV &lt;- {&quot; + event + &quot;}&quot;);                        //当事件的响应码区间为[600,700)，则发送消息交由 mCallbackHandler 处理                        if (event.isClassUnsolicited()) {                            // TODO: migrate to sending NativeDaemonEvent instances                            if (mCallbacks.onCheckHoldWakeLock(event.getCode())                                    &amp;&amp; mWakeLock != null) {                                mWakeLock.acquire();                                releaseWl = true;                            }                            if (mCallbackHandler.sendMessage(mCallbackHandler.obtainMessage(                                    event.getCode(), event.getRawEvent()))) {                                releaseWl = false;                            }                        } else {                            // 对于其他的响应码则添加到 mResponseQueue 队列                            // 该方法便能触发 ResponseQueue.poll 阻塞操作继续往下执行                            mResponseQueue.add(event.getCmdNumber(), event);                        }                    } catch (IllegalArgumentException e) {                        log(&quot;Problem parsing message &quot; + e);                    } finally {                        if (releaseWl) {                            mWakeLock.acquire();                        }                    }                    start = i + 1;                }            }            if (start == 0) {                log(&quot;RCV incomplete&quot;);            }            // We should end at the amount we read. If not, compact then            // buffer and read again.            if (start != count) {                final int remaining = BUFFER_SIZE - start;                System.arraycopy(buffer, start, buffer, 0, remaining);                start = remaining;            } else {                start = 0;            }        }    } catch (IOException ex) {        loge(&quot;Communications error: &quot; + ex);        throw ex;    } finally {        //收尾清理类工作，关闭mOutputStream, socket        synchronized (mDaemonLock) {            if (mOutputStream != null) {                try {                    loge(&quot;closing stream for &quot; + mSocket);                    mOutputStream.close();                } catch (IOException e) {                    loge(&quot;Failed closing output stream: &quot; + e);                }                mOutputStream = null;            }        }        try {            if (socket != null) {                socket.close();            }        } catch (IOException ex) {            loge(&quot;Failed closing socket: &quot; + ex);        }    }}</code></pre><p>内容比较多，这里也是比较重要的部分，建立连接后，便会进行onDaemonConnected回调。之后进入死循环不断监听，调用NativeDaemonEvent.parseRawEvent解析Socket内的元数据，根据事件类型进行分类处理。当事件的响应码区间为[600,700)，则发送消息交由 mCallbackHandler 处理，其他的则添加到 mResponseQueue 队列，触发 ResponseQueue.poll 阻塞操作继续往下执行。最终在finally释放锁和清理工作。</p><h3 id="onDaemonConnected"><a href="#onDaemonConnected" class="headerlink" title="onDaemonConnected"></a>onDaemonConnected</h3><pre><code>// 主线程发送消息 H_DAEMON_CONNECTED 给线程 MountService// 该线程收到消息后调用 MountServiceHandler 的 handleMessage()@Overridepublic void onDaemonConnected() {    mDaemonConnected = true;    mHandler.obtainMessage(H_DAEMON_CONNECTED).sendToTarget();}</code></pre><p>其通过handler，最终调用到handleDaemonConnected，如下：</p><h3 id="MountService-handleDaemonConnected"><a href="#MountService-handleDaemonConnected" class="headerlink" title="MountService.handleDaemonConnected"></a>MountService.handleDaemonConnected</h3><pre><code>private void handleDaemonConnected() {    synchronized (mLock) {        // 重置清理工作        resetIfReadyAndConnectedLocked();    }    /*     * Now that we&apos;ve done our initialization, release     * the hounds!     */    // 类型为 CountDownLatch，用于多线程同步，阻塞await()直到计数器为零    mConnectedSignal.countDown();    if (mConnectedSignal.getCount() != 0) {        // More daemons need to connect        return;    }    // On an encrypted device we can&apos;t see system properties yet, so pull    // the system locale out of the mount service.    if (&quot;&quot;.equals(SystemProperties.get(&quot;vold.encrypt_progress&quot;))) {        copyLocaleFromMountService();    }    // Let package manager load internal ASECs.    //调用PMS来加载ASECs    mPms.scanAvailableAsecs();    // Notify people waiting for ASECs to be scanned that it&apos;s done.    //用于通知ASEC扫描已完成    mAsecsScanned.countDown();}</code></pre><h4 id="mResponseQueue-add"><a href="#mResponseQueue-add" class="headerlink" title="mResponseQueue.add"></a>mResponseQueue.add</h4><pre><code>public void add(int cmdNum, NativeDaemonEvent response) {        PendingCmd found = null;        synchronized (mPendingCmds) {            for (PendingCmd pendingCmd : mPendingCmds) {                if (pendingCmd.cmdNum == cmdNum) {                    found = pendingCmd;                    break;                }            }            //没有找到则创建相应的PendingCmd            if (found == null) {                // 没有找到,在添加之前,确保队列容量不溢出                while (mPendingCmds.size() &gt;= mMaxCount) {                    Slog.e(&quot;NativeDaemonConnector.ResponseQueue&quot;,                            &quot;more buffered than allowed: &quot; + mPendingCmds.size() +                            &quot; &gt;= &quot; + mMaxCount);                    // let any waiter timeout waiting for this                    PendingCmd pendingCmd = mPendingCmds.remove();                    Slog.e(&quot;NativeDaemonConnector.ResponseQueue&quot;,                            &quot;Removing request: &quot; + pendingCmd.logCmd + &quot; (&quot; +                            pendingCmd.cmdNum + &quot;)&quot;);                }                found = new PendingCmd(cmdNum, null);                mPendingCmds.add(found);            }            found.availableResponseCount++;            // if a matching remove call has already retrieved this we can remove this            // instance from our list            if (found.availableResponseCount == 0) mPendingCmds.remove(found);        }        try {            found.responses.put(response);        } catch (InterruptedException e) { }    }</code></pre><p>mResponseQueue.add()，通过该方法便能触发ResponseQueue.poll阻塞操作继续往下执行。</p><p>到此,MountService与NativeDaemonConnector都已经启动，之前我们看到MountService内部静态类LifeCycle继承自SystemService，那么接下来到系统启动到达阶段PHASE_ACTIVITY_MANAGER_READY，则调用到其onBootPhase方法。</p><h2 id="Lifecycle-gt-onBootPhase"><a href="#Lifecycle-gt-onBootPhase" class="headerlink" title="Lifecycle-&gt;onBootPhase"></a>Lifecycle-&gt;onBootPhase</h2><pre><code>// 由SystenServer启动到指定阶段进行回调，其内部由mServices持有    @Override    public void onBootPhase(int phase) {        // 由于MountService的内部Lifecycle已添加SystemServiceManager的mServices服务列表；        // 系统启动到PHASE_ACTIVITY_MANAGER_READY时会回调mServices中的onBootPhase方法        if (phase == SystemService.PHASE_ACTIVITY_MANAGER_READY) {            mMountService.systemReady();        }    }</code></pre><p>由SystemService统一管理其声明流程，之后调用systemReady方法，如下：</p><h3 id="systemReady"><a href="#systemReady" class="headerlink" title="systemReady"></a>systemReady</h3><pre><code>private void systemReady() {    mSystemReady = true;    // 此处 mHandler = new MountServiceHandler(hthread.getLooper())    // 采用的是线程 ”MountService” 中的 Looper    // system_server 主线程通过 handler 向线程 ”MountService” 发送 H_SYSTEM_READY 消息    mHandler.obtainMessage(H_SYSTEM_READY).sendToTarget();}</code></pre><p>MountService的systemReady通过Handler发送消息到MountServiceHandler中进行处理，其收到消息处理后进入handleSystemReady方法</p><h3 id="handleSystemReady"><a href="#handleSystemReady" class="headerlink" title="handleSystemReady"></a>handleSystemReady</h3><pre><code>private void handleSystemReady() {    synchronized (mLock) {        // 重置...        resetIfReadyAndConnectedLocked();    }    // Start scheduling nominally-daily fstrim operations    // 计划执行日常的 fstrim 操作【】    MountServiceIdler.scheduleIdlePass(mContext);}</code></pre><p>主要做了两件事情，一件事重置操作，一件事执行fstrim操作。</p><h3 id="resetIfReadyAndConnectedLocked"><a href="#resetIfReadyAndConnectedLocked" class="headerlink" title="resetIfReadyAndConnectedLocked"></a>resetIfReadyAndConnectedLocked</h3><pre><code>private void resetIfReadyAndConnectedLocked() {    Slog.d(TAG, &quot;Thinking about reset, mSystemReady=&quot; + mSystemReady            + &quot;, mDaemonConnected=&quot; + mDaemonConnected);    if (mSystemReady &amp;&amp; mDaemonConnected) {        killMediaProvider();        // Mstar Android Patch Begin        new Thread() {            public void run() {                try {                    mConnector.execute(&quot;volume&quot;, &quot;reset&quot;);                    // Tell vold about all existing and started users                    //告知所有已经存在和启动的 users                    final UserManager um = mContext.getSystemService(UserManager.class);                    final List&lt;UserInfo&gt; users = um.getUsers();                    for (UserInfo user : users) {                        mConnector.execute(&quot;volume&quot;, &quot;user_added&quot;, user.id, user.serialNumber);                    }                    for (int userId : mStartedUsers) {                        mConnector.execute(&quot;volume&quot;, &quot;user_started&quot;, userId);                    }                } catch (NativeDaemonConnectorException e) {                    Slog.w(TAG, &quot;Failed to reset vold&quot;, e);                }            }        }.start();        // Mstar Android Patch End    }}</code></pre><p>首先检测系统是否启动完毕，是否和Vold建立连接，之后开启线程通过mConnector执行execute(“volume”, “reset”)，并再次通过mConnector告知所有的用户user_added和user_started。</p><h3 id="NDC-gt-execute"><a href="#NDC-gt-execute" class="headerlink" title="NDC-&gt;execute"></a>NDC-&gt;execute</h3><p>NativeDaemonConnector执行execute经过层层调用，最终走到executeForList，此时命令执行超时时长为1分钟，具体如下：</p><pre><code>public NativeDaemonEvent[] executeForList(long timeoutMs, String cmd, Object... args)        throws NativeDaemonConnectorException {    final long startTime = SystemClock.elapsedRealtime();    final ArrayList&lt;NativeDaemonEvent&gt; events = Lists.newArrayList();    final StringBuilder rawBuilder = new StringBuilder();    final StringBuilder logBuilder = new StringBuilder();    // mSequenceNumber初始化值为0，每执行一次该方法则进行加1操作    final int sequenceNumber = mSequenceNumber.incrementAndGet();    makeCommand(rawBuilder, logBuilder, sequenceNumber, cmd, args);    //例如：“7 volume mount”    final String rawCmd = rawBuilder.toString();    final String logCmd = logBuilder.toString();    log(&quot;SND -&gt; {&quot; + logCmd + &quot;}&quot;);    synchronized (mDaemonLock) {        if (mOutputStream == null) {            throw new NativeDaemonConnectorException(&quot;missing output stream&quot;);        } else {            try {                //将 cmd 写入到 socket 的输出流                mOutputStream.write(rawCmd.getBytes(StandardCharsets.UTF_8));            } catch (IOException e) {                throw new NativeDaemonConnectorException(&quot;problem sending command&quot;, e);            }        }    }    NativeDaemonEvent event = null;    do {        event = mResponseQueue.remove(sequenceNumber, timeoutMs, logCmd);        if (event == null) {            loge(&quot;timed-out waiting for response to &quot; + logCmd);            throw new NativeDaemonTimeoutException(logCmd, event);        }        if (VDBG) log(&quot;RMV &lt;- {&quot; + event + &quot;}&quot;);        events.add(event);        // 当收到的事件响应码属于[100,200)区间，则继续等待后续事件上报    } while (event.isClassContinue());    final long endTime = SystemClock.elapsedRealtime();    //对于执行时间超过500ms则会记录到log    if (endTime - startTime &gt; WARN_EXECUTE_DELAY_MS) {        loge(&quot;NDC Command {&quot; + logCmd + &quot;} took too long (&quot; + (endTime - startTime) + &quot;ms)&quot;);    }    if (event.isClassClientError()) {        throw new NativeDaemonArgumentException(logCmd, event);    }    if (event.isClassServerError()) {        throw new NativeDaemonFailureException(logCmd, event);    }    return events.toArray(new NativeDaemonEvent[events.size()]);}</code></pre><p>其流程也是比较重要的，主要是和Socket进行打交道。首先，将带执行的命令mSequenceNumber执行加1操作，再将cmd(例如7 volume mount)写入到socket的输出流，通知Vold进行处理。然后通过循环与poll机制等待执行底层响应该操作结果，否则直到1分钟超时才结束该方法。即便收到底层的响应码，如果响应码属于[100,200)区间，则继续阻塞等待后续事件上报。</p><h3 id="mResponseQueue-remove"><a href="#mResponseQueue-remove" class="headerlink" title="mResponseQueue.remove"></a>mResponseQueue.remove</h3><p>和上面的add操作相反，这里是将阻塞队列ResponseQueue移除操作，多有操作都是由ReentrantLock同步锁来控制，实现多线程下并发操作。</p><pre><code>public NativeDaemonEvent remove(int cmdNum, long timeoutMs, String logCmd) {    PendingCmd found = null;    synchronized (mPendingCmds) {        // 从mPendingCmds查询cmdNum        for (PendingCmd pendingCmd : mPendingCmds) {            if (pendingCmd.cmdNum == cmdNum) {                found = pendingCmd;                break;            }        }        // 如果已有的mPendingCmds中查询不到，则创建一个新的PendingCmd        if (found == null) {            found = new PendingCmd(cmdNum, logCmd);            mPendingCmds.add(found);        }        found.availableResponseCount--;        // if a matching add call has already retrieved this we can remove this        // instance from our list        if (found.availableResponseCount == 0) mPendingCmds.remove(found);    }    NativeDaemonEvent result = null;    try {        //采用poll轮询方式等待底层上报该事件，直到1分钟超时        //这里用到poll，先来看看responses        result = found.responses.poll(timeoutMs, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {}    if (result == null) {        Slog.e(&quot;NativeDaemonConnector.ResponseQueue&quot;, &quot;Timeout waiting for response&quot;);    }    return result;}</code></pre><ul><li>关于ArrayBlockingQueue可以参考如下链接：</li></ul><p><a href="http://blog.csdn.net/javazejian/article/details/77410889" target="_blank" rel="noopener">ArrayBlockingQueue</a></p><h1 id="MountService总结"><a href="#MountService总结" class="headerlink" title="MountService总结"></a>MountService总结</h1><p>MountService启动方式和其他的Service有点不同，主要是由其静态内部类LifeCycle控制其实例化过程，然后LifeCycle又继承SystemService，从而其受到SystemService的控制，系统启动到Ready阶段便会回调LifeCycle对应的方法，然后由发送消息到MountService进行处理。</p><p>MountService启动时候，自行建立了三个子线程：MountService、VoldConnector、CryptdConnector，其中VoldConnector，CryptdConnector分别对应监听Vold进程中的两个线程，接受他它们传递过来的消息。</p><p>其中重要的NativeDaemonConnector负责和Vold传递来的Socket进行通信，其运行在VoldConnector线程中。同理还有一个NDC运行在CryptdConnecto线程中。</p><p>部分内容参考如下：</p><p><a href="http://gityuan.com/2016/07/17/android-io/" target="_blank" rel="noopener">GitYuan</a></p><p><a href="http://blog.csdn.net/javazejian/article/details/77410889" target="_blank" rel="noopener">AttayBlockingQueue</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析之存储系统启动流程Vold</title>
      <link href="/FuckCode/2018/09/28/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8BVold%E6%A8%A1%E5%9D%97/"/>
      <url>/FuckCode/2018/09/28/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8BVold%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p><strong>Android的存储系统相对来讲还是比较复杂，其中主要包括了native层的Vold以及Java层的MountService。其中Vold在init进程中通过init脚本进行启动，而MountService则是在Java的服务总站SystemServer中配置启动的。它们之间的通信采用的Socket进行，而不是Binder机制，其主要的原因就是架构上比较简单，代码量也少。本文就从启动流程上分析安卓系统中的存储模块是如何加载起来的，下面就让我们直接进入正题。</strong></p><a id="more"></a><h1 id="Vold启动流程"><a href="#Vold启动流程" class="headerlink" title="Vold启动流程"></a>Vold启动流程</h1><p>native层的Vlod进程启动在init.rc脚本中进行配置的，其定义于 /system/core/rootdir/init.rc 中，我们看一下脚本文件内容。</p><h2 id="init脚本相关配置"><a href="#init脚本相关配置" class="headerlink" title="init脚本相关配置"></a>init脚本相关配置</h2><p>init.rc 脚本配置如下：</p><pre><code>service vold /system/bin/vold \        --blkid_context=u:r:blkid:s0 --blkid_untrusted_context=u:r:blkid_untrusted:s0 \        --fsck_context=u:r:fsck:s0 --fsck_untrusted_context=u:r:fsck_untrusted:s0    class core    socket vold stream 0660 root mount    socket cryptd stream 0660 root mount    ioprio be 2</code></pre><p>脚本文件声明服务 service 为 vold，对应的程序文件路径 /system/bin/vold，系统级 core 核心服务。</p><h2 id="Vold-main"><a href="#Vold-main" class="headerlink" title="Vold.main"></a>Vold.main</h2><p>init进程通过解析上述脚本文件内容，启动对应的Vold进程，进入到vold的main函数中。其函数文件位于 system/vold/main.cpp 中</p><pre><code>// vold 启动时都创建了若干对象int main(int argc, char** argv) {    setenv(&quot;ANDROID_LOG_TAGS&quot;, &quot;*:v&quot;, 1);    android::base::InitLogging(argv, android::base::LogdLogger(android::base::SYSTEM));    ...    VolumeManager *vm;    CommandListener *cl;    CryptCommandListener *ccl;    NetlinkManager *nm;    //解析参数    parse_args(argc, argv);    ...    // Quickly throw a CLOEXEC on the socket we just inherited from init    fcntl(android_get_control_socket(&quot;vold&quot;), F_SETFD, FD_CLOEXEC);    fcntl(android_get_control_socket(&quot;cryptd&quot;), F_SETFD, FD_CLOEXEC);    mkdir(&quot;/dev/block/vold&quot;, 0755);    // 用于cryptfs检查，并mount加密的文件系统    klog_set_level(6);    //创建单例对象 VolumeManager    if (!(vm = VolumeManager::Instance())) {        LOG(ERROR) &lt;&lt; &quot;Unable to create VolumeManager&quot;;        exit(1);    }    //创建单例对象 NetlinkManager    if (!(nm = NetlinkManager::Instance())) {        LOG(ERROR) &lt;&lt; &quot;Unable to create NetlinkManager&quot;;        exit(1);    }    if (property_get_bool(&quot;vold.debug&quot;, false)) {        vm-&gt;setDebug(true);    }    // 创建 CommandListener 对象    cl = new CommandListener();    // 创建 CryptCommandListener 对象    ccl = new CryptCommandListener();    // 将新创建的 CommandListener 对象 sl 赋值给 vm 对象的成员变量 mBroadcaster    vm-&gt;setBroadcaster((SocketListener *) cl);    nm-&gt;setBroadcaster((SocketListener *) cl);    if (vm-&gt;start()) {        PLOG(ERROR) &lt;&lt; &quot;Unable to start VolumeManager&quot;;        exit(1);    }    if (process_config(vm)) {        PLOG(ERROR) &lt;&lt; &quot;Error reading configuration... continuing anyways&quot;;    }    if (nm-&gt;start()) {        PLOG(ERROR) &lt;&lt; &quot;Unable to start NetlinkManager&quot;;        exit(1);    }    coldboot(&quot;/sys/block&quot;);//    coldboot(&quot;/sys/class/switch&quot;);    //启动响应命令的监听器    if (cl-&gt;startListener()) {        PLOG(ERROR) &lt;&lt; &quot;Unable to start CommandListener&quot;;        exit(1);    }    if (ccl-&gt;startListener()) {        PLOG(ERROR) &lt;&lt; &quot;Unable to start CryptCommandListener&quot;;        exit(1);    }    //Vold成为监听线程    while(1) {        sleep(1000);    }    LOG(ERROR) &lt;&lt; &quot;Vold exiting&quot;;    exit(0);}</code></pre><p>上述代码可以看出，Vold.main函数中主要做了以下几件事：</p><ul><li>解析传入参数</li><li>创建 VolumeManager，设置监听并启动</li><li>创建 NetlinkManager，设置监听并启动</li><li>创建 CommandListener</li><li>创建 CryptCommandListener</li><li>循环成为监听线程</li></ul><h3 id="VM流程分析"><a href="#VM流程分析" class="headerlink" title="VM流程分析"></a>VM流程分析</h3><h4 id="VM初始化"><a href="#VM初始化" class="headerlink" title="VM初始化"></a>VM初始化</h4><p>VolumeManager是Vold进程中最重要的几个类之一，其简而言之就是Vold的统筹管理类，代码位于 /system/vold/VolumeBase.cpp 下，我们看一下其初始化流程。</p><pre><code>// 单例模式VolumeManager *VolumeManager::Instance() {    if (!sInstance)        sInstance = new VolumeManager();    return sInstance;}VolumeManager::VolumeManager() {    mDebug = false;    mActiveContainers = new AsecIdCollection();    mBroadcaster = NULL;    mUmsSharingCount = 0;    mSavedDirtyRatio = -1;    // 当UMS获取时，则设置 dirty ratio 为 0    mUmsDirtyRatio = 0;}</code></pre><p>VolumeManager类内部通过单例模式进行创建，创建同时创建AsecIdCollection负责aesc文件的收集，从析构函数中可以看出其被手动删除释放。下面便是设置监听。</p><h4 id="VM-gt-setBroadcaster"><a href="#VM-gt-setBroadcaster" class="headerlink" title="VM-&gt;setBroadcaster"></a>VM-&gt;setBroadcaster</h4><p>VolumeManager设置监听后，VM才可以开启，并且监听线程才能启动。其代码位于头文件中。</p><pre><code>void setBroadcaster(SocketListener *sl) { mBroadcaster = sl; }</code></pre><p>代码中，将CommandListener 对象sl赋值给 mBroadcaster。</p><h4 id="VM-gt-start"><a href="#VM-gt-start" class="headerlink" title="VM-&gt;start"></a>VM-&gt;start</h4><p>VolumeManager设置监听后，便开启工作。</p><pre><code>int VolumeManager::start() {    // Always start from a clean slate by unmounting everything in    // directories that we own, in case we crashed.    // 卸载所有设备,已提供最干净的环境    unmountAll();    // Assume that we always have an emulated volume on internal    // storage; the framework will decide if it should be mounted.    CHECK(mInternalEmulated == nullptr);    // 创建Emulated内部存储    // 其类型为 EmulatedVolume，设备路径为/data/media    // id和label为“emulated”，mMountFlags=0    // EmulatedVolume 继承于 VolumeBase    mInternalEmulated = std::shared_ptr&lt;android::vold::VolumeBase&gt;(            new android::vold::EmulatedVolume(&quot;/data/media&quot;));    // EmulatedVolume继承VolumeBase    mInternalEmulated-&gt;create();    return 0;}</code></pre><p>VolumeManager开启时候，会线卸载所有设备，保证干净的环境，之后在重新建立存储化境。</p><h5 id="unmountAll卸载设备"><a href="#unmountAll卸载设备" class="headerlink" title="unmountAll卸载设备"></a>unmountAll卸载设备</h5><pre><code>int VolumeManager::unmountAll() {    std::lock_guard&lt;std::mutex&gt; lock(mLock);    // First, try gracefully unmounting all known devices    // 1.卸载内部存储    if (mInternalEmulated != nullptr) {        mInternalEmulated-&gt;unmount();    }    // 2.卸载外部存储    for (auto disk : mDisks) {        disk-&gt;unmountAll();    }    // Worst case we might have some stale mounts lurking around, so    // force unmount those just to be safe.    // 有可能存在严重的潜在的旧的挂载设备存在,强力卸载以保证安全    FILE* fp = setmntent(&quot;/proc/mounts&quot;, &quot;r&quot;);    if (fp == NULL) {        SLOGE(&quot;Error opening /proc/mounts: %s&quot;, strerror(errno));        return -errno;    }    // Some volumes can be stacked on each other, so force unmount in    // reverse order to give us the best chance of success.    std::list&lt;std::string&gt; toUnmount;    mntent* mentry;    while ((mentry = getmntent(fp)) != NULL) {        if (strncmp(mentry-&gt;mnt_dir, &quot;/mnt/&quot;, 5) == 0                || strncmp(mentry-&gt;mnt_dir, &quot;/storage/&quot;, 9) == 0) {            toUnmount.push_front(std::string(mentry-&gt;mnt_dir));        }    }    endmntent(fp);    for (auto path : toUnmount) {        SLOGW(&quot;Tearing down stale mount %s&quot;, path.c_str());        android::vold::ForceUnmount(path);    }    return 0;}</code></pre><p>unmountAll中主要卸载系统内部和外部设备，以提供最干净的设备环境。先卸载内部设备，在遍历外部设备，遍历卸载，之后再针对其他情况卸载而外干扰设备。</p><p>其中mInternalEmulated设备为EmulatedVolume类型，其继承了父类VolumeBase，其子类调用unmount方法，优先走父类VolumeBase的方法，其内容如下：</p><pre><code>status_t VolumeBase::unmount() {    if (mState != State::kMounted) {        LOG(WARNING) &lt;&lt; getId() &lt;&lt; &quot; unmount requires state mounted&quot;;        return -EBUSY;    }    // 设置状态，651，5    setState(State::kEjecting);    for (auto vol : mVolumes) {        if (vol-&gt;destroy()) {            LOG(WARNING) &lt;&lt; getId() &lt;&lt; &quot; failed to destroy &quot; &lt;&lt; vol-&gt;getId()                    &lt;&lt; &quot; stacked above&quot;;        }    }    mVolumes.clear();    status_t res = doUnmount();    // 设置状态，发送 651，0    setState(State::kUnmounted);    return res;}</code></pre><p>父类的上述方法中，首先设置状态，其最终通过VM的方法，向Socket发送命令。其具体代码如下：</p><pre><code>void VolumeBase::setState(State state) {    mState = state;    notifyEvent(ResponseCode::VolumeStateChanged, StringPrintf(&quot;%d&quot;, mState));}void VolumeBase::notifyEvent(int event) {    if (mSilent) return;    // 通过socket向MountService发送创建volume的命令(650)    VolumeManager::Instance()-&gt;getBroadcaster()-&gt;sendBroadcast(event,            getId().c_str(), false);}</code></pre><p>其次是调用子类的doUnmount方法，其对应到实现的子类自己的方法，这里的子类为EmulatedVolume，其对应的实现方法如下：</p><pre><code>status_t EmulatedVolume::doUnmount() {    if (mFusePid &gt; 0) {        kill(mFusePid, SIGTERM);        TEMP_FAILURE_RETRY(waitpid(mFusePid, nullptr, 0));        mFusePid = 0;    }    // 强制卸载fuse路径    ForceUnmount(mFuseDefault);    ForceUnmount(mFuseRead);    ForceUnmount(mFuseWrite);    rmdir(mFuseDefault.c_str());    rmdir(mFuseRead.c_str());    rmdir(mFuseWrite.c_str());    mFuseDefault.clear();    mFuseRead.clear();    mFuseWrite.clear();    return OK;}</code></pre><p>其内部具体的卸载方法就不一一细看了。最终，在再一次设置状态。到此内部设备就完成卸载，下面是外部设备的卸载过程。</p><pre><code>status_t Disk::unmountAll() {    for (auto vol : mVolumes) {        vol-&gt;unmount();    }    return OK;}</code></pre><p>其通过遍历，调用所有Disk的unmount实现卸载操作，这里就不一一分析了。其具体内容可以参考GitYuan博客内容。</p><p><a href="http://gityuan.com/2016/07/17/android-io/" target="_blank" rel="noopener">博客推荐</a></p><h5 id="EmulatedVolume-gt-create"><a href="#EmulatedVolume-gt-create" class="headerlink" title="EmulatedVolume-&gt;create"></a>EmulatedVolume-&gt;create</h5><p>EmulatedVolume设备的create方法，首先走父类的VolumeBase的create方法，如下：</p><pre><code>status_t VolumeBase::create() {    CHECK(!mCreated);    mCreated = true;    status_t res = doCreate();    // 通知VolumeCreated事件，发送650    notifyEvent(ResponseCode::VolumeCreated,            StringPrintf(&quot;%d \&quot;%s\&quot; \&quot;%s\&quot;&quot;, mType, mDiskId.c_str(), mPartGuid.c_str()));    // 设置为非挂载状态，发送651，0    setState(State::kUnmounted);    return res;}status_t VolumeBase::doCreate() {    return OK;}</code></pre><p>父类中检查状态后，直接调用doCreate方法，之后通过VM的Socket发送消息到MountService中。至此，VolumeManager便启动完成。</p><h3 id="NM流程分析"><a href="#NM流程分析" class="headerlink" title="NM流程分析"></a>NM流程分析</h3><h4 id="NM初始化"><a href="#NM初始化" class="headerlink" title="NM初始化"></a>NM初始化</h4><p>Vold.main中初始化VM后，便初始化NM，如下：</p><pre><code>// 同样是单利模式获取NetlinkManager *NetlinkManager::Instance() {    if (!sInstance)        sInstance = new NetlinkManager();    return sInstance;}NetlinkManager::NetlinkManager() {    mBroadcaster = NULL;}</code></pre><p>同样是单例模式进行实例化对象，之后便启动start函数，如下：</p><pre><code>int NetlinkManager::start() {    struct sockaddr_nl nladdr;    int sz = 64 * 1024;    int on = 1;    memset(&amp;nladdr, 0, sizeof(nladdr));    nladdr.nl_family = AF_NETLINK;    // 记录当前进程的pid    nladdr.nl_pid = getpid();    nladdr.nl_groups = 0xffffffff;    // 创建 event socket    if ((mSock = socket(PF_NETLINK, SOCK_DGRAM | SOCK_CLOEXEC,            NETLINK_KOBJECT_UEVENT)) &lt; 0) {        SLOGE(&quot;Unable to create uevent socket: %s&quot;, strerror(errno));        return -1;    }    // 设置 uevent 的 SO_RCVBUFFORCE 选项    if (setsockopt(mSock, SOL_SOCKET, SO_RCVBUFFORCE, &amp;sz, sizeof(sz)) &lt; 0) {        SLOGE(&quot;Unable to set uevent socket SO_RCVBUFFORCE option: %s&quot;, strerror(errno));        goto out;    }    // 设置 uevent 的 SO_PASSCRED 选项    if (setsockopt(mSock, SOL_SOCKET, SO_PASSCRED, &amp;on, sizeof(on)) &lt; 0) {        SLOGE(&quot;Unable to set uevent socket SO_PASSCRED option: %s&quot;, strerror(errno));        goto out;    }    // 绑定 uevent socket    if (bind(mSock, (struct sockaddr *) &amp;nladdr, sizeof(nladdr)) &lt; 0) {        SLOGE(&quot;Unable to bind uevent socket: %s&quot;, strerror(errno));        goto out;    }    // 在 NetlinkManager 启动中创建 NetlinkHandler    mHandler = new NetlinkHandler(mSock);    if (mHandler-&gt;start()) {        SLOGE(&quot;Unable to start NetlinkHandler: %s&quot;, strerror(errno));        goto out;    }    return 0;out:    close(mSock);    return -1;}</code></pre><p>其中内容比较多，最后我们发现其start时候，新建了一个NetlinkHandler负责通信。下面我们具体看看内部流程。</p><h4 id="NH流程分析"><a href="#NH流程分析" class="headerlink" title="NH流程分析"></a>NH流程分析</h4><h5 id="NH初始化"><a href="#NH初始化" class="headerlink" title="NH初始化"></a>NH初始化</h5><p>NetlinkHandler为NetlinkManager内部的handler，负责通信操作，具体如下：</p><pre><code>// NetlinkHandler继承于 NetlinkListener，NetlinkListener 继承于 SocketListener// new NetlinkHandler(mSock) 中参数 mSock 是用于与 Kernel 进行通信的 socket 对象// 由于这个继承关系，当 NetlinkHandler 初始化时会调用基类的初始化NetlinkHandler::NetlinkHandler(int listenerSocket) :                NetlinkListener(listenerSocket) {}int NetlinkHandler::start() {    return this-&gt;startListener();}</code></pre><p>其中如注释所写，NetlinkHandler继承于 NetlinkListener，NetlinkListener 继承于 SocketListener，我们看一下其父类和爷爷类：</p><pre><code>NetlinkListener::NetlinkListener(int socket) :                            SocketListener(socket, false) {    mFormat = NETLINK_FORMAT_ASCII;}SocketListener::SocketListener(const char *socketName, bool listen) {    init(socketName, -1, listen, false);}// 通过层层继承调用至此（SocketListener &lt;- NetlinkListener &lt;- NetlinkHandler &lt;- NetlinkManager）void SocketListener::init(const char *socketName, int socketFd, bool listen, bool useCmdNum) {    mListen = listen;    mSocketName = socketName;    // 用于监听 Kernel 发送过程的 uevent 事件    mSock = socketFd;    mUseCmdNum = useCmdNum;    // 初始化同步锁    pthread_mutex_init(&amp;mClientsLock, NULL);    // 创建 socket 通信的 client 端    mClients = new SocketClientCollection();}</code></pre><p>由此最终走到了SocketListener，其最终实现监听kernel发送过来的uevent事件，当然最终上层调用的开始监听也是在这里最终实现，后下面分析到这里会具体分析。</p><h5 id="NH-gt-start"><a href="#NH-gt-start" class="headerlink" title="NH-&gt;start"></a>NH-&gt;start</h5><p>NH初始化完成后，便进入start状态。代码跟踪如下：</p><pre><code>int NetlinkHandler::start() {    return this-&gt;startListener();}</code></pre><p>然后调用父类的方法，这里只在爷爷类SocketListener发现其实现代码，如下：</p><pre><code>int SocketListener::startListener(int backlog) {    if (!mSocketName &amp;&amp; mSock == -1) {        SLOGE(&quot;Failed to start unbound listener&quot;);        errno = EINVAL;        return -1;    } else if (mSocketName) {        // 获取所对应的 socket 的句柄        if ((mSock = android_get_control_socket(mSocketName)) &lt; 0) {            SLOGE(&quot;Obtaining file descriptor socket &apos;%s&apos; failed: %s&quot;,                mSocketName, strerror(errno));            return -1;        }        SLOGV(&quot;got mSock = %d for %s&quot;, mSock, mSocketName);        fcntl(mSock, F_SETFD, FD_CLOEXEC);    }    // 开始监听    if (mListen &amp;&amp; listen(mSock, backlog) &lt; 0) {        SLOGE(&quot;Unable to listen on socket (%s)&quot;, strerror(errno));        return -1;    } else if (!mListen)        // 创建 SocketClient 对象，并加入到 mClients 队列        mClients-&gt;push_back(new SocketClient(mSock, false, mUseCmdNum));    // 创建匿名管道    // 这是一个二元数组，mCtrlPipe[0]从管道读数据，mCtrlPipe[1]从管道写数据    if (pipe(mCtrlPipe)) {        SLOGE(&quot;pipe failed (%s)&quot;, strerror(errno));        return -1;    }    // 创建工作线程，线程运行函数threadStart    if (pthread_create(&amp;mThread, NULL, SocketListener::threadStart, this)) {        SLOGE(&quot;pthread_create (%s)&quot;, strerror(errno));        return -1;    }    return 0;}</code></pre><p>在SocketListener开始监听中，其创建SocketClient对象，加入到mClients队列中，然后对二元数组管道进行读写，最终通过pthread_create另外开启一个线程进行监听。线程代码开启如下：</p><pre><code>void *SocketListener::threadStart(void *obj) {    SocketListener *me = reinterpret_cast&lt;SocketListener *&gt;(obj);    //开始监听    me-&gt;runListener();    // 线程退出    pthread_exit(NULL);    return NULL;}void SocketListener::runListener() {    SocketClientCollection pendingList;    while(1) {        SocketClientCollection::iterator it;        fd_set read_fds;        int rc = 0;        int max = -1;        FD_ZERO(&amp;read_fds);        if (mListen) {            max = mSock;            FD_SET(mSock, &amp;read_fds);        }        FD_SET(mCtrlPipe[0], &amp;read_fds);        if (mCtrlPipe[0] &gt; max)            max = mCtrlPipe[0];        pthread_mutex_lock(&amp;mClientsLock);        for (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) {            // NB: calling out to an other object with mClientsLock held (safe)            int fd = (*it)-&gt;getSocket();            FD_SET(fd, &amp;read_fds);            if (fd &gt; max) {                max = fd;            }        }        pthread_mutex_unlock(&amp;mClientsLock);        SLOGV(&quot;mListen=%d, max=%d, mSocketName=%s&quot;, mListen, max, mSocketName);        if ((rc = select(max + 1, &amp;read_fds, NULL, NULL, NULL)) &lt; 0) {            if (errno == EINTR)                continue;            SLOGE(&quot;select failed (%s) mListen=%d, max=%d&quot;, strerror(errno), mListen, max);            sleep(1);            continue;        } else if (!rc)            continue;        if (FD_ISSET(mCtrlPipe[0], &amp;read_fds)) {            char c = CtrlPipe_Shutdown;            TEMP_FAILURE_RETRY(read(mCtrlPipe[0], &amp;c, 1));            if (c == CtrlPipe_Shutdown) {                break;            }            continue;        }        if (mListen &amp;&amp; FD_ISSET(mSock, &amp;read_fds)) {            struct sockaddr addr;            socklen_t alen;            int c;            do {                alen = sizeof(addr);                c = accept(mSock, &amp;addr, &amp;alen);                SLOGV(&quot;%s got %d from accept&quot;, mSocketName, c);            } while (c &lt; 0 &amp;&amp; errno == EINTR);            if (c &lt; 0) {                SLOGE(&quot;accept failed (%s)&quot;, strerror(errno));                sleep(1);                continue;            }            fcntl(c, F_SETFD, FD_CLOEXEC);            pthread_mutex_lock(&amp;mClientsLock);            mClients-&gt;push_back(new SocketClient(c, true, mUseCmdNum));            pthread_mutex_unlock(&amp;mClientsLock);        }        /* Add all active clients to the pending list first */        pendingList.clear();        pthread_mutex_lock(&amp;mClientsLock);        for (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) {            SocketClient* c = *it;            // NB: calling out to an other object with mClientsLock held (safe)            int fd = c-&gt;getSocket();            if (FD_ISSET(fd, &amp;read_fds)) {                pendingList.push_back(c);                c-&gt;incRef();            }        }        pthread_mutex_unlock(&amp;mClientsLock);        /* Process the pending list, since it is owned by the thread,        * there is no need to lock it */        while (!pendingList.empty()) {            /* Pop the first item from the list */            it = pendingList.begin();            SocketClient* c = *it;            pendingList.erase(it);            /* Process it, if false is returned, remove from list */            if (!onDataAvailable(c)) {                release(c, false);            }            c-&gt;decRef();        }    }}</code></pre><p>runListener中，通过死循环和加锁机制，不断读取上述二元数组内的数据，最终将读写到的数据通过方法onDataAvailable实现回调。</p><h5 id="SL-gt-onDataAvailable"><a href="#SL-gt-onDataAvailable" class="headerlink" title="SL-&gt;onDataAvailable"></a>SL-&gt;onDataAvailable</h5><p>这里我们不妨多看看其回调过程,其SocketListener本身没有实现这个方法，其直接子类NetlinkListener实现了，如下：</p><pre><code>// 父类 SocketListener 回调此方法bool NetlinkListener::onDataAvailable(SocketClient *cli){    int socket = cli-&gt;getSocket();    ssize_t count;    uid_t uid = -1;    bool require_group = true;    if (mFormat == NETLINK_FORMAT_BINARY_UNICAST) {        require_group = false;    }    // 多次尝试获取socket数据    count = TEMP_FAILURE_RETRY(uevent_kernel_recv(socket,            mBuffer, sizeof(mBuffer), require_group, &amp;uid));    if (count &lt; 0) {        if (uid &gt; 0)            LOG_EVENT_INT(65537, uid);        SLOGE(&quot;recvmsg failed (%s)&quot;, strerror(errno));        return false;    }    NetlinkEvent *evt = new NetlinkEvent();    // 解析消息并封装成 NetlinkEvent    if (evt-&gt;decode(mBuffer, count, mFormat)) {        //事件处理        onEvent(evt);    } else if (mFormat != NETLINK_FORMAT_BINARY) {        // Don&apos;t complain if parseBinaryNetlinkMessage returns false. That can        // just mean that the buffer contained no messages we&apos;re interested in.        SLOGE(&quot;Error decoding NetlinkEvent&quot;);    }    delete evt;    return true;}</code></pre><p>NetlinkListener在得到父类传来的数据后，将数据进行封装NetlinkEvent。最终实现onEvent方法回调。这里的onEvent接口是在哪声明的呢？根据头文件我们发现，其是一个虚函数，需要子类进行实现，其声明如下：</p><pre><code>-&gt; /system/vold/NetlinkHandler.hprotected:    virtual void onEvent(NetlinkEvent *evt);};</code></pre><p>由于NetlinkHandler为NetlinkListener的子类，我们查看发现其具体实现如下：</p><pre><code>// NetlinkListener 在 onDataAvailable 回调到此方法void NetlinkHandler::onEvent(NetlinkEvent *evt) {    VolumeManager *vm = VolumeManager::Instance();    const char *subsys = evt-&gt;getSubsystem();    if (!subsys) {        SLOGW(&quot;No subsystem found in netlink event&quot;);        return;    }    if (!strcmp(subsys, &quot;block&quot;)) {        // 调用 VolumeManager 处理块设备        vm-&gt;handleBlockEvent(evt);    }}</code></pre><p>到这里，最终调用VolumeManager的handleBlockEvent实现处理。至此我们先告一段落，在后面存储系统工作流程中进行具体分析。</p><h3 id="CommandListener流程分析"><a href="#CommandListener流程分析" class="headerlink" title="CommandListener流程分析"></a>CommandListener流程分析</h3><h4 id="CL初始化"><a href="#CL初始化" class="headerlink" title="CL初始化"></a>CL初始化</h4><p>分析完程VM和NM的流程，下面便是CommandListener的实例化过程，如下：</p><pre><code>CommandListener::CommandListener() :                FrameworkListener(&quot;vold&quot;, true) {    // 加入到 mCommands 队列    registerCmd(new DumpCmd());    registerCmd(new VolumeCmd());    registerCmd(new AsecCmd());    registerCmd(new ObbCmd());    registerCmd(new StorageCmd());    registerCmd(new FstrimCmd());    // MStar Android Patch Begin    registerCmd(new ISOCmd());    registerCmd(new SambaCmd());    // MStar Android Patch End}void FrameworkListener::registerCmd(FrameworkCommand *cmd) {    // 加入到mCommands队列    mCommands-&gt;push_back(cmd);}</code></pre><p>CommandListener在实例化中，注册了各种设备的操作命令，例如DumpCmd，VolumCmd等，其父类FrameworkListener做了啥，我们查看一下：</p><pre><code>FrameworkListener::FrameworkListener(const char *socketName) :                            SocketListener(socketName, true, false) {    init(socketName, false);}void FrameworkListener::init(const char *socketName UNUSED, bool withSeq) {    mCommands = new FrameworkCommandCollection();    errorRate = 0;    mCommandCount = 0;    mWithSeq = withSeq;    mSkipToNextNullByte = false;}</code></pre><p>父类FrameworkListener初始化又新建了FrameworkCommandCollection，这是干嘛的呀？其通过typedef重声明定义如下：</p><pre><code>typedef android::sysutils::List&lt;FrameworkCommand *&gt; FrameworkCommandCollection;FrameworkCommand::FrameworkCommand(const char *cmd) {    mCommand = cmd;}</code></pre><h5 id="关于DumpCmd，VolumCmd等几种cmd的介绍"><a href="#关于DumpCmd，VolumCmd等几种cmd的介绍" class="headerlink" title="关于DumpCmd，VolumCmd等几种cmd的介绍"></a>关于DumpCmd，VolumCmd等几种cmd的介绍</h5><p>在这里有必要介绍这几种DumpCmd，VolumCmd之间的关系，例如VolumCmd继承自VoldCommand继承自FrameworkCommand，FrameworkCommand有一个重要的方法runCommand实现如下：</p><pre><code>int FrameworkCommand::runCommand(SocketClient *c UNUSED, int argc UNUSED,                                char **argv UNUSED) {    SLOGW(&quot;Command %s has no run handler!&quot;, getCommand());    errno = ENOSYS;    return -1;}</code></pre><p>其中其没有必要的实现代码，我们继续通过继承关系向上追溯，发现其在CommandListener类中实现了具体代码，如下：</p><p>int CommandListener::VolumeCmd::runCommand(SocketClient *cli,<br>                                           int argc, char **argv) {<br>    dumpArgs(argc, argv, -1);</p><pre><code>if (argc &lt; 2) {    cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, &quot;Missing Argument&quot;, false);    return 0;}VolumeManager *vm = VolumeManager::Instance();std::lock_guard&lt;std::mutex&gt; lock(vm-&gt;getLock());std::string cmd(argv[1]);if (cmd == &quot;reset&quot;) {    return sendGenericOkFail(cli, vm-&gt;reset());}...} else if (cmd == &quot;mount&quot; &amp;&amp; argc &gt; 2) {    // mount [volId] [flags] [user]    std::string id(argv[2]);    auto vol = vm-&gt;findVolume(id);    if (vol == nullptr) {        return cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, &quot;Unknown volume&quot;, false);    }    int mountFlags = (argc &gt; 3) ? atoi(argv[3]) : 0;    userid_t mountUserId = (argc &gt; 4) ? atoi(argv[4]) : -1;    vol-&gt;setMountFlags(mountFlags);    vol-&gt;setMountUserId(mountUserId);    // Mstar Android Patch Begin    CommandListener::VolumeCmd::finished = false;    CommandListener::VolumeCmd::res = 1;    std::thread mThread(&amp;CommandListener::VolumeCmd::doMount,this,vol);    mThread.detach();    int i = 0;    // if mount time &gt; 3S ,return fail    while(i&lt;6 &amp;&amp; CommandListener::VolumeCmd::finished == false) {        SLOGD(&quot;sleep 0.5s&quot;);        usleep(500000); //sleep 0.5s        i++;    }    if (mountFlags &amp; android::vold::VolumeBase::MountFlags::kPrimary) {        vm-&gt;setPrimary(vol);    }    return sendGenericOkFail(cli, CommandListener::VolumeCmd::res);    // Mstar Android Patch End} else if (cmd == &quot;unmount&quot; &amp;&amp; argc &gt; 2) {    // unmount [volId]    std::string id(argv[2]);    auto vol = vm-&gt;findVolume(id);    if (vol == nullptr) {        return cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, &quot;Unknown volume&quot;, false);    }    return sendGenericOkFail(cli, vol-&gt;unmount());} else if (cmd == &quot;format&quot; &amp;&amp; argc &gt; 3) {    // format [volId] [fsType|auto]    std::string id(argv[2]);    std::string fsType(argv[3]);    auto vol = vm-&gt;findVolume(id);    if (vol == nullptr) {        return cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, &quot;Unknown volume&quot;, false);    }    return sendGenericOkFail(cli, vol-&gt;format(fsType));} ...return cli-&gt;sendMsg(ResponseCode::CommandSyntaxError, nullptr, false);</code></pre><p>}<br>其中代码比较长，实现了各种针对Volume设备的各种操作，比如 挂载mount，格式化format等等。。。</p><h4 id="CL-gt-startListener"><a href="#CL-gt-startListener" class="headerlink" title="CL-&gt;startListener"></a>CL-&gt;startListener</h4><p>下面我们查看一下CommandListener的startListener方法，CommandListener没有实现此方法，但是其继承自FrameworkListener，FrameworkListener也没有实现，其又继承自SocketListener，最终由SocketListener实现，如下：</p><pre><code>int SocketListener::startListener() {    return startListener(4);}int SocketListener::startListener(int backlog) {    if (!mSocketName &amp;&amp; mSock == -1) {        SLOGE(&quot;Failed to start unbound listener&quot;);        errno = EINVAL;        return -1;    } else if (mSocketName) {        // 获取所对应的 socket 的句柄        if ((mSock = android_get_control_socket(mSocketName)) &lt; 0) {            SLOGE(&quot;Obtaining file descriptor socket &apos;%s&apos; failed: %s&quot;,                mSocketName, strerror(errno));            return -1;        }        SLOGV(&quot;got mSock = %d for %s&quot;, mSock, mSocketName);        fcntl(mSock, F_SETFD, FD_CLOEXEC);    }    // 开始监听    if (mListen &amp;&amp; listen(mSock, backlog) &lt; 0) {        SLOGE(&quot;Unable to listen on socket (%s)&quot;, strerror(errno));        return -1;    } else if (!mListen)        // 创建 SocketClient 对象，并加入到 mClients 队列        mClients-&gt;push_back(new SocketClient(mSock, false, mUseCmdNum));    // 创建匿名管道    // 这是一个二元数组，mCtrlPipe[0]从管道读数据，mCtrlPipe[1]从管道写数据    if (pipe(mCtrlPipe)) {        SLOGE(&quot;pipe failed (%s)&quot;, strerror(errno));        return -1;    }    // 创建工作线程，线程运行函数threadStart    if (pthread_create(&amp;mThread, NULL, SocketListener::threadStart, this)) {        SLOGE(&quot;pthread_create (%s)&quot;, strerror(errno));        return -1;    }    return 0;}</code></pre><p>至此，CommandListener的startListener就分析完毕。</p><h3 id="CryptCommandListener流程分析"><a href="#CryptCommandListener流程分析" class="headerlink" title="CryptCommandListener流程分析"></a>CryptCommandListener流程分析</h3><h4 id="CLL初始化"><a href="#CLL初始化" class="headerlink" title="CLL初始化"></a>CLL初始化</h4><p>CryptCommandListener的初始化流程和上述的CommandListener基本相似，这了我们粗略的看一下，有兴趣的读者自行查看：</p><pre><code>CryptCommandListener::CryptCommandListener() :FrameworkListener(&quot;cryptd&quot;, true) {    registerCmd(new CryptfsCmd());}CryptCommandListener::CryptfsCmd::CryptfsCmd() :                VoldCommand(&quot;cryptfs&quot;) {}</code></pre><p>通过额外的registerCmd注册CryptfsCmd命令，其具体的runCommand实现对应的操作，这里就不贴代码了。</p><h4 id="CLL-gt-startListener"><a href="#CLL-gt-startListener" class="headerlink" title="CLL-&gt;startListener"></a>CLL-&gt;startListener</h4><p>当然CryptCommandListener也没有实现方法startListener，其最终还是通过SocketListener来实现的。具体参考上述流程。</p><h2 id="相关类图"><a href="#相关类图" class="headerlink" title="相关类图"></a>相关类图</h2><p>相信到此，如果你认真的看完第一遍并且是第一次看完的话，肯定是一头雾水，什么跟什么啊，这么多类，各种跳真的是烦。不急不急，这里我们引用一张类图还是有必要的，根据这张类图，在回过去看代码流程，你就能轻松的知道各个类之间的关系是如何的。</p><h3 id="VM相关类图"><a href="#VM相关类图" class="headerlink" title="VM相关类图"></a>VM相关类图</h3><img src="/FuckCode/2018/09/28/源码分析之存储系统启动流程Vold模块/VM.jpg" class="VolumeManger相关类图"><p>VolumeManager作为Vold模块最重要的一个类，其承载了很多重要的工作流程，其中涉及到很多类，类中各种继承关系也很复杂，对着上述的类图就很容易理清各个类之间的关系了。</p><h3 id="NM相关类图"><a href="#NM相关类图" class="headerlink" title="NM相关类图"></a>NM相关类图</h3><img src="/FuckCode/2018/09/28/源码分析之存储系统启动流程Vold模块/NM.jpg" class="VolumeManger相关类图"><p>NetLinkManager负责直接接收Kernel发来的uevent事件，其类之间的关系更是复杂，相信有这张类图后，在回溯到代码流程中就很清晰了。SocketListener为最重要的父类，其直接和Socket打交道，之后在分发到子类中处理，其大概可以分为两个部分，如下：</p><h4 id="命令流程如下："><a href="#命令流程如下：" class="headerlink" title="命令流程如下："></a>命令流程如下：</h4><p>SocketListener发现Socket中有数据后，对数据进行封装（NetlinkEvent），通过dispatchCommand方法，将命令分别分发到指定的Cmd进行处理，各种Cmd的声明和处理流程在CommandListener中都有声明。其中各种Cmd相似的方法处理都由父类FrameworkCommand进行统一的抽象管理。</p><h4 id="命令分发如下："><a href="#命令分发如下：" class="headerlink" title="命令分发如下："></a>命令分发如下：</h4><p>当然SocketListener得到数据后，还会通过onDataAvaiable进行回传，到Netlinkhandler中通过onEventh回传到VolumeManager进行处理。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="内容说明"><a href="#内容说明" class="headerlink" title="内容说明"></a>内容说明</h3><p>本想一篇章写完Android存储系统中启动流程，其主要包括native层的Vold和Java层MountService。介于篇幅太长，下面会在独立篇章介绍MountService启动流程以及两者之间的通信过程，希望三篇博客可以结束这段痛苦的代码阅读之旅。</p><h3 id="引用说明"><a href="#引用说明" class="headerlink" title="引用说明"></a>引用说明</h3><p>此博客内容为作者实战编辑，并非随便的拷贝，内容参考学习GitYuan博客中内容，这里郑重说明一下。其链接见下面。</p><p><a href="http://gityuan.com/2016/07/17/android-io/" target="_blank" rel="noopener">GitYuan博客推荐</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android系统HAL层驱动开发实战</title>
      <link href="/FuckCode/2018/08/22/Android%E7%B3%BB%E7%BB%9FHAL%E5%B1%82%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/FuckCode/2018/08/22/Android%E7%B3%BB%E7%BB%9FHAL%E5%B1%82%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><strong>基于Android HAL层驱动框架，开发者很容易将自己的驱动实现在用户空间，实现驱动细节的隐藏，而不必在内核中进行修改，避免因修改内核，公开源码进而损害自己的商业利益。本章节，我们就对HAL层驱动框架进行实现，由底层驱动到中间层framework，继而进入上层应用端，彻底完成上层应用到底层驱动的一一实现。</strong></p><a id="more"></a><h3 id="HAL层驱动实现"><a href="#HAL层驱动实现" class="headerlink" title="HAL层驱动实现"></a>HAL层驱动实现</h3><p>HAL层驱动框架的介绍在上篇章中已经详细的说明了。本节就在上节篇章中进行补充和说明，在框架基础上，代码实现自定义的驱动程序。本篇章中实现的驱动原型为led灯，包括设备初始化，打开，关闭以及设备移除等。</p><h4 id="HAL头文件"><a href="#HAL头文件" class="headerlink" title="HAL头文件"></a>HAL头文件</h4><p>HAL驱动的头文件声明，可供实体文件导入，在JNI实现代码中同样需要导入，具体代码如下：</p><pre><code>路径：hardware/libhardware/include/hardware/led.h#ifndef ANDROID_LED_INTERFACE_H#define ANDROID_LED_INTERFACE_H#include &lt;hardware/hardware.h&gt;__BEGIN_DECLS#define LED_HARDWARE_MODULE_ID &quot;led&quot;#define LED_HARDWARE_DEVICE_ID &quot;led&quot;typedef struct led_module_t {    struct hw_module_t common;} led_module_t;typedef struct led_device_t {    struct hw_device_t common;    int (*set_on)(struct led_device_t* dev);    int (*set_off)(struct led_device_t* dev);    int (*getCount)(struct led_device_t* dev);} led_device_t;static inline int led_device_open(const struct hw_module_t* module,    led_device_t** dev){    return module-&gt;methods-&gt;open(module,LED_HARDWARE_DEVICE_ID,        (struct hw_device_t**) dev);}static inline int led_device_close(led_device_t* dev){    return dev-&gt;common.close(&amp;dev-&gt;common);}__END_DECLS#endif</code></pre><p>代码相关说明：</p><ol><li>声明模块ID，设备ID均为“led”</li><li>定义结构体 led_module_t 及 led_device_t 时便进行全局 typedef ，方便导包直接使用</li><li>设备声明三个函数指针，set_on开灯，set_off关灯，getCount灯数目</li><li>两个静态内联函数 led_device_open打开模块设备，led_device_close关闭模块设备</li></ol><p><strong><em>注意：文件路径的include同级目录下，应该有hardware.h 文件，此文件源码框架本身已经提供，不必自己实现</em></strong></p><h4 id="HAL实体文件"><a href="#HAL实体文件" class="headerlink" title="HAL实体文件"></a>HAL实体文件</h4><p>本体文件代码如下：</p><pre><code>代码路径：hardware/libhardware/modules/led/led.c#define LOG_TAG &quot;LedHALStub&quot;#include &lt;hardware/hardware.h&gt;#include &lt;hardware/led.h&gt;#include &lt;cutils/log.h&gt;#include &lt;malloc.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;math.h&gt;#include &lt;memory.h&gt;#define MODULE_NAME &quot;Led&quot;#define MODULE_AUTHOR &quot;891904833@qq.com&quot;static int led_set_on(led_device_t* dev) {    if(!dev) {        ALOGI(&quot;Null dev pointer.&quot;);        return -EFAULT;    }    ALOGI(&quot;led_set_on function call!&quot;);    return 0;}static int led_set_off(led_device_t* dev) {    if(!dev) {        ALOGI(&quot;Null dev pointer.&quot;);        return -EFAULT;    }    ALOGI(&quot;led_set_off function call!&quot;);    return 0;}static int led_getCount(led_device_t* device) {    ALOGI(&quot;led_getCount function call,return led_getCount is 4!&quot;);    return 4;}static int led_close(hw_device_t* device) {    if(device){        free(device);    }    ALOGI(&quot;led_device close successfully!&quot;);    return 0;}static int led_open(const hw_module_t* module, const char* id,    hw_device_t** device) {        // dev = (struct led_device_t*)malloc(sizeof(struct led_device_t));        led_device_t *dev = (led_device_t *)calloc(1, sizeof(led_device_t));        if(!dev) {            ALOGE(&quot;Failed to alloc space for led_device_t.&quot;);            return -EFAULT;        }        memset(dev, 0, sizeof(struct led_device_t));        dev-&gt;common.tag = HARDWARE_DEVICE_TAG;        dev-&gt;common.version = 0;        dev-&gt;common.module = (struct hw_module_t*)module;        dev-&gt;common.close = led_close;        dev-&gt;set_on = led_set_on;        dev-&gt;set_off = led_set_off;        dev-&gt;getCount = led_getCount;        *device = &amp;dev-&gt;common;        ALOGI(&quot;Open led_device successfully!&quot;);        return 0;}static struct hw_module_methods_t my_methods = {    .open = led_open,};struct led_module_t HAL_MODULE_INFO_SYM = {    .common = {        .tag = HARDWARE_MODULE_TAG,        .version_major = 1,        .version_minor = 0,        .id = LED_HARDWARE_MODULE_ID,        .name = MODULE_NAME,        .author = MODULE_AUTHOR,        .methods = &amp;my_methods,    },};</code></pre><p>代码相关说明：</p><ol><li>前面几个静态函数是函数指针方法的具体实现，下面在open设备时实现方法的一一映射</li><li>led_open 方法实现设备的初始化，包括内核分配内存，led_device_t 内相关指针函数方法的映射等</li><li>my_methods 方法为框架中结构体 hw_module_t 内 open 方法的具体映射</li><li>HAL_MODULE_INFO_SYM 为HAL框架的必要说明，方便加载动态库时识别为驱动模块，并依据ID找到对应的模块驱动。同时完成 hw_module_t 必要方法 methods 的映射</li><li>为了方便调试，HAL驱动的具体实现中仅进行Log打印，没有协助内核进行相关操作，之后在上层调用中如果查看到 “LedHALStub” 日志，即代表驱动调用ok</li></ol><h4 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h4><p>编译文件 Android.mk 将源代码编译成动态链接库，存放在设备的 /system/lib/hw/led.default.so 和 /system/lib64/hw/led.default.so，代码如下：</p><pre><code>LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_PRELINK_MODULE := falseLOCAL_MODULE_RELATIVE_PATH := hwLOCAL_SHARED_LIBRARIES := \    liblog \    libutilsLOCAL_SRC_FILES := led.cppLOCAL_MODULE := led.defaultinclude $(BUILD_SHARED_LIBRARY)</code></pre><h3 id="framework层实现"><a href="#framework层实现" class="headerlink" title="framework层实现"></a>framework层实现</h3><p>HAL层驱动框架实现完成，下面就进行framework层的实现。大概调用流程如下：首先系统提供一个全局的LedService服务，系统设备启动中将其注册到ServiceManager中，其后上层应用通过跨进程aidl方式，远程调用服务内方法，最后在服务内通过jni方式再调用到底层驱动程序，实现上层到中间层继而底层驱动的全程跨度。</p><h4 id="AIDL声明"><a href="#AIDL声明" class="headerlink" title="AIDL声明"></a>AIDL声明</h4><p>AIDL的详细说明在之前的篇章中已经详细介绍过了，下面直接看服务的接口声明：</p><pre><code>代码路径：frameworks/base/core/java/android/os/ILedService.aidlpackage android.os;/** {@hide} */interface ILedService{    int LedInit();    void LedSetOn();    void LedSetOff();    void LedClose();    int LedGetCount();}</code></pre><p>代码说明：<br>声明五个接口，对应设备的初始化，打开，关闭，灯数目以及设备移除。</p><h5 id="编译AIDL文件"><a href="#编译AIDL文件" class="headerlink" title="编译AIDL文件"></a>编译AIDL文件</h5><p>声明完成AIDL文件，修改framework/base下的Android.mk文件，将ILedService.aidl加入到编译脚本aidl文件中去。</p><pre><code>LOCAL_SRC_FILES += \    core/java/android/accessibilityservice/IAccessibilityServiceConnection.aidl \    ...    core/java/android/os/ILedService.aidl \  ...</code></pre><p>之后执行 mmm framework/base 局部编译，生成aidl对应的java文件，文件位于 out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/os/ILedService.java</p><h4 id="自定义服务实现"><a href="#自定义服务实现" class="headerlink" title="自定义服务实现"></a>自定义服务实现</h4><p>有了AIDL文件的接口方法，下面就进行自定义服务的实现。首先找到同级文件夹 frameworks/base/services/core/java/com/android/server/ 下，自定义 LedService 继承AIDL文件中间类 ILedService.Stub ，具体代码如下：</p><pre><code>package com.android.server;import android.os.ILedService;import android.util.Slog;public class LedService extends ILedService.Stub {    private static final String TAG = &quot;LedService&quot;;    public int LedInit() throws android.os.RemoteException    {        return native_LedInit();    }    public void LedSetOn() throws android.os.RemoteException    {        Slog.d(TAG,&quot;LedService native_LedSetOn&quot;);        native_LedSetOn();    }    public void LedSetOff() throws android.os.RemoteException    {        Slog.d(TAG,&quot;LedService native_LedSetOff&quot;);        native_LedSetOff();    }    public int LedGetCount() throws android.os.RemoteException    {        Slog.d(TAG,&quot;LedService native_LedGetCount&quot;);        return native_LedGetCount();    }    public void LedClose() throws android.os.RemoteException{        Slog.d(TAG,&quot;LedService native_LedClose&quot;);        native_LedClose();    }    public LedService()    {        Slog.d(TAG,&quot;LedService started!&quot;);    }    native int native_LedInit();    native void native_LedSetOn();    native void native_LedSetOff();    native int native_LedGetCount();    native void native_LedClose();}</code></pre><p>代码相关说明：</p><ol><li>ILedService.Stub 类为aidl文件经过系统编译后生成的本地Binder类，实现跨进层通信的基础是基于安卓Binder框架，这里通过继承 ILedService.Stub 类，可以直接调用框架中实现好的Binder体系中重要的两个方法 transact(…) 和 onTransact(…)</li><li>对于接口中的每个方法，最终都归结实现在native层jni方法中</li></ol><h4 id="加入系统服务SM"><a href="#加入系统服务SM" class="headerlink" title="加入系统服务SM"></a>加入系统服务SM</h4><p>完成自定义服务的编写，下面就需要将其加入到SM中，方便后续上层应用进行调用。由于系统开机会在SystemServer中进行相关服务的初始化登记动作，这里将LedService加入到SystemServer中去即可，具体代码如下：</p><pre><code>代码路径：frameworks/base/services/core/java/com/android/server/SystemServer.java...Slog.i(TAG, &quot;Vibrator Service&quot;);vibrator = new VibratorService(context);ServiceManager.addService(&quot;vibrator&quot;, vibrator);// new code by alliesLedService led = null;Slog.i(TAG, &quot;Led Service&quot;);led = new LedService();ServiceManager.addService(&quot;led&quot;, led);...</code></pre><p>这里找到 VibratorService 震动服务，将 LedService 加入到此段代码下面即可，其他代码这里省略。</p><h4 id="JNI方法实现"><a href="#JNI方法实现" class="headerlink" title="JNI方法实现"></a>JNI方法实现</h4><p>LedService中的native方法声明完成，下面就要对此jni方法进行实现。这里依据其他服务jni方法声明文件方式，同级目录下新建文档 com_android_server_LedService.cpp ,具体代码如下：</p><pre><code>代码路径：frameworks/base/services/core/jni/com_android_server_LedService.cpp#define LOG_TAG &quot;LedServiceJNI&quot;#include &quot;jni.h&quot;#include &quot;JNIHelp.h&quot;#include &quot;android_runtime/AndroidRuntime.h&quot;#include &lt;utils/misc.h&gt;#include &lt;utils/Log.h&gt;#include &lt;hardware/hardware.h&gt;#include &lt;hardware/led.h&gt;#include &lt;stdio.h&gt;namespace android{    static led_device_t* mLedDevice = 0;    static jint led_init(JNIEnv *env, jobject instance){        led_module_t* module;        ALOGI(&quot;led_init start ...&quot;);        if (hw_get_module(LED_HARDWARE_MODULE_ID, (hw_module_t const**)&amp;module) == 0) {              ALOGI(&quot;Device led found...&quot;);            if (led_device_open(&amp;(module-&gt;common), &amp;mLedDevice ) == 0) {                ALOGI(&quot;led_init success!!!&quot;);                return 0;            }            ALOGE(&quot;led_init error!!!&quot;);        }        ALOGI(&quot;hw_get_module function call error!!!&quot;);        return -1;    }    static jint led_getCount(JNIEnv *env, jobject thiz) {        ALOGI(&quot;led_getCount 4&quot;);        return mLedDevice-&gt;getCount(mLedDevice);;    }    static void led_setOn(JNIEnv *env, jobject thiz) {        ALOGI(&quot;led_set_on&quot;);        mLedDevice-&gt;set_on(mLedDevice);    }    static void led_setOff(JNIEnv *env, jobject thiz) {        ALOGI(&quot;led_set_off&quot;);        mLedDevice-&gt;set_off(mLedDevice);    }    static void led_close(JNIEnv *env, jobject thiz) {        ALOGI(&quot;led_close&quot;);        led_device_close(mLedDevice);    }    static const JNINativeMethod method_table[] = {        {&quot;native_LedInit&quot;, &quot;()I&quot;, (void*)led_init},        {&quot;native_LedSetOn&quot;, &quot;()V&quot;, (void*)led_setOn},        {&quot;native_LedSetOff&quot;, &quot;()V&quot;, (void*)led_setOff},        {&quot;native_LedGetCount&quot;, &quot;()I&quot;, (void*)led_getCount},        {&quot;native_LedClose&quot;, &quot;()V&quot;, (void*)led_close},    };    int register_android_server_LedService(JNIEnv *env) {            return jniRegisterNativeMethods(env, &quot;com/android/server/LedService&quot;, method_table, NELEM(method_table));    }};</code></pre><p>代码相关说明：</p><ol><li>led_init 为设备的初始化，主要有两个重要操作：其一，调用HAL框架公用方法 hw_get_module 依据传入的模块ID，加载对应的驱动模块文件，并完成框架结构体 hw_module_t 内 methods方法的映射；其二，调用 led.h 头文件内联函数 led_device_open 打开模块设备，完成 led_device_t 结构体内相关指针函数的映射，之后，将设备引用存放于 mLedDevice 中，方便后续具体方法的调用</li><li>几个静态方法的具体实现，实质上是调用 mLedDevice 变量设备的方法，及驱动中对应的方法</li><li>method_table 静态常数组，其内存放了上层native方法声明和本c层实体方法的一一映射</li><li>register_android_server_LedService jni方法的注册具体实现，此方法需要在系统启动时，在onload.cpp中指定</li></ol><h4 id="自定义方法JNI注册实现"><a href="#自定义方法JNI注册实现" class="headerlink" title="自定义方法JNI注册实现"></a>自定义方法JNI注册实现</h4><p>修改同级目录下 frameworks/base/services/core/jni/onload.cpp 文件，将 com_android_server_LedService.cpp 文件注册到系统中去。</p><pre><code>代码路径：frameworks/base/services/core/jni/onload.cpp#include &quot;JNIHelp.h&quot;#include &quot;jni.h&quot;#include &quot;utils/Log.h&quot;#include &quot;utils/misc.h&quot;namespace android {int register_android_server_AlarmManagerService(JNIEnv* env);int register_android_server_AssetAtlasService(JNIEnv* env);...int register_android_server_LedService(JNIEnv* env);};using namespace android;extern &quot;C&quot; jint JNI_OnLoad(JavaVM* vm, void* /* reserved */){    JNIEnv* env = NULL;    jint result = -1;    if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {        ALOGE(&quot;GetEnv failed!&quot;);        return result;    }    ALOG_ASSERT(env, &quot;Could not retrieve the env!&quot;);    register_android_server_PowerManagerService(env);    register_android_server_SerialService(env);    ...    register_android_server_LedService(env);    return JNI_VERSION_1_4;}</code></pre><p>在对应的地方，依照其他代码方式，添加自己声明的jni方法注册实现即可。</p><h4 id="编译脚本修改"><a href="#编译脚本修改" class="headerlink" title="编译脚本修改"></a>编译脚本修改</h4><p>到这里已经修改完成了framework层相关文件的编写，之后我们就需要修改此层文件中的编译脚本，将添加的文件加入编译系统中去。</p><pre><code>代码路径：frameworks/base/services/core/jni/Android.mkLOCAL_REL_DIR := core/jniLOCAL_CFLAGS += -Wall -Werror -Wno-unused-parameterLOCAL_SRC_FILES += \    $(LOCAL_REL_DIR)/com_android_server_AlarmManagerService.cpp \    $(LOCAL_REL_DIR)/com_android_server_am_BatteryStatsService.cpp \    ...    $(LOCAL_REL_DIR)/com_android_server_LedService.cpp \    $(LOCAL_REL_DIR)/onload.cpp \    ...</code></pre><p>源码跟路径下，执行 mmm frameworks/base/services/ 命令，编译生成相关文件之后，make snod 将编译变动文件打包到system.img镜像中，升级系统。</p><h3 id="应用层实现"><a href="#应用层实现" class="headerlink" title="应用层实现"></a>应用层实现</h3><p>到这里，HAL层驱动，framework层框架都以搭建完成，系统刷写新的rom后，下面我们就要对此进行上层应用的调用。</p><h4 id="导入AIDL文件"><a href="#导入AIDL文件" class="headerlink" title="导入AIDL文件"></a>导入AIDL文件</h4><p>由于需要跨进程进行系统服务的调用，这里需要将之前声明的AIDL文件拷贝到Android Studio中，锤子一下，生成相应的Stub文件，方便后续服务的获取。注意AIDL文件的包名要和系统中的相一致。</p><h4 id="项目源码示例"><a href="#项目源码示例" class="headerlink" title="项目源码示例"></a>项目源码示例</h4><p>对于Android Studio项目的全程源码，在这里就不贴了。主要的逻辑还是要看一下。如下：</p><p>package allies.showame.com.jni_hal_demo;</p><p>import android.os.Bundle;<br>import android.os.ILedService;<br>import android.os.RemoteException;<br>import android.os.ServiceManager;<br>import android.support.v7.app.AppCompatActivity;<br>import android.util.Log;<br>import android.view.View;</p><p>public class MainActivity extends AppCompatActivity implements View.OnClickListener {</p><pre><code>private static final String TAG = &quot;Led_MainActivity&quot;;private View btn_setOff;private View btn_setOn;private View btn_init;private View btn_getCount;private View btn_close;static boolean ifInited = false;private ILedService ledProxy = null;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    initViews();    setOnClick();    enableBtn();}@Overrideprotected void onResume() {    ledProxy = ILedService.Stub.asInterface(ServiceManager.getService(&quot;led&quot;));    if (ledProxy == null)        Log.e(TAG, &quot;led service is null!!!&quot;);    else        Log.e(TAG, &quot;led service stub get success!!!&quot;);    super.onResume();}private void enableBtn() {    if (ifInited) {        btn_setOff.setEnabled(true);        btn_setOn.setEnabled(true);        btn_getCount.setEnabled(true);        btn_close.setEnabled(true);    } else {        btn_setOff.setEnabled(false);        btn_setOn.setEnabled(false);        btn_getCount.setEnabled(false);        btn_close.setEnabled(false);    }}private void initViews() {    btn_init = findViewById(R.id.btn_init);    btn_setOn = findViewById(R.id.btn_setOn);    btn_setOff = findViewById(R.id.btn_setOff);    btn_getCount = findViewById(R.id.btn_getCount);    btn_close = findViewById(R.id.btn_close);}private void setOnClick() {    btn_init.setOnClickListener(this);    btn_setOn.setOnClickListener(this);    btn_setOff.setOnClickListener(this);    btn_getCount.setOnClickListener(this);    btn_close.setOnClickListener(this);}@Overridepublic void onClick(View v) {    int id = v.getId();    int i = -1;    switch (id) {        case R.id.btn_init:            try {                i = ledProxy.LedInit();            } catch (RemoteException e) {                e.printStackTrace();            }            Log.d(TAG, &quot;led init...&quot; + String.valueOf(i));            if (!ifInited) {                ifInited = true;                enableBtn();            }            break;        case R.id.btn_setOn:            try {                ledProxy.LedSetOn();            } catch (RemoteException e) {                e.printStackTrace();            }            Log.d(TAG, &quot;led setOn...&quot;);            break;        case R.id.btn_setOff:            try {                ledProxy.LedSetOff();            } catch (RemoteException e) {                e.printStackTrace();            }            Log.d(TAG, &quot;led setOff...&quot;);            break;        case R.id.btn_getCount:            try {                i = ledProxy.LedGetCount();            } catch (RemoteException e) {                e.printStackTrace();            }            Log.d(TAG, &quot;led getCount...&quot; + String.valueOf(i));            break;        case R.id.btn_close:            try {                ledProxy.LedClose();            } catch (RemoteException e) {                e.printStackTrace();            }            Log.d(TAG, &quot;led close...&quot;);            if (ifInited) {                ifInited = false;                enableBtn();            }        default:            break;    }}</code></pre><p>}</p><p>代码相关说明：</p><ol><li>onCreate实现控件的获取绑定、点击监听以及状态切换</li><li>onResume实现获取LedService的远程Proxy代理对象，方便跨进程方法调用</li><li>onClick实现相关控件的点击实现，即调用Proxy代理类相关方法，其中还有控件状态使能控制</li></ol><h4 id="SM获取系统服务的说明"><a href="#SM获取系统服务的说明" class="headerlink" title="SM获取系统服务的说明"></a>SM获取系统服务的说明</h4><p>对于方法 ServiceManager.getService(“led”)，此方法为系统api，直接调用在Android Studio无法实现，这里提供两个方法实现。</p><ul><li>方法一：本项目实现方法，导入系统编译中间framework.jar实现系统api无缝调用</li><li><p>方法二：使用反射方式进行调用，具体方式如下：</p><pre><code>public ILedService getILedServiceProxy() {    ILedService LedService = null;    try {        // 根据指定文件，反射获取类 ServiceManager        Class&lt;?&gt; aClass = Class.forName(&quot;android.os.ServiceManager&quot;);        // 获取类中定义的具体方法 getService        Method getService = aClass.getDeclaredMethod(&quot;getService&quot;, String.class);        // 反射方法到类，即 method + invoke + 类        Object ledIBinder = getService.invoke(aClass, &quot;led&quot;);        // 将 IBinder 对象转成远程代理 Proxy        LedService = ILedService.Stub.asInterface((IBinder) ledIBinder);    } catch (IllegalAccessException e) {        e.printStackTrace();    } catch (InvocationTargetException e) {        e.printStackTrace();    } catch (ClassNotFoundException e) {        e.printStackTrace();    } catch (NoSuchMethodException e) {        e.printStackTrace();    }    return LedService;}</code></pre></li></ul><h3 id="安装调试"><a href="#安装调试" class="headerlink" title="安装调试"></a>安装调试</h3><p>将之前打包好的rom刷写到设备中，重启开机后，Android Studio中终端adb连接到设备中去，开启软件进行调试。</p><h4 id="Log日志"><a href="#Log日志" class="headerlink" title="Log日志"></a>Log日志</h4><p>终端输入 logcat | grep “Led”,查看最终的log日志如下：</p><ol><li><p>led_init</p><p> 3673 I LedServiceJNI: led_init start …<br> 3673 I LedServiceJNI: Device led found…<br> 3673 I LedHALStub: Open led_device successfully!<br> 3673 I LedServiceJNI: led_init success!!!<br> 3659 D Led_MainActivity: led init…0</p></li><li><p>led_setOn</p><p> 2340 D LedService: LedService native_LedSetOn<br> 2340 I LedServiceJNI: led_set_on<br> 2340 I LedHALStub: led_set_on function call!<br> 3659 D Led_MainActivity: led setOn…</p></li><li><p>led_setOff</p><p> 2384 D LedService: LedService native_LedSetOff<br> 2384 I LedServiceJNI: led_set_off<br> 2384 I LedHALStub: led_set_off function call!<br> 3659 D Led_MainActivity: led setOff…</p></li><li><p>led_getCount</p><p> 3673 D LedService: LedService native_LedGetCount<br> 3673 I LedServiceJNI: led_getCount 4<br> 3673 I LedHALStub: led_getCount function call,return led_getCount is 4!<br> 3659 D Led_MainActivity: led getCount…4</p></li><li><p>led_close</p><p> 2391 D LedService: LedService native_LedClose<br> 2391 I LedServiceJNI: led_close<br> 2391 I LedHALStub: led_device close successfully!<br> 3659 D Led_MainActivity: led close…</p></li></ol><p>从log日志可以看出，从上层应用的调用到驱动，经过的流程 Led_MainActivity -&gt; LedServic -&gt; nativce_jni&gt;HAL -&gt; Led_MainActivity ,一次调用过程，完整的透过了安卓的整个框架。至此从安卓HAL层驱动到上层应用的实现就完整结束了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上面的代码实战，透过安卓的硬件抽象层框架，完整的实现了从上层应用到中间层framework，再到驱动的全程调用。这里总结一下整个流程。</p><ol><li>基于安卓HAL框架，实现自定义的驱动，生成相关 *.so 动态库</li><li>对应驱动具体方法，定义framework层AIDL文件，添加到编译文件，并生成相应的Stub类文件</li><li>新建 <em>Service.java 自定义服务，继承于AIDL的中间编译文件 </em>Service.Stub</li><li>将自定义服务添加到SysterServer中，便于登记注册到SM中</li><li>新建 com_android_server_*Service.cpp，完成对应native层代码实现，主要包括方法注册，模块的初始化和设备的打开</li><li>将新建c层jni文件添加到onload.cpp中，实现方法的注册和映射</li><li>修改对应的 Android.mk，将新建文件添加到编译系统中去</li><li>生成最新系统包进行刷写</li><li>提取AIDL文件到应用中，新建应用App通过SM获取LedService服务的远程代理对象Proxy，测试调用其方法，方法经过层层调用，最终指向驱动层实现代码</li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>相关参考</p><blockquote><p>高焕堂安卓架构师系列视频</p></blockquote><blockquote><p>Android系统源代码情景分析</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 驱动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android系统HAL层驱动基础总结</title>
      <link href="/FuckCode/2018/08/18/Android%E7%B3%BB%E7%BB%9FHAL%E5%B1%82%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/"/>
      <url>/FuckCode/2018/08/18/Android%E7%B3%BB%E7%BB%9FHAL%E5%B1%82%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>Android系统HAL层驱动实现原理是基于谷歌提供的框架来展开，从而更好的规避因底层使用linux内核开源核心代码的要求，同时因为其安卓本身遵循Apache Lincence协议，允许厂商修改而不必公开修改的源代码。本文章就其HAL层（硬件抽象层），主要介绍此框架的组成部分、原理框架以及调用流程，为后续的HAL驱动具体实现提供相关的理论基础。</strong></p><a id="more"></a><h3 id="开胃菜-两种开源协议"><a href="#开胃菜-两种开源协议" class="headerlink" title="开胃菜-两种开源协议"></a>开胃菜-两种开源协议</h3><h4 id="GPL协议"><a href="#GPL协议" class="headerlink" title="GPL协议"></a>GPL协议</h4><ul><li>GPL，是GNU General Public License的缩写，是GNU通用公共授权非正式的中文翻译。它并非由自由软件基金会所发表，亦非使用GNU通用公共授权的软件的法定发布条款─只有GNU通用公共授权英文原文的版本始具有此等效力。</li><li>Linux内核源代码遵循的是GPL协议，即对内核源代码进行修改必须将其公开。这带来的问题是如果将驱动的实现细节封装在内核中，就必须公开源代码，这无疑是大大的损坏了众多驱动厂商的经济利益。</li></ul><h4 id="Apache-Licence-协议"><a href="#Apache-Licence-协议" class="headerlink" title="Apache Licence 协议"></a>Apache Licence 协议</h4><ul><li>apache licence（Apache许可证），是Apache软件基金会发布的一个自由软件许可证。</li><li>安卓系统源代码遵循此协议，允许厂商自由修改源代码而不必公开实现的细节。如果可以讲相关的驱动实现细节放到源代码中（及不在内核空间实现），使驱动上移到用户空间中，就能很好的规避这个问题，既维护了第三方厂商的利益，而且还有助于商业的快速推广。</li></ul><h3 id="HAL层驱动总体概括"><a href="#HAL层驱动总体概括" class="headerlink" title="HAL层驱动总体概括"></a>HAL层驱动总体概括</h3><h4 id="基础架构概括"><a href="#基础架构概括" class="headerlink" title="基础架构概括"></a>基础架构概括</h4><p>由于安卓本身基于Linux系统，与硬件直接打交道的驱动实现必须实现在内核空间中。但是由于Linxu协议问题，要求必须公示修改的源代码。最好的方法就是将驱动分别实现于内核空间和用户空间。</p><ol><li>内核空间：以硬件驱动模块形式支持，但是只是简单的提供硬件的访问通道。</li><li>用户空间：以硬件抽象层模块形式支持，封装硬件的实现细节和参数。</li></ol><p>这样，通过上面的分析可以看出，这种折中的方式很好的规避协议带来的问题。驱动开发者只需要在内核中实现相关驱动的硬件硬件接口，将具体驱动的实现细节上升到HAl层实现即可，完全可以将自己的商业利益最大化。</p><h4 id="HAL架构"><a href="#HAL架构" class="headerlink" title="HAL架构"></a>HAL架构</h4><p>HAL层中重要的三个结构体如下图所示，所有的驱动开发厂商都依照这个框架进行实现自己的驱动程序。</p><img src="/FuckCode/2018/08/18/Android系统HAL层驱动分析/hal_jiagou.png" class="HAL层架构示意图"><h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><p>由于驱动层的开发基本都使用c/c++实现，但是由于c没有类似面向对象的类概念，但是有结构体可以代替。但是结构体又不能直接存储函数实现，就必须依照指针声明函数来实现，在结构体声明完毕后，需要将结构体的指针进行赋值即可实现类似面向对象的功能。</p><h5 id="三个重要的结构体"><a href="#三个重要的结构体" class="headerlink" title="三个重要的结构体"></a>三个重要的结构体</h5><ol><li>struct hw_device_t： 硬件抽象层的设备基类，所有的具体设备驱动必须实现此基类，其内部函数指针others由用户自行定义，扩充自己的驱动实现。</li><li>struct hw_module_t： 硬件抽象层的模块基类，一个模块中可以包含多个设备，驱动开发者同样要对这个基类实现自己的驱动模块。内部含有一个重要的成员methods，其对应结构体hw_module_methods_t，在驱动的实现中就静态的实现函数的指向，方便后续的打开操作。其内部others为用户扩充驱动实现。</li><li>struct hw_module_methods_t： 硬件抽象层的函数表定义。其内部只有一个重要的指针函数 open()，其具体功能是协助模块打开设备并完成结构体中函数指针的赋值等重要操作。</li></ol><h5 id="模块导出符号HMI"><a href="#模块导出符号HMI" class="headerlink" title="模块导出符号HMI"></a>模块导出符号HMI</h5><p>在谷歌硬件抽象层模块的编写规范中，其硬件抽象层的每一个模块都必须存在一个符号 <strong><em>HAL_MODULE_INFO_SYM</em></strong>，此符号宏定义于框架中，值为“HMI”。其指向一个自定义的硬件抽象层模块结构体，方便系统加载*.so时辩之为对应的硬件抽象层驱动模块，在后面的模版代码中会详细介绍。</p><h5 id="驱动的命名"><a href="#驱动的命名" class="headerlink" title="驱动的命名"></a>驱动的命名</h5><p>HAL模块驱动以*.so文件存在于 /system/lib/hw 和 /system/lib64/hw 下，其拥有独特的命名方式，具体参考可在 hardware/libandroid/hardware.c 中。</p><pre><code>/** * There are a set of variant filename for modules. The form of the filename * is &quot;&lt;MODULE_ID&gt;.variant.so&quot; so for the led module the Dream variants * of base &quot;ro.product.board&quot;, &quot;ro.board.platform&quot; and &quot;ro.arch&quot; would be: * * led.trout.so * led.msm7k.so * led.ARMV6.so * led.default.so */</code></pre><ol><li>硬件抽象层模块文件的命名规范为“&lt;MODULE_ID&gt;.variant.so”,</li><li>其中，MODULE_ID代表模块的ID，variant表示四个系统属性 ro.hardware, ro.pproduct.board, ro.board.platform, ro.arch 之一。</li><li>系统在加载硬件抽象层模块是会依次取出其值，根据对应值到文件名称，检查文件是否存在。存在便找到了加载的硬件抽象层模块，否则便继续查找下一个属性。</li><li>如果四个属性对应的文件都不存在，便使用“&lt;MODULE_ID&gt;.defaule.so”作为加载的硬件抽象层模块文件。</li></ol><h5 id="驱动的调用"><a href="#驱动的调用" class="headerlink" title="驱动的调用"></a>驱动的调用</h5><p>HAL框架提供了一个公用的函数 hw_get_module 实现一键加载hal驱动。其大致调用流程如下：</p><ol><li>传入模块id，根据module_id去查找注册在当前系统中与id对应的硬件对象</li><li>然后载入(load)其相应的HAL层驱动模块的 *so 文件</li><li>从*.so里查找”HMI”这个符号，如果在so 代码里有定义的函数名或变量名为HMI，返回其地址</li></ol><p>图示如下：</p>  <img src="/FuckCode/2018/08/18/Android系统HAL层驱动分析/hal_liucheng.png" class="hal驱动调用图示一览"><h3 id="HAL模版代码"><a href="#HAL模版代码" class="headerlink" title="HAL模版代码"></a>HAL模版代码</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p>HAL层头文件路径一般位于<strong>/hardware/libhardware/include/hardware/*</strong>下。头文件除了在编写中还需要#include &lt;hardware/hardware.h&gt;这个HAL层关键的头文件，其文件定于本路径的上级include同级目录下。</p><p>头文件模版代码如下：</p><pre><code>#ifndef ANDROID_LED_INTERFACE_H#define ANDROID_LED_INTERFACE_H#include &lt;hardware/hardware.h&gt;__BEGIN_DECLS#define LED_HARDWARE_MODULE_ID &quot;led&quot;#define LED_HARDWARE_DEVICE_ID &quot;led&quot;typedef struct led_module_t {    struct hw_module_t common;} led_module_t;typedef struct led_device_t {    struct hw_device_t common;    others (void*);} led_device_t;static inline int led_device_open(const struct hw_module_t* module,    led_device_t** dev){    return module-&gt;methods-&gt;open(module,LED_HARDWARE_DEVICE_ID,        (struct hw_device_t**) dev);}static inline int led_device_close(led_device_t* dev){    return dev-&gt;common.close(&amp;dev-&gt;common);}__END_DECLS#endif</code></pre><ol><li>模版代码中，宏定义模块及设备id，方便c层文件导包导入so模块。</li><li>结构体 struct led_module_t 是用户扩充框架中的 struct hw_module_t 结构体，其内部成员commom必须放在第一个位置，保证led_module_t的地址和hw_module_t相一致。此模版为源码中约定俗成的固定写法，用户实现参考即可。</li><li>结构体 struct led_device_t 扩充框架中的 struct hw_device_t 结构体。其为设备的具体信息，包括tag，version，id等等。后年的赋值操作会涉及到。</li><li>typedef 用于提前声明变量，便于在后续导包开发中避免多次声明指定的结构体变量。</li><li>两个静态inline内联函数，方便模块设备的打开以及关闭。其也可不必放在头文件中。这里参考源码中的形式放于此处。</li></ol><h4 id="驱动本体实现"><a href="#驱动本体实现" class="headerlink" title="驱动本体实现"></a>驱动本体实现</h4><p>驱动的本体实现代码路径位于 <strong>/hardware/libhardware/modules/led/*</strong>下，其中的最后的led为实际模块的名称文件夹。其同级文件下还有一个mk编译文件，方便生成指定的动态链接库。</p><p>具体实现参考代码如下：</p><pre><code>#define LOG_TAG &quot;LedHALStub&quot;#include &lt;hardware/hardware.h&gt;#include &lt;hardware/led.h&gt;#include &lt;cutils/log.h&gt;#include &lt;malloc.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;math.h&gt;#include &lt;memory.h&gt;#define MODULE_NAME &quot;Led&quot;#define MODULE_AUTHOR &quot;891904833@qq.com&quot;static int led_set_on(led_device_t* dev) {...}static int led_set_off(led_device_t* dev) {...}static int led_getCount(led_device_t* device) {...}static int led_close(hw_device_t* device) {  if(device){    free(device);  }  return 0;}static int led_open(const hw_module_t* module, const char* id,    hw_device_t** device) {        led_device_t *dev = (led_device_t *)calloc(1, sizeof(led_device_t));        if(!dev) {            ALOGE(&quot;Failed to alloc space for led_device_t.&quot;);            return -EFAULT;        }        memset(dev, 0, sizeof(struct led_device_t));        dev-&gt;common.tag = HARDWARE_DEVICE_TAG;        dev-&gt;common.version = 0;        dev-&gt;common.module = (struct hw_module_t*)module;        dev-&gt;common.close = led_close;        dev-&gt;set_on = led_set_on;        dev-&gt;set_off = led_set_off;        dev-&gt;getCount = led_getCount;        *device = &amp;dev-&gt;common;        ALOGI(&quot;Open led_device successfully!&quot;);        return 0;}static struct hw_module_methods_t my_methods = {    .open = led_open,};struct led_module_t HAL_MODULE_INFO_SYM = {    .common = {        .tag = HARDWARE_MODULE_TAG,        .version_major = 1,        .version_minor = 0,        .id = LED_HARDWARE_MODULE_ID,        .name = MODULE_NAME,        .author = MODULE_AUTHOR,        .methods = &amp;my_methods,    },};</code></pre><ol><li>首先代码最后声明结构体 led_module_t HAL_MODULE_INFO_SYM ，方便系统根据模块id导入合适的库文件，其第一个成员变量的类型必须为 hw_module_t，从中我们可以看出common即为指定的结构体变量。其次是common中的第一成员id，必须指定为HARDWARE_MODULE_TAG。方便用户调用 hw_get_module 传入模块名称找到对应的模块设备。同时此模块的另些属性也在此期间进行赋值。</li><li>struct hw_module_methods_t 为模版结构体中重要的函数指针映射。其来源于导库操作中的最后一个成员的赋值 .methods = &amp;my_methods，通过函数指针其最终指向led_open这个方法，协助设备的打开操作。</li><li>led_open 方法具体为设备的打开过程。通过 calloc 操作分配内存，memset 实现内存的初始化。其中需要注意设备的 close 方法属于 dev-&gt;common.close 内。通过指针赋值，预先将结构体中相关的函数指针填充，为后续调用做基础。</li><li>最上面的static int（void）** 方法为用户自定义驱动具体实现，这里省略。</li><li>在头文件中涉及到设备的打开，具体是通过框架提供的 hw_module_t 结构体中的 methods 方法 open 函数实现，  即 module-&gt;methods-&gt;open(module,LED_HARDWARE_DEVICE_ID,<br>(struct hw_device_t**) dev)；</li><li>同样设备的关闭操作通过 struct hw_device_t 的 close 方法实现，即 dev-&gt;common.close(&amp;dev-&gt;common)；</li></ol><h4 id="打开驱动设备代码预览"><a href="#打开驱动设备代码预览" class="headerlink" title="打开驱动设备代码预览"></a>打开驱动设备代码预览</h4><p>驱动本体实现完成后，通过mk文件打包成 *.so 文件,生成于 /system/lib/hw 和 /system/lib64/hw 下。通过上层c文件实现驱动的打开调用，基本参考代码流程如下：</p><pre><code>static jint led_init(JNIEnv *env, jobject instance){     led_module_t* module;     ALOGI(&quot;led_init start ...&quot;);     if (hw_get_module(LED_HARDWARE_MODULE_ID, (hw_module_t const**)&amp;module) == 0) {         ALOGI(&quot;Device led found...&quot;);         if (led_device_open(&amp;(module-&gt;common), &amp;mLedDevice ) == 0) {             ALOGI(&quot;led_init success!!!&quot;);                        return 0;         }         ALOGE(&quot;led_init error!!!&quot;);     }     ALOGI(&quot;hw_get_module function call error!!!&quot;);     return -1; }</code></pre><ol><li>通过 hw_get_module 方法，传入模块id，找到指定模块。</li><li>通过 led_device_open 方法，打开设备，将设备实例放于变量 mLedDevice 中。</li><li>通过获取到的设备实例 mLedDevice ，直接调用其具体驱动方法即可。</li></ol><h3 id="HAL层驱动调用总结"><a href="#HAL层驱动调用总结" class="headerlink" title="HAL层驱动调用总结"></a>HAL层驱动调用总结</h3><p>根据HAL层驱动框架的介绍，分析出驱动模块的具体流程,首先来看一下代码的总体结构，如下图：</p><img src="/FuckCode/2018/08/18/Android系统HAL层驱动分析/hal_zongjie.png" class="HAL驱动调用流程"><h4 id="找到-hw-get-module"><a href="#找到-hw-get-module" class="headerlink" title="找到 hw_get_module"></a>找到 hw_get_module</h4><p>根据HAL框架提供的公有函数 hw_get_module ，传入模块设备名称，在导入的so库文件中根据 HAL_MODULE_INFO_SYM 识别出驱动模块后，找到对应的具体 id 驱动模块，并在运行时完成结构体中相关指针函数的赋值。其中涉及到open方法的映射，方便设备的进一步打开。</p><h4 id="open-打开设备分配内存"><a href="#open-打开设备分配内存" class="headerlink" title="open 打开设备分配内存"></a>open 打开设备分配内存</h4><p>在上述流程走完之后，相关结构体中的函数指针均已经赋值完成，继而调用框架提供的 hw_module_t 结构体中的 methods 方法 open 函数实现设备的打开，设备打开过程中，便实现了用户自有驱动实现方法函数指针的赋值过程，此流程走完之后，便可以通过自定的 结构体（扩充 hw_device_t 实现的）调用自有驱动逻辑。</p><h4 id="获取自有设备驱动实例"><a href="#获取自有设备驱动实例" class="headerlink" title="获取自有设备驱动实例"></a>获取自有设备驱动实例</h4><p>在open方法调用后，完成了设备实例结构体内具体函数指针的赋值，此时用户便可以通过获取的设备实例直接调用自有结构体内的指针函数，实现驱动的具体调用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的介绍分析，总体知晓了安卓硬件抽象层的工作流程，后续会针对此部分来一篇实战博客进一步加强。谷歌通过硬件抽象层框架，成功将驱动分别实现在内核和用户空间，通过内核空间和用户空间的配合，实现驱动的无缝链接。此举一方面维护了众多厂商的商业利益，另一方面也遵循了GPL协议和Apache Licence协议，真可谓一举两的。在这里不由得赞叹谷歌架构师的超高水平。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>参考书籍文章如下：</p><blockquote><p>高焕堂架构师系列视频</p></blockquote><blockquote><p>Android系统源代码情景分析</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HAL驱动 </category>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HAL驱动 </tag>
            
            <tag> 项目实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binder系统分析之SM大管家的获取流程</title>
      <link href="/FuckCode/2018/07/30/Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BSM%E5%A4%A7%E7%AE%A1%E5%AE%B6%E7%9A%84%E8%8E%B7%E5%8F%96%E6%B5%81%E7%A8%8B/"/>
      <url>/FuckCode/2018/07/30/Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BSM%E5%A4%A7%E7%AE%A1%E5%AE%B6%E7%9A%84%E8%8E%B7%E5%8F%96%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>之前介绍了Binder跨进程通信中AIDL文件的具体实现流程，之后又实现Native层、framework层Binder框架的具体使用范例。其使用规范都是基于底层设计好的框架之上，本章节就针对其框架，步步分析其实现流程背后的原理，对着代码一步一步追溯到源头，废话不多说，Fucking Code！</strong></p><a id="more"></a><h3 id="ServiceManager的获取流程"><a href="#ServiceManager的获取流程" class="headerlink" title="ServiceManager的获取流程"></a>ServiceManager的获取流程</h3><p>对于上层应用来说，获取ServiceManager大管家的方式无非两种，一种是framework层获取，一种是Native层获取，具体对应方式如下</p><h4 id="framework层获取SM"><a href="#framework层获取SM" class="headerlink" title="framework层获取SM"></a>framework层获取SM</h4><h5 id="原生API获取服务流程浅析"><a href="#原生API获取服务流程浅析" class="headerlink" title="原生API获取服务流程浅析"></a>原生API获取服务流程浅析</h5><p>对于Java层获取SM方式，相信对于应用层开发来说非常熟悉了，我们可以通过类ServiceManager.getService()方法，通过传入服务名称来获取对应的远程代理服务对象。例如获取闹钟服务时，调用代码 <strong><em>getSystemService(Context.ALARM_SERVICE)</em></strong> 即可获取相应服务，然而其内部获取的流程是如何实现的呢？下面我们追溯代码看一下具体调用流程。</p><ul><li><p>通过Activity的getSystemService()方法，我们追溯下去</p><pre><code>@Overridepublic Object getSystemService(@ServiceName @NonNull String name) {    if (getBaseContext() == null) {        throw new IllegalStateException(                &quot;System services not available to Activities before onCreate()&quot;);    }    if (WINDOW_SERVICE.equals(name)) {        return mWindowManager;    } else if (SEARCH_SERVICE.equals(name)) {        ensureSearchManager();        return mSearchManager;    }    return super.getSystemService(name);}</code></pre><p>  通过super.getSystemService(name)调用父类的getSystemService</p></li><li><p>ContextThemeWrapper的getSystemService</p><pre><code>@Overridepublic Object getSystemService(String name) {    if (LAYOUT_INFLATER_SERVICE.equals(name)) {        if (mInflater == null) {            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this);        }        return mInflater;    }    return getBaseContext().getSystemService(name);}</code></pre></li><li><p>通过getBaseContext()调用父类的方法</p><pre><code>public Context getBaseContext() {    return mBase;}@Overridepublic Object getSystemService(String name) {    return mBase.getSystemService(name);}</code></pre><p>  其中的mBase实际指向Context类</p></li><li><p>Context的具体方法实现</p><pre><code>public abstract @Nullable Object getSystemService(@ServiceName @NonNull String name);</code></pre><p>  貌似到这里就停下来，其提供一个抽象方法由子类实现，最后是谁来实现呢？Context类有一个实现类ContextImp，我们来看一下里面的内容。</p></li><li><p>ContextImp的getSystemService方法</p><pre><code>@Overridepublic Object getSystemService(String name) {    return SystemServiceRegistry.getSystemService(this, name);}</code></pre><p>  间接调用了SystemServiceRegistry类的getSystemService()方法</p></li><li><p>SystemServiceRegistry具体方法</p><pre><code>public static Object getSystemService(ContextImpl ctx, String name) {    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);    return fetcher != null ? fetcher.getService(ctx) : null;}</code></pre><p>  由类名SystemServiceRegistry可知，此类和服务注册有关，其内部有两个重要的静态私有成员常量(final修饰的变量)中保存了Hash列表，如下：</p><pre><code>private static final HashMap&lt;Class&lt;?&gt;, String&gt; SYSTEM_SERVICE_NAMES =        new HashMap&lt;Class&lt;?&gt;, String&gt;();private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =        new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</code></pre><p>  其中ServiceFetcher为一个接口，其返回一个范性T，SystemServiceRegistry内部有三个具体类实现了此接口</p><pre><code>static abstract interface ServiceFetcher&lt;T&gt; {    T getService(ContextImpl ctx);}// 其中的一个实现类如下static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; {    private final int mCacheIndex;    public CachedServiceFetcher() {        mCacheIndex = sServiceCacheSize++;    }    @Override    @SuppressWarnings(&quot;unchecked&quot;)    public final T getService(ContextImpl ctx) {        final Object[] cache = ctx.mServiceCache;        synchronized (cache) {            // Fetch or create the service.            Object service = cache[mCacheIndex];            if (service == null) {                service = createService(ctx);                cache[mCacheIndex] = service;            }            return (T)service;        }    }    public abstract T createService(ContextImpl ctx);}</code></pre><p>  在类的前面有一大片的静态代码块，其中涉及到了服务的初始化注册代码。</p></li><li><p>SystemServiceRegistry静态代码块</p><pre><code>static {    ...    registerService(Context.ALARM_SERVICE, AlarmManager.class,        new CachedServiceFetcher&lt;AlarmManager&gt;() {    @Override    public AlarmManager createService(ContextImpl ctx) {        IBinder b = ServiceManager.getService(Context.ALARM_SERVICE);        IAlarmManager service = IAlarmManager.Stub.asInterface(b);        return new AlarmManager(service, ctx);    }});    ...}</code></pre></li><li><p>通过registerService()方法，缓存系统相关服务，方便用户获取</p><pre><code>private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,        ServiceFetcher&lt;T&gt; serviceFetcher) {    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);}</code></pre><ol><li>参数一：服务名称</li><li>参数二：服务具体类文件</li><li>参数三：服务对应的ServiceFetcher对象</li></ol></li></ul><p>到这里基本就可以看到最终的调用结果，即通过SM获取IBinder远程服务代理对象，然后通过IAlarmManager.Stub.asInterface()方法将IBinder对象转换成可以使用的IAlarmManager服务对象</p><pre><code>IBinder b = ServiceManager.getService(Context.ALARM_SERVICE)；IAlarmManager service = IAlarmManager.Stub.asInterface(b);</code></pre><p>到这里，是不是和AIDL中流程分析很相似呢？不错，其调用获取、转换方式基本都是一致的。下面我们来具体分析真正的SM获取流程。</p><h5 id="framework层获取sm分析"><a href="#framework层获取sm分析" class="headerlink" title="framework层获取sm分析"></a>framework层获取sm分析</h5><p>上面小结分析得出最终调用的方式为<strong><em>IBinder b = ServiceManager.getService(Context.ALARM_SERVICE)；</em></strong>，我们就由此开始分析。</p><ul><li><p>ServiceManager.getService()</p><pre><code>//getService()最终获取了指向目标Binder服务端的代理对象BinderProxypublic static IBinder getService(String name) {    try {        //其中sCache = new HashMap&lt;String, IBinder&gt;() 以hashmap格式缓存已组成的名称        // 请求获取服务过程中，先从缓存中查询是否存在，如果缓存中不存在的话，再通过binder交互来查询相应的服务        IBinder service = sCache.get(name);        if (service != null) {            return service;        } else {            //调用的是ServiceManagerNative的ServiceManagerProxy的getService（）            return getIServiceManager().getService(name);        }    } catch (RemoteException e) {        Log.e(TAG, &quot;error in getService&quot;, e);    }    return null;}</code></pre><p>  代码注释很详细，sCache为一个HashMap，键值分别为服务名、IBinder对象。首先从缓存中获取服务的IBinder对象，不存在，就调用getIServiceManager().getService(name)来获取。</p></li><li><p>getIServiceManager().getService()</p><pre><code>//返回的是ServiceManagerProxy对象private static IServiceManager getIServiceManager() {    if (sServiceManager != null) {        return sServiceManager;    }    // Find the service manager    // ServiceManagerNative.asInterface(BinderInternal.getContextObject()) == new ServiceManagerProxy(new BinderProxy())    sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());    return sServiceManager;}</code></pre><p>  getIServiceManager获取到类内部的静态的IServiceManager对象，IServiceManager接口继承自IInterface接口，是不是又是很亲切，哈哈！其最终对应的是SM的远程代理对象ServiceManagerProxy。这里首先透露一下，ServiceManagerNative.asInterface(BinderInternal.getContextObject())方法通过jni调用c层代码，获取位于c层的handle值为0的binder引用对象，其对应的正是ServiceManager对象大管家。<br>  获取到了SM大管家，通过传入的服务名称即可获取相应的远程代理服务对象了。由于IServiceManager继承自IInterface接口，所以我们需要找到实现IServiceManager接口的类即可找到具体的实现方法。</p></li><li><p>BinderInternal.getContextObject()</p></li></ul><ul><li><p>ServiceManagerNative.getService()<br>ServiceManagerProxy实际上在ServiceManagerNative文件中，ServiceManagerProxy类有一个IBinder对象mRemote，其是Binder驱动为服务分配的远程服务代理对象，这个和AIDL中分析的相一致，而mRemote对象就是和Binder驱动进行通信的关键。</p><pre><code>/** * 其成员变量mRemote指向BinderProxy对象 * ServiceManagerProxy的addService, getService方法最终是交由mRemote来完成 */class ServiceManagerProxy implements IServiceManager {    //mRemote是BinderProxy的对象，该BinderProxy对象对应于BpBinder（0）    //其作为binder代理管家，指向native层的大管家Service Manager    public ServiceManagerProxy(IBinder remote) {        mRemote = remote;    }    public IBinder asBinder() {        return mRemote;    }    //getService()最终获取了指向目标Binder服务端的代理对象BinderProxy    public IBinder getService(String name) throws RemoteException {        //此处需要将java层的Parcel转成Native层的Parcel        Parcel data = Parcel.obtain();        Parcel reply = Parcel.obtain();        data.writeInterfaceToken(IServiceManager.descriptor);        data.writeString(name);        //mRemote为BinderProxy对象        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);        //从replay里面解析出获取的IBinder对象,调用Parcel.java中native方法        //最终创建了指向Binder服务端的BpBinder代理对象        IBinder binder = reply.readStrongBinder();        reply.recycle();        data.recycle();        return binder;    }    public IBinder checkService(String name) throws RemoteException {        ...     }    public void addService(String name, IBinder service, boolean allowIsolated)            throws RemoteException {        ...    }    public String[] listServices() throws RemoteException {        ...    }    public void setPermissionController(IPermissionController controller)            throws RemoteException {        ...    }    private IBinder mRemote;}</code></pre><p>  由上代码可以看出getService()方法，最终由Parcel数据封装服务信息，调用mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0)方法与Binder驱动进行交互。<br>  在AIDL分析文章中介绍类Binder和IBinder的作用，现在我们查看一下其具体的代码。</p></li><li><p>Binder文件一览分析</p><pre><code>public class Binder implements IBinder {    public IInterface queryLocalInterface(String descriptor) {        ...    }    protected boolean onTransact(int code, Parcel data, Parcel reply,            int flags) throws RemoteException {        if (code == INTERFACE_TRANSACTION) {            reply.writeString(getInterfaceDescriptor());            return true;        } else if (code == DUMP_TRANSACTION) {            ParcelFileDescriptor fd = data.readFileDescriptor();            String[] args = data.readStringArray();            if (fd != null) {                try {                    dump(fd.getFileDescriptor(), args);                } finally {                    try {                        fd.close();                    } catch (IOException e) {                        // swallowed, not propagated back to the caller                    }                }            }            // Write the StrictMode header.            if (reply != null) {                reply.writeNoException();            } else {                StrictMode.clearGatheredViolations();            }            return true;        }        return false;    }    public final boolean transact(int code, Parcel data, Parcel reply,            int flags) throws RemoteException {        if (false) Log.v(&quot;Binder&quot;, &quot;Transact: &quot; + code + &quot; to &quot; + this);        if (data != null) {            data.setDataPosition(0);        }        boolean r = onTransact(code, data, reply, flags);        if (reply != null) {            reply.setDataPosition(0);        }        return r;    }    private boolean execTransact(int code, long dataObj, long replyObj,            int flags) {        Parcel data = Parcel.obtain(dataObj);        Parcel reply = Parcel.obtain(replyObj);        boolean res;         try {            res = onTransact(code, data, reply, flags);        } catch (RemoteException e) {            if ((flags &amp; FLAG_ONEWAY) != 0) {                Log.w(TAG, &quot;Binder call failed.&quot;, e);            } else {                reply.setDataPosition(0);                reply.writeException(e);            }            res = true;        } catch (RuntimeException e) {            if ((flags &amp; FLAG_ONEWAY) != 0) {                Log.w(TAG, &quot;Caught a RuntimeException from the binder stub implementation.&quot;, e);            } else {                reply.setDataPosition(0);                reply.writeException(e);            }            res = true;        } catch (OutOfMemoryError e) {            RuntimeException re = new RuntimeException(&quot;Out of memory&quot;, e);            reply.setDataPosition(0);            reply.writeException(re);            res = true;        }        checkParcel(this, code, reply, &quot;Unreasonably large binder reply buffer&quot;);        reply.recycle();        data.recycle();        ...        StrictMode.clearGatheredViolations();        return res;    }}final class BinderProxy implements IBinder {    public native boolean pingBinder();    public native boolean isBinderAlive();    public IInterface queryLocalInterface(String descriptor) {        return null;    }    //最终交由Native层的BpBinder::transact()完成    //另外，该方法可抛出RemoteException    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {        //用于检测Parcel大小是否大于800k        Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);        return transactNative(code, data, reply, flags);    }    public native String getInterfaceDescriptor() throws RemoteException;    //对应android_util_Binder.cpp下android_os_BinderProxy_transact具体方法    public native boolean transactNative(int code, Parcel data, Parcel reply,            int flags) throws RemoteException;    public native void linkToDeath(DeathRecipient recipient, int flags)            throws RemoteException;    public native boolean unlinkToDeath(DeathRecipient recipient, int flags);    public void dumpAsync(FileDescriptor fd, String[] args) throws RemoteException {        Parcel data = Parcel.obtain();        Parcel reply = Parcel.obtain();        data.writeFileDescriptor(fd);        data.writeStringArray(args);        try {            transact(DUMP_TRANSACTION, data, reply, FLAG_ONEWAY);        } finally {            data.recycle();            reply.recycle();        }    }    BinderProxy() {        mSelf = new WeakReference(this);    }    @Override    protected void finalize() throws Throwable {        try {            destroy();        } finally {            super.finalize();        }    }    private native final void destroy();    private static final void sendDeathNotice(DeathRecipient recipient) {        if (false) Log.v(&quot;JavaBinder&quot;, &quot;sendDeathNotice to &quot; + recipient);        try {            recipient.binderDied();        }        catch (RuntimeException exc) {            Log.w(&quot;BinderNative&quot;, &quot;Uncaught exception from death notification&quot;,                    exc);        }    }    final private WeakReference mSelf;    private long mObject;    private long mOrgue;}</code></pre><p>  代码比较多，这里知识贴出来大概通览一遍，如果是对AIDL文件实现流程很清晰的话，便会很快的找到共同点。这里作一个大概的解读。</p><ol><li>BinderProxy实现IBinder接口，ServiceManagerProxy内的IBinder对象mRemote即是SM远程代理实例，mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0)便是通过BinderProxy类的transact方法，继而进入jni通过c调用与Binder驱动进行交互。</li><li>Binder也实现了IBinder接口，但是其对应的是Server端的对象，是本地Binder服务。其接受远程mRemote代理对象通过Binder驱动传来请求，处理并返回。此期间Client端处于堵塞状态。自定义的Server端服务可以通过继承Binder，实现其onTransact方法即可，此方法由于驱动支持，会自动调用。</li><li>进程间数据均由Parcel封装，data.***方法由底层jni实现，便于与驱动交互。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Binder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ServiceManager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binder系统分析之Native层、framework层使用</title>
      <link href="/FuckCode/2018/07/16/Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BNative%E5%B1%82%E3%80%81framework%E5%B1%82%E4%BD%BF%E7%94%A8/"/>
      <url>/FuckCode/2018/07/16/Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BNative%E5%B1%82%E3%80%81framework%E5%B1%82%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>上篇文章中，我们详细的了解了AIDL的使用流程。其关键点在于对系统编译生成的AIDL生成中间文件中Binder类以及IBinder接口的实现。系统提供的这两个类很关键，下面我们分别从Native层以及framework实现一下自定义的Binder程序。</strong></p><a id="more"></a><h3 id="在Native层实现Binder"><a href="#在Native层实现Binder" class="headerlink" title="在Native层实现Binder"></a>在Native层实现Binder</h3><p>Binder基于C/S架构，在这里，我们需要分别实现Server端和Client端，提取出公共的接口文件IService。同时还要注意几个关键类，他们在Binder实现中起到了关键作用，下面会具体介绍。源码程序参考罗升阳博客内的代码，删减了其内部打开设备，获取寄存器值等相关逻辑，还是很有参考性的。</p><h4 id="项目基本文件结构"><a href="#项目基本文件结构" class="headerlink" title="项目基本文件结构"></a>项目基本文件结构</h4><p>由源码目录层级展示如下：</p><ul><li><p>公共接口文件</p><pre><code>/external/binder/common    IFregService.h    IFregService.cpp</code></pre></li><li><p>服务端程序</p><pre><code>/external/binder/server    FregService.cpp    Android.mk</code></pre></li><li><p>客户端程序</p><pre><code>/external/binder/client    FregClient.cpp    Android.mk</code></pre></li></ul><h4 id="Server端实现"><a href="#Server端实现" class="headerlink" title="Server端实现"></a>Server端实现</h4><h5 id="FregServer-cpp"><a href="#FregServer-cpp" class="headerlink" title="FregServer.cpp"></a>FregServer.cpp</h5><pre><code>#define LOG_TAG &quot;FregServer&quot;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;utils/Log.h&gt;#include &lt;binder/IServiceManager.h&gt;#include &lt;binder/IPCThreadState.h&gt;#include &quot;../common/IFregService.h&quot;#define FREG_DEVICE_NAME &quot;/dev/freg&quot;// 实现Binder的本地对象FregService的具体实现，实现了IFregService接口// 具体的Server端模块实现class FregService : public BnFregService{public:    // 构造函数实现    FregService(){    }    // 析构函数    virtual ~FregService(){    }public:    // 讲台初始化函数    static void instantiate()    {        // 获取ServiceManager，注册Server端服务FREG_SERVICE（shy.luo.FregService）        defaultServiceManager()-&gt;addService(String16(FREG_SERVICE), new FregService());    }    // 方法的具体实现，由IFregService中父类传递调用，读取寄存器值    int32_t getVal(){        return mVal;    }    // 同上方法，设置寄存器值    void setVal(int32_t val){            mVal = val;    }private:    int mVal = 100;};// 主程序int main(int argc, char** argv){    // 初始化    FregService::instantiate();    // 获取进程，开启Binder线程池    ProcessState::self()-&gt;startThreadPool();    // 获取线程，加入到Binder线程池中    IPCThreadState::self()-&gt;joinThreadPool();    return 0;}</code></pre><p>程序相关说明如下：</p><ol><li>FregService继承于BnFregService，BnFregService会在后面接口文件中涉及</li><li>defaultServiceManager()用来获取系统服务关系程序ServiceManager，其是Binder架构中的上下文管理者，任何服务都要先在其中注册，然后再从中获取到对应服务的代理对象，完成相应逻辑</li><li>addService()向SM注册服务，传入服务的描述名和服务对象，以便SM为其分配代理对象等</li><li>ProcessState::self()用于获取本地进程，内部使用单例模式，返回本地进程</li><li>startThreadPool开启本进程的线程池服务，用于等待客户端请求通知</li><li>IPCThreadState::self()获取进程对应的当前线程，joinThreadPool则是将当前线程加入到线程池中进行处理</li></ol><h5 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h5><pre><code>LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := ../common/IFregService.cpp \    FregServer.cppLOCAL_SHARED_LIBRARIES:= libcutils libutils libbinderLOCAL_MODULE := FregServerinclude $(BUILD_EXECUTABLE)</code></pre><p>编译文件内容，使用的共享库有三个，在要是在代码中使用了几个关键的类，编译为可执行程序。其他的这里不做过多介绍了。</p><h4 id="Client端实现"><a href="#Client端实现" class="headerlink" title="Client端实现"></a>Client端实现</h4><h5 id="FregClient-cpp"><a href="#FregClient-cpp" class="headerlink" title="FregClient.cpp"></a>FregClient.cpp</h5><p>客户端实现基于服务端，需要从SM中获取在使用其提供的服务方法，具体代码如下：</p><pre><code>#define LOG_TAG &quot;FregClient&quot;#include &lt;utils/Log.h&gt;#include &lt;binder/IServiceManager.h&gt;#include &quot;../common/IFregService.h&quot;// Client端模块// 主程序int main(){    // 由Servcer端注册的服务，这里通过ServiceManager获取相应服务    sp&lt;IBinder&gt; binder = defaultServiceManager()-&gt;getService(String16(FREG_SERVICE));    if(binder == NULL) {        ALOGE(&quot;Failed to get freg service: %s.\n&quot;, FREG_SERVICE);        return -1;    }    // 获取binder是实现了IFergService接口的对象，这里可以直接转    sp&lt;IFregService&gt; service = IFregService::asInterface(binder);    if(service == NULL) {        ALOGE(&quot;Failed to get freg service interface.\n&quot;);        return -2;    }    printf(&quot;Read original value from FregService:\n&quot;);    // 通过代理对象，调用其getVal方法获取寄存器值    int32_t val = service-&gt;getVal();    printf(&quot; %d.\n&quot;, val);    printf(&quot;Add value 9 to FregService.\n&quot;);        val += 9;    // 通过代理对象，调用setVal设置寄存器值    service-&gt;setVal(val);    printf(&quot;Read the value from FregService again:\n&quot;);    // 在此读取寄存器值    val = service-&gt;getVal();        printf(&quot; %d.\n&quot;, val);     return 0;}</code></pre><p>代码相关说明：</p><ol><li>defaultServiceManager()-&gt;getService()同样通过SM上下文管理者获取指定传入服务</li><li>获取到的服务统一以接口IBinder类型返回，有强引用sp维护生命周期</li><li>IFregService::asInterface()用于将获取的接口实例转换成需要的服务实例，具体在下面接口文件中分析</li><li>service-&gt;getVal(),setVal()根绝获取服务，调用其服务方法</li></ol><p>从这里，不免可以看出之前AIDL文章中分析到的中间文件内容，在下面的接口文件分析中将更加清晰。</p><h5 id="Android-mk-1"><a href="#Android-mk-1" class="headerlink" title="Android.mk"></a>Android.mk</h5><pre><code>LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := ../common/IFregService.cpp \    FregClient.cppLOCAL_SHARED_LIBRARIES:= libcutils libutils libbinderLOCAL_MODULE := FregClientinclude $(BUILD_EXECUTABLE)</code></pre><p>和上面的编译文件基本相似，最后同样生成可执行程序。</p><h4 id="IFregService接口文件实现"><a href="#IFregService接口文件实现" class="headerlink" title="IFregService接口文件实现"></a>IFregService接口文件实现</h4><h5 id="IFregService-h"><a href="#IFregService-h" class="headerlink" title="IFregService.h"></a>IFregService.h</h5><pre><code>#ifndef IFREGSERVICE_H_#define IFREGSERVICE_H_#include &lt;utils/RefBase.h&gt;#include &lt;binder/IInterface.h&gt;#include &lt;binder/Parcel.h&gt;#define FREG_SERVICE &quot;shy.luo.FregService&quot;using namespace android;// 接口声明class IFregService: public IInterface{public:    // 特定宏，声明IFregService的元接口    DECLARE_META_INTERFACE(FregService);    // 两个虚方法，子类实现    virtual int32_t getVal() = 0;    virtual void setVal(int32_t val) = 0;};// 本地（Binder）FregService对象class BnFregService: public BnInterface&lt;IFregService&gt;{public:    // 模板类BnInterface的成员函数onTransact    virtual status_t onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0);};#endif</code></pre><p>代码说明集中如下：</p><ol><li>导包中有&lt;binder/IInterface.h&gt;，其为底层Binder为上层提供跨进程通信的函数模版，具体内容等待介绍</li><li>导包中有&lt;binder/Parcel.h&gt;，Parcel类为数据在Binder机制中传输的媒介，任何数据进行传输都要进行封包Parcel，然后再拆包</li><li>FREG_SERVICE为服务唯一描述符，注册，获取均要使用它</li><li>IFregService继承于IInterface，这里可以看出AIDL中自定义的接口也是继承IInterface</li><li>DECLARE_META_INTERFACE，为IInterface模版函数提供的元接口，后续讲到</li><li>BnFregService为本地服务Binder服务，相同的Bp…则是远程，其继承BnInterface，范型<br>为IFregService，其代表服务端收到请求处理onTransact方法</li></ol><p>由上，引出来一个重要的文件IInterface.h，下面我们集中分析它。</p><h5 id="IFregService-cpp"><a href="#IFregService-cpp" class="headerlink" title="IFregService.cpp"></a>IFregService.cpp</h5><p>头文件已经分析完了，下面来看看IFregService.cpp文件具体内容</p><pre><code>#define LOG_TAG &quot;IFregService&quot;#include &lt;utils/Log.h&gt;#include &quot;IFregService.h&quot;using namespace android;// 枚举，对应通信两个方法enum {    GET_VAL = IBinder::FIRST_CALL_TRANSACTION,    SET_VAL};// 模板类BpInterface的实现类，Binder远程代理实现class BpFregService: public BpInterface&lt;IFregService&gt;{public:    // 构造函数    BpFregService(const sp&lt;IBinder&gt;&amp; impl)         : BpInterface&lt;IFregService&gt;(impl){    }public:    //代理对象，具体实现    int32_t getVal(){        Parcel data;        data.writeInterfaceToken(IFregService::getInterfaceDescriptor());        Parcel reply;        // remote（）函数来获取BpBinder代理对象        // 调用代理对象的transact请求运行在Server进程的一个Binder对象执行GET_VAL方法        remote()-&gt;transact(GET_VAL, data, &amp;reply);        int32_t val = reply.readInt32();        return val;    }    void setVal(int32_t val){        Parcel data;        data.writeInterfaceToken(IFregService::getInterfaceDescriptor());        data.writeInt32(val);        Parcel reply;        // remote（）函数来获取BpBinder代理对象        // 调用代理对象的transact请求运行在Server进程的一个Binder对象执行SET_VAL方法        remote()-&gt;transact(SET_VAL, data, &amp;reply);    }};// 特定宏，实现IFregService类的元接口，有头文件DECLARE_META_INTERFACE相对应IMPLEMENT_META_INTERFACE(FregService, &quot;shy.luo.IFregService&quot;);// 模板类BnInterface实现类BnFregService的成员函数onTransact的实现// 将具体方法分发给实现其的子类FregService处理，这里只是分发，不具体实现status_t BnFregService::onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags){    switch(code)    {        case GET_VAL:{            CHECK_INTERFACE(IFregService, data, reply);            int32_t val = getVal();            reply-&gt;writeInt32(val);            return NO_ERROR;        }        case SET_VAL:{            CHECK_INTERFACE(IFregService, data, reply);            int32_t val = data.readInt32();            setVal(val);            return NO_ERROR;        }        default:{            return BBinder::onTransact(code, data, reply, flags);        }    }}</code></pre><p>代码相关说明：</p><ol><li>enum用于声明两个方法，Binder底层通信会使用到后面的IBinder::FIRST_CALL_TRANSACTION，用于区分服务的不同请求</li><li>BpFregService为远程代理服务实现，依旧是由模版类中的BpInterface提供支持。其构造函数传递对象为IBinder类型，由强引用sp维持</li><li>BpFregService中方法getVal和setVal，有客户端通过SM获取到远程代理对象，调用代理对象服务方法会走此流程，remote()函数来获取BpBinder代理对象，之后进入Binder驱动中，从数据封装到了Parcel中可以看出</li><li>IMPLEMENT_META_INTERFACE，特定宏，实现IFregService类的元接口，IInterface中会介绍</li><li>BnFregService为Server端得到Binder驱动传入的请求消息，响应走onTransact方法。其最终调用实现类FregService的具体的方法，FregService继承了BnFregService</li></ol><h4 id="IInterface-h"><a href="#IInterface-h" class="headerlink" title="IInterface.h"></a>IInterface.h</h4><p>前面文件分析中，多次提到这个文件，下面我们来具体分析一下。</p><pre><code>#ifndef ANDROID_IINTERFACE_H#define ANDROID_IINTERFACE_H#include &lt;binder/Binder.h&gt;namespace android {// ----------------------------------------------------------------------class IInterface : public virtual RefBase{public:            IInterface();            static sp&lt;IBinder&gt;  asBinder(const IInterface*);            static sp&lt;IBinder&gt;  asBinder(const sp&lt;IInterface&gt;&amp;);protected:    virtual                     ~IInterface();    virtual IBinder*            onAsBinder() = 0;};// ----------------------------------------------------------------------//模板函数//interface_cast(const sp&lt;IServiceManager&gt;) == IServiceManager::asInterface()template&lt;typename INTERFACE&gt;inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj){    return INTERFACE::asInterface(obj);}// ----------------------------------------------------------------------template&lt;typename INTERFACE&gt;class BnInterface : public INTERFACE, public BBinder{public:    virtual sp&lt;IInterface&gt;      queryLocalInterface(const String16&amp; _descriptor);    virtual const String16&amp;     getInterfaceDescriptor() const;protected:    virtual IBinder*            onAsBinder();};// ----------------------------------------------------------------------template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase{public:                                BpInterface(const sp&lt;IBinder&gt;&amp; remote);protected:    virtual IBinder*            onAsBinder();};// ----------------------------------------------------------------------//主要声明asInterface(),getInterfaceDescriptor()方法#define DECLARE_META_INTERFACE(INTERFACE)                               \    static const android::String16 descriptor;                          \    static android::sp&lt;I##INTERFACE&gt; asInterface(                       \            const android::sp&lt;android::IBinder&gt;&amp; obj);                  \    virtual const android::String16&amp; getInterfaceDescriptor() const;    \    I##INTERFACE();                                                     \    virtual ~I##INTERFACE();                                            \#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \    const android::String16 I##INTERFACE::descriptor(NAME);             \    const android::String16&amp;                                            \            I##INTERFACE::getInterfaceDescriptor() const {              \        return I##INTERFACE::descriptor;                                \    }                                                                   \    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(                \            const android::sp&lt;android::IBinder&gt;&amp; obj)                   \    {                                                                   \        android::sp&lt;I##INTERFACE&gt; intr;                                 \        if (obj != NULL) {                                              \            intr = static_cast&lt;I##INTERFACE*&gt;(                          \                obj-&gt;queryLocalInterface(                               \                        I##INTERFACE::descriptor).get());               \            if (intr == NULL) {                                         \                intr = new Bp##INTERFACE(obj);                          \            }                                                           \        }                                                               \        return intr;                                                    \    }                                                                   \    I##INTERFACE::I##INTERFACE() { }                                    \    I##INTERFACE::~I##INTERFACE() { }                                   \#define CHECK_INTERFACE(interface, data, reply)                         \    if (!data.checkInterface(this)) { return PERMISSION_DENIED; }       \// ----------------------------------------------------------------------// No user-serviceable parts after this...template&lt;typename INTERFACE&gt;inline sp&lt;IInterface&gt; BnInterface&lt;INTERFACE&gt;::queryLocalInterface(        const String16&amp; _descriptor){    if (_descriptor == INTERFACE::descriptor) return this;    return NULL;}template&lt;typename INTERFACE&gt;inline const String16&amp; BnInterface&lt;INTERFACE&gt;::getInterfaceDescriptor() const{    return INTERFACE::getInterfaceDescriptor();}template&lt;typename INTERFACE&gt;IBinder* BnInterface&lt;INTERFACE&gt;::onAsBinder(){    return this;}template&lt;typename INTERFACE&gt;inline BpInterface&lt;INTERFACE&gt;::BpInterface(const sp&lt;IBinder&gt;&amp; remote)    //先初始化BpRefBase()    : BpRefBase(remote){}template&lt;typename INTERFACE&gt;inline IBinder* BpInterface&lt;INTERFACE&gt;::onAsBinder(){    return remote();}// ----------------------------------------------------------------------}; // namespace android#endif // ANDROID_IINTERFACE_H</code></pre><p>内容比较多，我们根据代码一一分析：</p><h5 id="DECLARE-META-INTERFACE（…）"><a href="#DECLARE-META-INTERFACE（…）" class="headerlink" title="DECLARE_META_INTERFACE（…）"></a>DECLARE_META_INTERFACE（…）</h5><p>在头文件中使用到宏指令DECLARE_META_INTERFACE，其目的是方便在C层声明asInterface等方法，具体传入参数为FregService，根据代码展开如下：</p><pre><code>static const android::String16 descriptor;                          static android::sp&lt;IFregService&gt; asInterface(                               const android::sp&lt;android::IBinder&gt;&amp; obj);                  virtual const android::String16&amp; getInterfaceDescriptor() const;    IFregService();                                                     virtual ~IFregService();                                            </code></pre><p>C层头文件通过一条宏指令，便可以完成Binder通信架构的声明，下面便是具体实现宏IMPLEMENT_META_INTERFACE。</p><h5 id="IMPLEMENT-META-INTERFACE-…"><a href="#IMPLEMENT-META-INTERFACE-…" class="headerlink" title="IMPLEMENT_META_INTERFACE(…)"></a>IMPLEMENT_META_INTERFACE(…)</h5><p>其是一条宏，传入参数为(INTERFACE, NAME),这里INTERFACE对应FregService；NAME对应于 “shy.luo.IFregService”。根据宏内容展开如下：</p><pre><code>const android::String16 FregService::descriptor(shy.luo.IFregService);             const android::String16&amp;                                                    FregService::getInterfaceDescriptor() const {                  return FregService::descriptor;                                }                                                                   android::sp&lt;FregService&gt; FregService::asInterface(                        const android::sp&lt;android::IBinder&gt;&amp; obj)                   {                                                                      android::sp&lt;FregService&gt; intr;                                     if (obj != NULL) {                                                      intr = static_cast&lt;FregService*&gt;(                                      obj-&gt;queryLocalInterface(                                                   FregService::descriptor).get());                       if (intr == NULL) {                                                     intr = new Bp##INTERFACE(obj);                                  }                                                               }                                                                   return intr;                                                    }                                                                   FregService::FregService() { }                                    FregService::~FregService() { }     </code></pre><ol><li>其根据宏，声明了FregService的descriptor，getInterfaceDescriptor，asInterface，构造函数和析构函数</li><li>其中descriptor描述为shy.luo.IFregService，asInterface传入的参数是范型为IBinder常引用</li><li>其内部逻辑是首先通过BInder对象的queryLocalInterface方法，根据descriptor查看本地是否存在，（同一个进程，直接返回），不存在就其自身新建Bp##INTERFACE(obj)</li></ol><p>分析到这里，基本的函数模版就清晰可见了。IInterface.h头文件，通过两条特定的宏，完成了C层代码实现基于系统提供的Binder跨进程通信的架构规范，而其最终结果便是生成远程代理对象Bp##INTERFACE，方便Client端调用。</p><h5 id="BpFregService实例化"><a href="#BpFregService实例化" class="headerlink" title="BpFregService实例化"></a>BpFregService实例化</h5><ol><li><p>BpFregService创建过程，首先实例化父类</p><pre><code>--&gt; IFregService.cppBpFregService(const sp&lt;IBinder&gt;&amp; impl)         : BpInterface&lt;IFregService&gt;(impl){    }</code></pre></li><li><p>BpInterface初始化，会先初始化BpRefBase</p><pre><code>--&gt; IInterface.hinline BpInterface&lt;INTERFACE&gt;::BpInterface(const sp&lt;IBinder&gt;&amp; remote)    //先初始化化BpRefBase()    : BpRefBase(remote){}</code></pre></li><li><p>BpRefBase初始化，建立引用关系</p><pre><code>--&gt; Binder.cppBpRefBase::BpRefBase(const sp&lt;IBinder&gt;&amp; o)    : mRemote(o.get()), mRefs(NULL), mState(0){    extendObjectLifetime(OBJECT_LIFETIME_WEAK);    if (mRemote) {        mRemote-&gt;incStrong(this);        mRefs = mRemote-&gt;createWeak(this);    }}</code></pre></li></ol><p>BpFregService在初始化过程中，经过层层调用，进入到Binder驱动程序中，通过传入的IBinder，为其建立引用关系，增加其对应的强弱引用值等。</p><ul><li><p>以上部分参考Gityuan博客相关内容，有兴趣读者可以自行查看，链接如下：</p><p>  <a href="http://gityuan.com/2015/11/08/binder-get-sm/" target="_blank" rel="noopener">戳我</a></p></li></ul><h5 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h5><p>在理解这部分时，我们不妨这样理解，采用分层的形式来理解，具体如下：</p><ol><li>BpInterface 对应远程代理对象，持有对象为IBinder类型的remote，由Client端直接持有，存在于底层Binder中</li><li>BnInterface 对应本地对象，由sp强引用维持生命周期，继承自BBinder，此处由BnFregService持有，存在于底层Binder中</li><li>Client端从SM中获取的IBinder类型对象obj，其是底层Binder对应Server端分配为其分配的BpInterface远程代理对象</li><li>底层Binder接受Client传递的跨进程消息，首先传递到对应的BnInterface本地对象，然后在传递给其子类BnFregService的onTransact中处理，而FregService正是继承自BnFregService，实现了onTransact中的具体方法</li></ol><p>由上解释了跨进程通信的具体流程，其中分层的意思就是Binder底层自动的为Client和Server端都建立了链接关系，通过BpInterface和BnInterface在底层实现跨进程交互。</p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><h5 id="编译获取文件"><a href="#编译获取文件" class="headerlink" title="编译获取文件"></a>编译获取文件</h5><pre><code>// 编译完成得到FregServermmm external/binder/server/// 编译得到FregClientmmm external/binder/client</code></pre><h5 id="放置程序，提权"><a href="#放置程序，提权" class="headerlink" title="放置程序，提权"></a>放置程序，提权</h5><pre><code>adb connect ...// push文件到sdcard下adb push FregServer FregClient /sdcard/adb shellsu// 重挂在分区读写mount -o remount,rw /systemcp /sdcard/Freg* /system/bin// 读权chmod 755 Freg*</code></pre><h5 id="运行，查看结果"><a href="#运行，查看结果" class="headerlink" title="运行，查看结果"></a>运行，查看结果</h5><pre><code>// 后台运行/system/bin/FregServer &amp;/system/bin/FregClient</code></pre><p>log日志如下：</p><pre><code>root@makena:/system # /system/bin/FregClient                                   Read original value from FregService: 100.Add value 9 to FregService.Read the value from FregService again: 109.</code></pre><h3 id="在framework层实现Binder通信"><a href="#在framework层实现Binder通信" class="headerlink" title="在framework层实现Binder通信"></a>在framework层实现Binder通信</h3><p>以上介绍了Native层Binder通信的实现，至于framework层实现也基本相似，这里就不详细说明了。其大概流程就是像之前AIDL分析章节中提到的编译中间接口文件那样，使用其中几个重要类和方法，基于底层Binder实现好的框架，实现跨进程通信。如果有读者想尝试，可以参考Gityuan博客中的代码自己实现测试一下即可。</p><p><a href="http://gityuan.com/2015/11/22/binder-use/" target="_blank" rel="noopener">戳我</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章节详细的介绍了Binder通信在Native层具体实现。其本质还是基于底层Binder驱动实现好框架，借助于IInterface.h中提供的几个重要方法，按照一定的规范实现，便可以轻松的实现跨进程通信。</p><p>本着前篇的AIDL的介绍和本章节的Binder在Native层实现，相信读者基本了解了Binder跨进程通信机制的原理，至于更多更深层次的介绍，可能会更多的集中在C层和驱动层，后续章节会针对这些方面再具体分析。</p><p>基本上层的Binder实现到此就结束了。下面章节再介绍Binder就会从C层乃至驱动层进行分析。读者本人刚开始学习也是一脸懵逼，咬牙坚持，耐着性子看了两三遍才稍微有点想法。世上无难事，只怕有心人。Jsut do it！</p><p>共勉：Fucking source code！！！</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><blockquote><p>参考代码： Android系统源代码情景分析</p></blockquote><blockquote><p><a href="http://gityuan.com/2015/11/22/binder-use/" target="_blank" rel="noopener">Gityuan博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Binder分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binder分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binder系统分析之应用层AIDL的具体实现</title>
      <link href="/FuckCode/2018/07/12/Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82AIDL%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/"/>
      <url>/FuckCode/2018/07/12/Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8B%E5%BA%94%E7%94%A8%E5%B1%82AIDL%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>提及安卓的跨进程通信机制，那肯定非Binder机制莫属了！然而安卓为什么不采用原生linux提供的管道、消息队列、信号、secket以及共享内存呢？而是自己大费周章的写了一套自己的Binder跨进程通信机制，由此可见Binder通信机制的重要性。本人学习Binder后，感悟颇深。为了更好的理解，避免方便上层应用开发者直接看底层c实现难度太大，便拿其最直接的aidl文件实现跨进程开刀，庖丁解牛，由表及里，拨开云雾见天日！</strong></p><a id="more"></a><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>AIDl（Android Interface Definition Language），解释为安卓接口定义语言。以AIDl定义的服务接口文件是以.aidl文件结尾的。在系统编译时，会自动将其转换成对应的java文件。此java自动生成了若干类提供开发者无缝调用其他进程定义好的接口而无需关注其内部的具体实现。本文后面会借此java文件内容，初探分析Binder内部的具体实现方式。对于AIDL的具体语法，这里不做过多解释了。</p><h3 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h3><p>为了方便清晰的描述跨进程通信机制Binder的具体实现方式aidl，这里我们采用一下案例进行实现。</p><ul><li>用户使用手机购物需要支付时，一般调用第三方的支付接口服务，此服务运行在不同进程中</li><li>支付服务运行商的支付逻辑自己实现，其约定接口，发放接口文件aidl提供开发者调用</li><li>支付请求基于跨进程通信，此方式解耦了商品购买和支付之间的关系，开发者只需要知道支付是否成功即可</li></ul><h3 id="Server端实现"><a href="#Server端实现" class="headerlink" title="Server端实现"></a>Server端实现</h3><h4 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h4><p>支付接口需要aidl声明，便于跨进程交互。其在as中可以自行建立。这里在定义接口之前，还需约定好传递的数据类型，aidl不仅仅支持基本的数据类型，也支持自定的数据类型。首先右击新建aidl文件，命名IAlipayInterface.aidl，系统会自动为其新建指定包名的aidl文件夹，位于main文件夹下。在此文件夹下进行下面的操作。</p><h5 id="支付数据PayInfo"><a href="#支付数据PayInfo" class="headerlink" title="支付数据PayInfo"></a>支付数据PayInfo</h5><p>PayInfo声明为简单的JavaBean，其主要是支付信息数据的封装，这里主要包括支付时间，地点，描述信息，金额，支付结果，错误信息等。其简单实现如下：</p><pre><code>package com.example.rememberme.alipay_server;public class PayInfo implements Parcelable {    private String data;    private String local;    private String desc;    private float money;    private boolean ok;    private String errorInfo;    public PayInfo() {    }    protected PayInfo(Parcel in) {        data = in.readString();        local = in.readString();        desc = in.readString();        money = in.readFloat();        ok = in.readByte() != 0;        errorInfo = in.readString();    }    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeString(data);        dest.writeString(local);        dest.writeString(desc);        dest.writeFloat(money);        dest.writeByte((byte) (ok ? 1 : 0));        dest.writeString(errorInfo);    }    @Override    public int describeContents() {        return 0;    }    public static final Creator&lt;PayInfo&gt; CREATOR = new Creator&lt;PayInfo&gt;() {        @Override        public PayInfo createFromParcel(Parcel in) {            return new PayInfo(in);        }        @Override        public PayInfo[] newArray(int size) {            return new PayInfo[size];        }    };    //各种set方法    public PayInfo setData(String data) {        this.data = data;        return this;    }    ...    @Override    public String toString() {        return &quot;PayInfo{&quot; +                &quot;data=&apos;&quot; + data + &apos;\&apos;&apos; +                &quot;, local=&apos;&quot; + local + &apos;\&apos;&apos; +                &quot;, desc=&apos;&quot; + desc + &apos;\&apos;&apos; +                &quot;, money=&quot; + money +                &quot;, ok=&quot; + ok +                &quot;, errorInfo=&apos;&quot; + errorInfo + &apos;\&apos;&apos; +                &apos;}&apos;;    }}</code></pre><p>这里需要有以下几点注意事项：</p><ol><li>package 包名位置一定要清晰，下面的aidl文件都是以此为基础的</li><li>自定义的 JavaBean 一定要实现 Parcelable 接口，以方便通过此层Binder机制跨进程通信</li><li>先声明好 java 中的成员以及对应的set方法，直接继承 parcelable 接口，使用as快捷键会自动实现具体逻辑</li></ol><h5 id="PayInfo-aidl"><a href="#PayInfo-aidl" class="headerlink" title="PayInfo.aidl"></a>PayInfo.aidl</h5><p>实现PayInfo自定义数据对应的aidl文件。</p><pre><code>// PayInfo.aidlpackage com.example.rememberme.alipay_server;parcelable PayInfo;</code></pre><ol><li>这里的 PayInfo.aidl 文件位于和 PayInfo.java 文件统计目录下，package 包名一致</li><li>关键字parcelable 声明实现接口类型对应文件 PayInfo</li></ol><h5 id="IAliayInterface"><a href="#IAliayInterface" class="headerlink" title="IAliayInterface"></a>IAliayInterface</h5><p>实现支付接口IAlipayInterface的具体实现。</p><pre><code>// IAllipayInterface.aidlpackage com.example.rememberme.alipay_server;import com.example.rememberme.alipay_server.PayInfo;// Declare any non-default types here with import statementsinterface IAlipayInterface {    PayInfo transact(in PayInfo i);}</code></pre><ol><li>统计目录下 package 内容一致</li><li>import 导入之前对应的自定义数据类型 PayInfo</li><li>接口方法定义 transact ，传入和返回参数都是 PayInfo 类型</li></ol><h5 id="IAlipayInterface-java-的生成"><a href="#IAlipayInterface-java-的生成" class="headerlink" title="IAlipayInterface.java 的生成"></a>IAlipayInterface.java 的生成</h5><p>注意，上面介绍的目录层级和包名一定要相互对应，否则as将无法正常生成对应的接口定义文件 IAlipayInterface.java </p><p>如果一切ok，点击as运行编译旁边的小锤子按钮，系统便会生成如下文件，具体目录如下（目录显示为project）：</p><pre><code>app/build/generated/source/aidl/debug/com/example/rememberme/alipay_server/IAlipayInterface.java</code></pre><p>如果编译出错，可能是as没有将aidl文件纳入编译中，需要修改项目的配置文件 build.gradle 内容，在 android{} 的 buildTypes{} 上面添加如下文件配置代码，便可解决。</p><pre><code>sourceSets {    main {        manifest.srcFile &apos;src/main/AndroidManifest.xml&apos;        java.srcDirs = [&apos;src/main/java&apos;, &apos;src/main/aidl&apos;]        resources.srcDirs = [&apos;src/main/java&apos;, &apos;src/main/aidl&apos;]        aidl.srcDirs = [&apos;src/main/aidl&apos;]        res.srcDirs = [&apos;src/main/res&apos;]        assets.srcDirs = [&apos;src/main/assets&apos;]    }}</code></pre><p>我们大概浏览一下文件的具体内容，其内部的具体内容较多，下面会具体分析，这里主要关注后面涉及的方法：</p><ol><li>抽象类Stub实例化时，将实例对象与DESCRIPTOR进行了绑定，queryLocalInterface会根据它找到实例对象</li><li>抽象类Stub中asInterface同于将远程代理对象转换成IAlipayInterface接口，方便客户端调用支付逻辑，此实现于客户端内</li><li>方法中的transact和支付接口声明的transact是两码事，这里笔者声明后才发现容易引起混淆，这里主要根据形参可以看出不是同一个方法。</li><li>抽象类Stub还有一个静态内部类Proxy，其主要工作是代理底层传递的远程Binder服务，负责底层和上层客户端的交互。</li><li>从类中，我们发现其接口均以全包名的形式展示出来，这就意味着服务端的接口文件需要和客户端的接口文件相一致，否则会调用失败。这里也是笔者一再强调上述三个在同一文件夹下的必要性。</li></ol><p>到这里，支付接口的定义和声明就告一段落，下面我们来具体实现其服务端和客户端的具体逻辑。</p><h4 id="AlipayService实现"><a href="#AlipayService实现" class="headerlink" title="AlipayService实现"></a>AlipayService实现</h4><p>支付服务独立运行在一个服务进程中，这里我们开启一个Service来提供支付服务。具体实现如下：</p><pre><code>public class AlipayService extends Service {    private static final String TAG = &quot;AlipayService&quot;;    public AlipayService() {        Log.d(TAG, &quot;AlipayService: &quot; + &quot;服务已启动...&quot;);    }    @Override    public IBinder onBind(Intent intent) {        Log.d(TAG, &quot;onBind: &quot; + &quot;服务已绑定...&quot;);        return new Alipay();    }    class Alipay extends IAlipayInterface.Stub {        @Override        public PayInfo transact(PayInfo i) throws RemoteException {            // client端请求本服务aidl支付接口            return doPay(i);        }    }    // 支付具体逻辑    private PayInfo doPay(PayInfo i) {        Log.d(TAG, &quot;doPay: &quot; + &quot;支付服务已受理，支付成功！！！&quot;);        Log.d(TAG, &quot;请求数据: &quot;+i.toString());        PayInfo payInfo = new PayInfo();        payInfo.setDesc(&quot;返回数据：&quot; + i.getDesc())                .setData(&quot;支付请求完成时间：&quot; + &quot;2018/7/12/16:38&quot;)                .setErrorInfo(&quot;&quot;)                .setLocal(i.getLocal())                .setMoney(i.getMoney())                .setOk(true);        return payInfo;    }    @Override    public boolean onUnbind(Intent intent) {        return super.onUnbind(intent);    }}</code></pre><ul><li>服务中在绑定时，返回一个Alipay的对象，AliPay继承了之前AIDL接口文件生成的中间类Stub类，提供了实现具体支付的接口。</li><li>这里显然Stub提供的接口需要服务端具体实现，Stub的作用就是远程客户端请求支付服务的时候，通过IPC多线程下的Binder通信机制，跨进程获取服务支付代理对象，从而通过约定好的接口实现支付逻辑。</li><li>在支付接口方法transact中，我们通过形参PayInfo可以获取到客户端传来的支付信息，这里我们简单的对数据进行处理，更改时间并将支付成功置位true后返回客户端。</li></ul><p>至此，服务就基本处理完成。下面我们在应用打开的时候就将这个服务开启起来，以便供客户端使用（注意：这里不启动也可以，因为在客户端中就已实现了关联，这里只是为了方便查看进程id，便于解释跨进程通信）</p><h5 id="MainActivity实现"><a href="#MainActivity实现" class="headerlink" title="MainActivity实现"></a>MainActivity实现</h5><p>主页面的实现很简单，就是在页面开始时候启动服务，同时在Manifest中声明服务的action值。</p><pre><code>public class MainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        // 开启服务        Intent intent = new Intent(MainActivity.this, AlipayService.class);        startService(intent);    }}</code></pre><p>Mainfest 声明</p><pre><code>&lt;service    android:name=&quot;.AlipayService&quot;    android:enabled=&quot;true&quot;    android:exported=&quot;true&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.alipayserver&quot;&gt;&lt;/action&gt;    &lt;/intent-filter&gt;&lt;/service&gt;</code></pre><p>如上，server端的实现就具体完成了，编译打包安装到机器上，运行后ps一下就可以看到其进程id了。</p><h3 id="Client实现"><a href="#Client实现" class="headerlink" title="Client实现"></a>Client实现</h3><h4 id="接口文件"><a href="#接口文件" class="headerlink" title="接口文件"></a>接口文件</h4><p>AIDL跨进程通信约束了客户端和服务端都必须遵循相同的接口文件。这里我们直接将server端中aidl文件夹下的文件直接拷贝到client端中对应的位置即可，同时在 build.gradle 中声明 aidl 编译配置，锤子点一下，生成同样的 IAlipayInterface.java 中间文件即可。</p><h4 id="MainActivity实现-1"><a href="#MainActivity实现-1" class="headerlink" title="MainActivity实现"></a>MainActivity实现</h4><p>这里我们简化客户模式购物请求，直接在MainActivity中实现支付请求，传入支付参数即可。具体代码如下：</p><pre><code>public class MainActivity extends AppCompatActivity {    private static final String TAG = &quot;ALIPAY_CLIENT&quot;;    private IAlipayInterface alipayInterface;    private MyConn conn;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Intent intent = new Intent();        conn = new MyConn();        //通过意图过滤器建立关系        intent.setAction(&quot;android.intent.action.alipayserver&quot;);        //自从Android5.0开始通过setAction的方式已经失效，必须要传入应用包名        intent.setPackage(&quot;com.example.rememberme.alipay_server&quot;);        //绑定服务        bindService(intent, conn, Service.BIND_AUTO_CREATE);        Button alipay = findViewById(R.id.alipay);        alipay.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                try {                    // 生成请求数据信息                    PayInfo payInfo = new PayInfo();                    payInfo.setMoney(7000)                            .setLocal(&quot;广东省深圳市宝安区西乡大道...&quot;)                            .setErrorInfo(&quot;&quot;)                            .setDesc(&quot;用户请求支付宝服务支付接口：商品：苹果X（128g），红色国行&quot;)                            .setData(&quot;2018/7/12/16:35&quot;)                            .setOk(false);                    // 调用远程服务接口支付                    PayInfo callback = alipayInterface.transact(payInfo);                    Log.d(TAG, &quot;onClick: &quot;+ callback.toString());                } catch (RemoteException e) {                    e.printStackTrace();                }            }        });    }    private class MyConn implements ServiceConnection {        @Override        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {            Log.d(TAG, &quot;onServiceConnected: &quot; + &quot;远程服务连接成功...&quot;);            // 这里采用asInterface方式，不再强转形式            alipayInterface = IAlipayInterface.Stub.asInterface(iBinder);        }        @Override        public void onServiceDisconnected(ComponentName componentName) {            Log.d(TAG, &quot;onServiceDisconnected: &quot; + &quot;远程服务已断开...&quot;);            alipayInterface = null;        }        @Override        public void onBindingDied(ComponentName name) {            Log.d(TAG, &quot;onBindingDied: &quot; + &quot;远程服务死亡通知...&quot;);        }    }}</code></pre><p>这里对代码进行解释：</p><ol><li>通过 bindService 实现远程服务端的绑定，方便调用远程服务提供的支付接口</li><li>bindService 需要传入三个参数，第一个意图对象，即远程服务；第二个本地 ServiceConnection 具体实现，即获取到远程服务绑定成功回传的代理对象；第三个为标志位，即绑定服务及创建服务，意味远程服务不存在时候，绑定时候便启动服务进程。</li><li>Intent 用来通过意图过滤器建立远程服务之间的关系，这里需要注意5.0以后需要指定服务的包名</li><li>ServiceConnection 的具体实现 MyConn，其为 bindService 远程服务时的回调，回传远程服务对象IBinder。这里IBinder对象是底层会传的引用，由系统返回的代理对象的基类。可以调用生成的中间文件asInterface方法将其转成接口服务IAlipayInterface。</li><li>btn是一个Button控件，点击即生成请求参数PayInfo，调用获取到的远程支付接口 alipayInterface.transact方法，得到支付结果，这里我们直接打印log查看。</li></ol><p>至此，一个aidl跨进程通信模型就基本实现完成，下面我们进行调试观察，以便了解跨进程通信的原理。</p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><h5 id="服务端-gt-客户端"><a href="#服务端-gt-客户端" class="headerlink" title="服务端-&gt;客户端"></a>服务端-&gt;客户端</h5><p>我们先启动服务端，在启动客户端进行支付请求。</p><ul><li><p>启动服务</p><pre><code>服务端u0_a25    3820  1452  1100144 59428 SyS_epoll_ 7f94979574 S com.example.rememberme.alipay_server客户端u0_a25    3820  1452  1075500 49968 SyS_epoll_ 7f94979574 S com.example.rememberme.alipay_serveru0_a26    3917  1452  1149604 63084 SyS_epoll_ 7f94979574 S com.example.rememberme.alipay_client</code></pre></li></ul><p>上面由进程id可以看出两着不在同一个进程，server端位于3820，client端位于3917，我们调用支付接口看一下log。</p><ul><li><p>调用支付接口</p><pre><code>服务端07-13 10:36:41.693 3820-3831/com.example.rememberme.alipay_server D/AlipayService: doPay: 支付服务已受理，支付成功！！！客户端07-13 10:36:41.693 3917-3917/com.example.rememberme.alipay_client D/ALIPAY_CLIENT: onClick: PayInfo{data=&apos;支付请求完成时间：2018/7/12/16:38&apos;, local=&apos;广东省深圳市宝安区西乡大道...&apos;, desc=&apos;返回数据：用户请求支付宝服务支付接口：商品：苹果X（128g），红色国行&apos;, money=7000.0, ok=true, errorInfo=&apos;&apos;}</code></pre></li></ul><p>下面我们将服务端kill掉在试一下，kill 3820，再请求支付。</p><ul><li><p>kill 后</p><pre><code>服务端    07-13 10:39:39.333 4014-4014/com.example.rememberme.alipay_server I/InstantRun: starting instant run server: is main process    07-13 10:39:39.343 4014-4014/com.example.rememberme.alipay_server D/AlipayService: AlipayService: 服务已启动...    07-13 10:39:39.344 4014-4014/com.example.rememberme.alipay_server D/AlipayService: onBind: 服务已绑定...客户端    07-13 10:39:37.456 3917-3917/com.example.rememberme.alipay_client D/ALIPAY_CLIENT: onServiceDisconnected: 远程服务已断开...    07-13 10:39:39.347 3917-3917/com.example.rememberme.alipay_client D/ALIPAY_CLIENT: onServiceConnected: com.example.rememberme.alipay_server        onServiceConnected: 远程服务连接成功...</code></pre></li><li><p>请求支付            </p><pre><code>服务端07-13 10:40:19.800 4014-4048/com.example.rememberme.alipay_server D/AlipayService: doPay: 支付服务已受理，支付成功！！！客户端07-13 10:40:19.801 3917-3917/com.example.rememberme.alipay_client D/ALIPAY_CLIENT: onClick: PayInfo{data=&apos;支付请求完成时间：2018/7/12/16:38&apos;, local=&apos;广东省深圳市宝安区西乡大道...&apos;, desc=&apos;返回数据：用户请求支付宝服务支付接口：商品：苹果X（128g），红色国行&apos;, money=7000.0, ok=true, errorInfo=&apos;&apos;}</code></pre></li></ul><h5 id="只客户端"><a href="#只客户端" class="headerlink" title="只客户端"></a>只客户端</h5><ul><li><p>启动服务（未调用支付）</p><pre><code>服务端07-13 10:54:31.125 3301-3301/com.example.rememberme.alipay_server I/InstantRun: starting instant run server: is main process07-13 10:54:31.135 3301-3301/com.example.rememberme.alipay_server D/AlipayService: AlipayService: 服务已启动...07-13 10:54:31.136 3301-3301/com.example.rememberme.alipay_server D/AlipayService: onBind: 服务已绑定...客户端07-13 10:54:31.140 3227-3227/com.example.rememberme.alipay_client D/ALIPAY_CLIENT: onServiceConnected: com.example.rememberme.alipay_server    onServiceConnected: 远程服务连接成功...</code></pre></li></ul><p>注意：如果这个时候kill掉cilent，在kill掉server，有可能出现服务不断重启，此时只需要重启设备即可。</p><ul><li><p>请求支付</p><pre><code>服务端07-13 10:55:57.026 3301-3354/com.example.rememberme.alipay_server D/AlipayService: doPay: 支付服务已受理，支付成功！！！客户端07-13 10:55:57.027 3227-3227/com.example.rememberme.alipay_client D/ALIPAY_CLIENT: onClick: PayInfo{data=&apos;支付请求完成时间：2018/7/12/16:38&apos;, local=&apos;广东省深圳市宝安区西乡大道...&apos;, desc=&apos;返回数据：用户请求支付宝服务支付接口：商品：苹果X（128g），红色国行&apos;, money=7000.0, ok=true, errorInfo=&apos;&apos;}进程idu0_a26    3227  1446  1152892 63496 SyS_epoll_ 7fa8d6b574 S com.example.rememberme.alipay_clientu0_a25    3301  1446  1034472 36832 SyS_epoll_ 7fa8d6b574 S com.example.rememberme.alipay_server</code></pre></li></ul><h5 id="小结现象"><a href="#小结现象" class="headerlink" title="小结现象"></a>小结现象</h5><ul><li>先启动服务端，再启动客户端，pid是服务端先于客户端分配</li><li>先启动客户端，绑定服务时即自动启动服务端，pid是客户端先于服务端分配</li><li>客户端存在，服务端kill掉也会不断重启（BIND_AUTO_CREATE），以维护绑定机制正常运行</li></ul><p>由上面可以看出，客户端不用关注服务端的运行状态，因为其在绑定时即进行了相关操作，不存在就直接创建服务。从log打印流程可以看出。</p><p>这里我们可以大概总结内部通信的流程：</p><ol><li><p>Client绑定服务端获取到远程代理对象</p><ul><li>通过绑定服务，通过意图对象过滤器与远程服务建立连接</li><li>绑定服务返回接口ServiceConnection具体实现类回传底层分配的代理对象IBinder</li><li>通过IAlipayInterface接口文件编译的中间产物IAlipayInterface.Stub.asInterface 将回传对象IBinder转成接口文件类型，以实现无缝调用</li></ul></li><li><p>调用远程对象的支付逻辑</p><ul><li>服务端和客户端实现相同的aidl接口文件，方便底层驱动识别查找</li><li>底层通知调用其支付方法。服务端根据传入请求支付消息，调用其支付接口，返回支付结果。其实质是通过中间文件转达消息到binder底层驱动后，再间接调用远程服务提供的支付逻辑</li></ul></li><li><p>客户端得到支付结果处理</p><ul><li>支付结果通过底层回传到客户端，客户端得到服务端支付的回传结果，继续处理</li></ul></li></ol><p>以上便是整个支付请求的大概流程，只停留在上层应用中，涉及到底层驱动部分不作过多的解释。由于我们关注的是其中Binder机制下aidl的具体实现原理，我们就集中对生成的中间文件进行分析。</p><h3 id="AIDL中间文件分析"><a href="#AIDL中间文件分析" class="headerlink" title="AIDL中间文件分析"></a>AIDL中间文件分析</h3><p>开篇中我们就说到，aidl是为了跨进程通信实现的一种方式，它是Binder上层应用的直接体现。我们可以借此大概了解Binder的运行机制。</p><h4 id="类Binder和接口IBinder"><a href="#类Binder和接口IBinder" class="headerlink" title="类Binder和接口IBinder"></a>类Binder和接口IBinder</h4><p>为了便于下面文档的说明，这里有必要了解一下上层应用的Binder类和IBinder接口的相关说明。</p><ul><li><p>IBinder是远程对象的基本接口，代表了跨进程通信的能力，是为了高性能而设计的轻量级远程调用机制的核心部分。但他不仅用于远程调用，也用于进程内调用。实现这个接口，便可以将这个对象进行跨进程传递，这是底层驱动支持的。该接口定义了与远程对象间交互的协议。但不要直接实现这个接口，而是继承(extends)Binder。</p></li><li><p>IBinder负责数据传输，那么client和server端的调用契约呢，即同步的接口声明？这里就用到了IInterface，其代表了远程server具体执行的能力，开发者只需要实现自定的接口文件aidl，其中间编译文件会自动让你生命的接口继承于这个类。</p></li><li><p>IBinder主要的API是transact()，与之对应的API是Binder.onTransact()。通过前者，你能向远程IBinder对象发送发出调用，后者使你的远程对象能够响应接收到的调用。IBinder的API都是 Syncronous(同步)执行的，比如transact()直到对方的Binder.onTransact()方法调用玩 后才返回。调用发生在进程内时无疑是一样的，而在进程间时，在IPC的帮助下，也是同样的效果。</p></li><li><p>Java层的Binder类，其实就是代表一个Binder本地对象。BinderProxy为其一个内部类，它代表远程进程的Binder对象的本地代理。这两个类都继承自IBinder，因而都具有跨进程通信的能力。在跨进程通信，驱动会自动实现这两个对象的转换。</p></li><li><p>通过transact()发送的数据是Parcel，Parcel是一种一般的缓冲区，除了有数据外还带有一些描述它内容的元数据。元数据用于管理IBinder对象的引用，这样就能在缓冲区从一个进程移动到另一个进程时保存这些引用。这样就保证了当一个IBinder被写入到Parcel并发送到另一个进程中，如果另一个进程把同一个IBinder的引用回发到原来的进程，那么这个原来的进程就能接收到发出的那个IBinder的引用。这种机制使IBinder和Binder像唯一标志符那样在进程间管理。</p></li><li><p>系统为每个进程维护一个存放交互线程的线程池。这些交互线程用于派送所有从另外进程发来的IPC 调用。例如：当一个IPC从进程Ａ发到进程Ｂ，Ａ中那个发出调用的线程(这个应该不在线程池中)就阻塞 在transact()中了。进程Ｂ中的交互线程池中的一个线程接收了这个调用，它调用 Binder.onTransact()，完成后用一个Parcel来做为结果返回。然后进程Ａ中的那个等待的线程在 收到返回的Parcel后得以继续执行。实际上，另一个进程看起来就像是当前进程的一个线程，但不是当前进程创建的。</p></li><li><p>Binder机制还支持进程间的递归调用。例如，进程Ａ执行自己的IBinder的transact()调用进程Ｂ 的Binder，而进程Ｂ在其Binder.onTransact()中又用transact()向进程Ａ发起调用，那么进程Ａ 在等待它发出的调用返回的同时，还会用Binder.onTransact()响应进程Ｂ的transact()。 总之Binder造成的结果就是让我们感觉到跨进程的调用与进程内的调用没什么区别。</p></li><li><p>部分解释来源于网络，参考如下：</p><p>  <a href="https://blog.csdn.net/ls5718/article/details/51854106" target="_blank" rel="noopener">参考链接</a></p></li></ul><h4 id="中间文件（IAlipayInterface-java）"><a href="#中间文件（IAlipayInterface-java）" class="headerlink" title="中间文件（IAlipayInterface.java）"></a>中间文件（IAlipayInterface.java）</h4><p>IAlipayInterface.java是aidl文件IAlipayInterface的编译中间产物，我们来具体分析一下：</p><pre><code>package com.example.rememberme.alipay_server;public interface IAlipayInterface extends android.os.IInterface {    public static abstract class Stub extends android.os.Binder implements com.example.rememberme.alipay_server.IAlipayInterface {        //DESCRIPTOR Binder的唯一标识，一般用当前Binder的类名表示        private static final java.lang.String DESCRIPTOR = &quot;com.example.rememberme.alipay_server.IAlipayInterface&quot;;        public Stub() {            this.attachInterface(this, DESCRIPTOR);        }        //将服务端的Binder对象转换成客户端所需的aidl接口类型的对象，这种转换过程是区分进程的        //位于同一进程，该方法返回的是服务端的Stub对象本身        //不在同一进程，该方法返回的是系统封装后都Stub.proxy对象        public static com.example.rememberme.alipay_server.IAlipayInterface asInterface(android.os.IBinder obj) {            if ((obj == null)) {                return null;            }            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);            if (((iin != null) &amp;&amp; (iin instanceof com.example.rememberme.alipay_server.IAlipayInterface))) {                return ((com.example.rememberme.alipay_server.IAlipayInterface) iin);            }            return new com.example.rememberme.alipay_server.IAlipayInterface.Stub.Proxy(obj);        }        //返回当前Binder对象（Alipay）        @Override        public android.os.IBinder asBinder() {            return this;        }        /**         * onTransact运行在服务端中的Binder线程池中         * 当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理         * code 通过code确定客户端请求的目标方法         * data 从data中取出目标方法所需的参数，然后执行目标方法         * reply执行完目标方法，将返回值写入reply中         * return 如果返回false，客户端去请求失败。可以用这个特性来做权限验证，过滤掉 不希望访问的进程         * /        @Override        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {            switch (code) {                case INTERFACE_TRANSACTION: {                    reply.writeString(DESCRIPTOR);                    return true;                }                case TRANSACTION_transact: {                    data.enforceInterface(DESCRIPTOR);                    com.example.rememberme.alipay_server.PayInfo _arg0;                    if ((0 != data.readInt())) {                        _arg0 = com.example.rememberme.alipay_server.PayInfo.CREATOR.createFromParcel(data);                    } else {                        _arg0 = null;                    }                    com.example.rememberme.alipay_server.PayInfo _result = this.transact(_arg0);                    reply.writeNoException();                    if ((_result != null)) {                        reply.writeInt(1);                        _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);                    } else {                        reply.writeInt(0);                    }                    return true;                }            }            return super.onTransact(code, data, reply, flags);        }        private static class Proxy implements com.example.rememberme.alipay_server.IAlipayInterface {            //远程的代理对象            private android.os.IBinder mRemote;            //接受底层分配的远程IBinder对象            Proxy(android.os.IBinder remote) {                mRemote = remote;            }            //返回的是远程代理对象（由底层支持）            @Override            public android.os.IBinder asBinder() {                return mRemote;            }            public java.lang.String getInterfaceDescriptor() {                return DESCRIPTOR;            }            /**             * 运行在客户端             * 首先创建该方法所需要的输入型Parcel 对象_data，输入型Parcel对象_reply和返回值对象_result             * 然后把该方法的参数信息写入 _data 中             * 接着调用transact方法发起RPC（远程过程调用）请求，同时挂起当前线程             * 然后服务端的 onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，             * 并从_reply中取出RPC过程的返回结果             * 最后返回_reply中的数据             */            @Override            public com.example.rememberme.alipay_server.PayInfo transact(com.example.rememberme.alipay_server.PayInfo i) throws android.os.RemoteException {                android.os.Parcel _data = android.os.Parcel.obtain();                android.os.Parcel _reply = android.os.Parcel.obtain();                com.example.rememberme.alipay_server.PayInfo _result;                try {                    _data.writeInterfaceToken(DESCRIPTOR);                    if ((i != null)) {                        _data.writeInt(1);                        i.writeToParcel(_data, 0);                    } else {                        _data.writeInt(0);                    }                    mRemote.transact(Stub.TRANSACTION_transact, _data, _reply, 0);                    _reply.readException();                    if ((0 != _reply.readInt())) {                        _result = com.example.rememberme.alipay_server.PayInfo.CREATOR.createFromParcel(_reply);                    } else {                        _result = null;                    }                } finally {                    _reply.recycle();                    _data.recycle();                }                return _result;            }        }        //声明指定ID，便于底层Binder处理时事件区分        static final int TRANSACTION_transact = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);    }    public com.example.rememberme.alipay_server.PayInfo transact(com.example.rememberme.alipay_server.PayInfo i) throws android.os.RemoteException;}</code></pre><p>下面我们来集中对其进行解释并说明调用流程：</p><ol><li>首先之前分析过，在AliService中的onBind方法中返回一个AliPay对象，其继承了IAlipayInterface.Stub对象，实现具体的支付方法，两者都在上层服务端中实现，最后以IBinder形式返回给了系统。（此时Alipay是抽象类IAlipayInterface.Stub的具体实现）</li><li>Stub构造函数中调用attachInterface将Alipay实现与DESCRIPTOR实现绑定，便于查询方法queryLocalInterface</li><li>asInterface方法接收了一个IBinder的接口对象，这个对象怎么来的呢？实际上是底层的Binder驱动提供的，在onBind方法中返回的抽象类Stub实例Alipay（以IBinder形式传递）实际上首先扔给了驱动，binder驱动进行了对其包装改变（因为binder驱动也在一个进程中，onBind返回的过程由于首先给binder驱动，所以也属于进程间对象的传递，所以binder驱动肯定会对Alipay进行包装和改变），binder驱动完成了改变之后，又交给了客户端的进程，所以客户端进程中的onServiceConnected才可以拿到一个IBinder的对象，并执行后续的asInterface方法。以上就解释了asInterface方法的参数IBinder obj的由来，它并不是直接的Alipay(服务端的onBind方法所返回的IBinder)。</li><li>asInterface是在客户端中调用的，在onServiceConnected中间接实现。首先调用queryLocalInterface进行本地查询。此时因为是跨进程，直接通过IAlipayInterface.Stub.Proxy(obj)新建实例返回</li><li>代理对象Proxy内部有一个mRemote的IBinder对象，所以这个对象也是可以跨进程的。在这个代理方法中，将binder驱动传递给客户端进程的IBinder赋值给了Proxy代理类的私有变量mRemote，而Proxy是Stub的内部类，这里千万不要被两个类在同一个文件中给弄迷糊了，这两个类在实际执行的时候是分属不同的进程空间中的。Proxy这个内部类实现了AIDL接口，所以其对象也是可以供客户端进程使用的AIDL接口对象。</li><li>这样的话，就通过服务端的Alipay（源自AIDL接口的内部类Stub）、客户端的asInterface得到AIDL接口对象(基于代理)实现了跨进程AIDL接口的使用，进行数据交互。 </li><li>抽象类Stub内部的静态代理类Proxy，其方法transact是客户端的直接实现。这里需要注意transact和onTransact并不在一个进程中运行，注释中有说明。transact调用后，对数据PayInfo进行相应的Parcel封装，便于进程间传递，之后调用代理对象mRemote的transact方法进入底层binder驱动，此时客户端处于阻塞等待状态。</li><li>binder驱动得到请求后，将封装的数据传递到抽象类Stub的onTransact方法中，由于其Stub继承了Binder类（底层驱动支持）。onTransact方法中对Parcel数据进行解析，得到PayInfo数据后，调用其直接实现类this.transact(_arg0)实现服务端实现的具体逻辑。处理完成具体支付逻辑后，返回的支付结果也按照同样的相反的流程返回到了客户端。</li></ol><p>通过上面的解释，基本就说通了adil接口在binder跨进程通信中的作用。其实aidl语言约束了开发者使用binder进行跨进程通信的相关接口文件声明，而开发者根本不需要知道其内部复杂的工作机制，只需要根据指定的规范进行接口声明及aidl文件实现即可，大大提高了不同进程间通信的开发工作效率。</p><h3 id="相关总结"><a href="#相关总结" class="headerlink" title="相关总结"></a>相关总结</h3><h4 id="关于aidl的总结"><a href="#关于aidl的总结" class="headerlink" title="关于aidl的总结"></a>关于aidl的总结</h4><ol><li>aidl的基于底层Binder跨进程通信基础上实现的，例如Binder类和IBinder接口</li><li>aidl文件仅仅是一个壳，as会根据其编译生成中间产物，这个中间产物才是最终需要用的文件</li><li>aidl可以传递各种数据，包括自定义JavaBean，但是必须实现其parcelable接口，在aidl接口中还要import进入</li><li>aidl对包名的要求极其严格，其约束客户端和服务端接口全称必须完全一致</li><li>aidl借助底层Binder跨进层通信，向上层提供Binder，IBinder以及IItnerface等类和接口，实现简单而无需了解内部工作机制，极大提高开发效率</li></ol><h4 id="安卓中IPC通信介绍"><a href="#安卓中IPC通信介绍" class="headerlink" title="安卓中IPC通信介绍"></a>安卓中IPC通信介绍</h4><ol><li>Bundle：简单易用，只能传输Bundle支持的数据类型，四大组件的进程间通信</li><li>文件共享：简单易用，不适合高并发场景，并且无法做到进程间的即时通讯 无并发访问情形，交换简单的数据实时性不高的场景</li><li>AIDL：功能强大，支持一对多并发通信，支持实时通信，使用稍复杂，需要处理好线程同步，一对多通信且RPC需要</li><li>Messenger：功能一般，支持一对多串行通信，支持实时通信 不能很好的处理高并发情形，不支持RPC，数据通过Message进行传输，因此只能传输Bundle支持的数据类型 低并发的一对多即时通讯，无RPC需要，或者无需返回结果的RPC需求</li><li>ContentProvider 在数据访问功能很强大，支持一对多并发数据共享，可通过call方法扩展其他操作 可以理解为受约束的AIDL，主要提供数据的CRUD操作 一对多的进程间的数据共享</li><li>Socket：功能强大，可以通过网络传输字节流，并支持一对多并发实时通信 实现细节稍微有点繁琐，不支持直接的RPC、网络数据交换 </li></ol><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文集中分析了AIDL的实现，AIDL文件接口的声明是方便as编译器生成中间文件，调用底层binder实现好的Binder，IBinder以及IInterface等，其最重要的就是抽象类Stub的asInterface方法和Stub.proxy代理类的实现。分析完AIDl的运行过程，我们很清晰的得出binder在此通信过程所占有的地位。</p><ol><li>首先在数据传递上，跨进程数据传递要求数据必要可以序列化和反序列化，自定义数据类型必须实现Parcelable接口。数据在上层客户端传递到底层binder，需要进行一次封装；底层传给上层服务端再解封使用，处理结果回传到底层继续封装，到达客户端在一次解封。</li><li>AIDl效率很高，可以传递自定义数据类型，可以处理多并发访问请求，需要客户端和服务约定同一套接口服务。</li><li>AIDL基于底层Binder底层实现，实现多并发同步操作，多种数据支持；Message消息则是AIDL的进一步封装，单线程，异步操作，传递数据有限；Intent意图是Binder的最高封装形式，使用Bundle数据传输</li></ol><p>借助于底层binder机制的实现，以及系统为上层应用提供了Binder，IBinder等类和接口，加上AIDL语言的支持，上层应用将很容易的实现应用之间的跨进程通信。此篇仅仅是binder的开篇引入，后续会从底层分析binder的实现。</p><p><strong><em>由上总结，作为将来成为大佬级人物的你，还有什么理由不学习一下Binder跨进程通信机制呢？</em></strong></p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/ls5718/article/details/51854106" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Binder分析 </category>
          
          <category> AIDL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AIDL </tag>
            
            <tag> Binder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码编译之make流程分析</title>
      <link href="/FuckCode/2018/06/27/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8Bmake%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/FuckCode/2018/06/27/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8Bmake%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>前面分别分析了安卓源码编译过程中 source 和 lunch 命令下的具体操作流程。其中source是向shell环境导入相关变量，lunch命令则是执行build/envsetup.sh文件中定义好的函数，与lunch函数相似，编译系统命令m（make），mm，mmm等命令也是其中定义好的方法，下面我们就来具体分析一下。</strong></p><a id="more"></a><h3 id="make编译具体分析"><a href="#make编译具体分析" class="headerlink" title="make编译具体分析"></a>make编译具体分析</h3><h4 id="make（m）分析"><a href="#make（m）分析" class="headerlink" title="make（m）分析"></a>make（m）分析</h4><p>m，mm，mmmm等方法均等定义在build/envsetup.sh中，其就是make命令的简写，代表从源码跟路径开始编译，具体代码如下：</p><pre><code>function m(){    local T=$(gettop)    local DRV=$(getdriver $T)    if [ &quot;$T&quot; ]; then        $DRV make -C $T -f build/core/main.mk $@    else        echo &quot;Couldn&apos;t locate the top of the tree.  Try setting TOP.&quot;        return 1    fi}</code></pre><p>代码可以看出，获取到源码跟路径后，由此获取到mak编译所需驱动，直接调用 make -C 指定工作目录T，之后通过-f指定Makefile文件，最后将m方法传递的参数$@作为命令make的参数进行编译操作。</p><h4 id="mm-分析"><a href="#mm-分析" class="headerlink" title="mm 分析"></a>mm 分析</h4><p>方法mm表示编译当前路径下的所有模块，不包含依赖。其具体的脚本文件内容如下：</p><pre><code>function mm(){    local T=$(gettop)    local DRV=$(getdriver $T)    # If we&apos;re sitting in the root of the build tree, just do a    # normal make.    if [ -f build/core/envsetup.mk -a -f Makefile ]; then        $DRV make $@    else        # Find the closest Android.mk file.        local M=$(findmakefile)        local MODULES=        local GET_INSTALL_PATH=        local ARGS=        # Remove the path to top as the makefilepath needs to be relative        local M=`echo $M|sed &apos;s:&apos;$T&apos;/::&apos;`        if [ ! &quot;$T&quot; ]; then            echo &quot;Couldn&apos;t locate the top of the tree.  Try setting TOP.&quot;            return 1        elif [ ! &quot;$M&quot; ]; then            echo &quot;Couldn&apos;t locate a makefile from the current directory.&quot;            return 1        else            for ARG in $@; do                case $ARG in                  GET-INSTALL-PATH) GET_INSTALL_PATH=$ARG;;                esac            done            if [ -n &quot;$GET_INSTALL_PATH&quot; ]; then              MODULES=              ARGS=GET-INSTALL-PATH            else              MODULES=all_modules              ARGS=$@            fi            ONE_SHOT_MAKEFILE=$M $DRV make -C $T -f build/core/main.mk $MODULES $ARGS        fi    fi}</code></pre><p>方法mm适用于shell环境当前路径下编译其所在的模块项，具体流程可以总结如下：</p><ol><li>获取源码跟路径，通过判断当前是否存在文件/build/core/envsetup.mk文件和Makefiel文件来确定是否处于源码跟路径，是便执行全局make</li><li>通过findmakefile 方法获取指定的Android.mk文件，找到便停止，得到其绝对路径</li><li>通过取出源码跟路径和找到的绝对路径通过sed命令比对，删除相同部分，获取相对的路径存放于M</li><li>将找到的Android.mk文件的相对路径设置给环境变量ONE_SHOT_MAKE，表示接下来要对它进行编译</li><li><p>由于mm后面一半不接参数，这里源码可以看出 MODULES=all_modules 表示编译指定Anroid.mk文件的所有模块；如果有参数则对参数判断在设置编译选项</p><p> findmakefile代码具体如下：</p><pre><code>function findmakefile(){    TOPFILE=build/core/envsetup.mk    local HERE=$PWD    T=    while [ \( ! \( -f $TOPFILE \) \) -a \( $PWD != &quot;/&quot; \) ]; do        T=`PWD= /bin/pwd`        if [ -f &quot;$T/Android.mk&quot; ]; then            # 如果找到Android.mk，echo出来的全路径将作为函数的返回值赋给某个变量            echo $T/Android.mk            \cd $HERE            return        fi        # 向上循环查找        \cd ..    done    \cd $HERE}</code></pre></li></ol><h4 id="mmm-具体分析"><a href="#mmm-具体分析" class="headerlink" title="mmm 具体分析"></a>mmm 具体分析</h4><p>mmm 后面可以传入编译的路径，编译的模块名称，如下所示：</p><pre><code>mmm &lt;dir-1&gt; &lt;dir-2&gt; ... &lt;dir-N&gt;[:module-1,module-2,...,module-M] </code></pre><p>其中，dir-1、dir-2、dir-N都是包含有Android.mk文件的目录。在最后一个目录dir-N的后面可以带一个冒号，冒号后面可以通过逗号分隔一系列的模块名称module-1、module-2和module-M，用来表示要编译前面指定的Android.mk中的哪些模块。具体的代码如下：</p><pre><code>function mmm(){    local T=$(gettop)    local DRV=$(getdriver $T)    if [ &quot;$T&quot; ]; then        local MAKEFILE=        local MODULES=        local ARGS=        local DIR TO_CHOP        local GET_INSTALL_PATH=        # 将以横线“-”开头的字符串提取出，取出编译选项参数        local DASH_ARGS=$(echo &quot;$@&quot; | awk -v RS=&quot; &quot; -v ORS=&quot; &quot; &apos;/^-.*$/&apos;)        # 将非以横线“-”开头的字符串提取出来，跟在命令mmm后面的字符串        # “&lt;dir-1&gt; &lt;dir-2&gt; ... &lt;dir-N&gt;[:module-1,module-2,...,module-M]”        # 取出路径和模块名        local DIRS=$(echo &quot;$@&quot; | awk -v RS=&quot; &quot; -v ORS=&quot; &quot; &apos;/^[^-].*$/&apos;)        for DIR in $DIRS ; do            # 将取出字符匹配到的第一个&quot;：&quot;至结尾的数据，删除&quot;，&quot;            # 第一个sed获得的是一系列以逗号分隔的模块名称列表            # 第二个sed命令用来将前面获得的以逗号分隔的模块名称列表转化为以空格分隔的模块名称列表            MODULES=`echo $DIR | sed -n -e &apos;s/.*:\(.*$\)/\1/p&apos; | sed &apos;s/,/ /&apos;`            if [ &quot;$MODULES&quot; = &quot;&quot; ]; then                # 不指定modules名称状态                MODULES=all_modules            fi            # 第一个sed命令将原来DIR字符串后面的冒号以及冒号后面的模块列表字符串删掉            # 第二个sed命令将执行前面一个sed命令获得的目录后面的&quot;/&quot;斜线去，这里的&quot;：&quot;同于&quot;/&quot;，为定界符之意            # 此处获得一个末尾不带有斜线“/”的真正路径，并且保存在变量DIR中            DIR=`echo $DIR | sed -e &apos;s/:.*//&apos; -e &apos;s:/$::&apos;`            if [ -f $DIR/Android.mk ]; then                # cd -P进入非链接的真实路径后返回绝对路径，计算字符数，删除其中空格                local TO_CHOP=`(\cd -P -- $T &amp;&amp; pwd -P) | wc -c | tr -d &apos; &apos;`                # 字符数加1，得到的值保存在变量TO_CHOP中                local TO_CHOP=`expr $TO_CHOP + 1`                # 执行/bin/pwd命令获得当前执行命令mmm的目录START                local START=`PWD= /bin/pwd`                # 通过cut命令获得当前目录START相对于Android源码根目录T的路径，并且保存在变量MFILE中                # 打印START路径后，裁剪指定字符长度后面的路径                local MFILE=`echo $START | cut -c${TO_CHOP}-`                if [ &quot;$MFILE&quot; = &quot;&quot; ] ; then                # 如果变量MFILE的值等于空，就表明是在Android源码根目录T中执行mmm命令，                # 这时候就表明变量DIR描述的就是相对Android源码根目录T的一个目录，                # 这时候指定的Android.mk文件相对于Android源码根目录T的路径就为$DIR/Android.mk                    MFILE=$DIR/Android.mk                else                # 如果变量MFILE的值不等于空，就表明是在Android源码根目录T的某一个子目录中执行mmm命令，                # 这时候$MFILE/$DIR/Android.mk表示的Android.mk文件路径才是相对于Android源码根目录T的                    MFILE=$MFILE/$DIR/Android.mk                fi                # 将获得的Android.mk路径MFILE附加在变量MAKEFILE描述的字符串的后面，并且以空格分隔                MAKEFILE=&quot;$MAKEFILE $MFILE&quot;            else                case $DIR in                # 如果变量DIR描述的不是一个真正的路径，并且它的值等于&quot;snod&quot;、&quot;showcomands&quot;、“dist”或者“incrementaljavac”，                # 那么它描述的其实是make修饰命令                  showcommands | snod | dist | incrementaljavac | *=*) ARGS=&quot;$ARGS $DIR&quot;;;                  GET-INSTALL-PATH) GET_INSTALL_PATH=$DIR;;                  *) echo &quot;No Android.mk in $DIR.&quot;; return 1;;                esac            fi        done        # 变量MAKEFILE保存的是要编译的Android.mk文件列表，它们都是相对于Android源码根目录的路径，        # 变量DASH_ARGS保存的是原来执行mmm命令时带的选项参数，        # 变量MODULES保存的是指定要编译的模块名称，变量ARGS保存的是修饰命令        if [ -n &quot;$GET_INSTALL_PATH&quot; ]; then          ARGS=$GET_INSTALL_PATH          MODULES=        fi        # 变量MAKEFILE的内容通过环境变量ONE_SHOT_MAKEFILE传递给make命令，        # 而其余变量都是通过参数的形式传递给make命令，并且变量MODULES作为make命令的目标        ONE_SHOT_MAKEFILE=&quot;$MAKEFILE&quot; $DRV make -C $T -f build/core/main.mk $DASH_ARGS $MODULES $ARGS    else        echo &quot;Couldn&apos;t locate the top of the tree.  Try setting TOP.&quot;        return 1    fi}</code></pre><p>注释中已对代码进行了相当程度的注释，基本可以无缝看懂。这里总结一下期间复杂的流程：</p><ol><li><p>调用函数gettop获得Android源码根目录。</p></li><li><p>通过命令awk将执行命令mmm时指定的选项参数提取出来，也就是将以横线“-”开头的字符串提取出来，并且保存在变量DASH_ARGS中。</p></li><li><p>通过命令awk将执行命令mmm时指定的非选项参数提取出来，也就是将非以横线“-”开头的字符串提取出来，并且保存在变量DIRS中。这里得到的实际上就是跟在命令mmm后面的字符串“<dir-1> <dir-2> … <dir-n>[:module-1,module-2,…,module-M]”。</dir-n></dir-2></dir-1></p></li><li><p>变量DIRS保存的字符串可以看成是一系以空格分隔的子字符串，因此，就可以通过一个for循环来对这些子字府串进行遍历。每一个子字符串DIR描述的都是一个包含有Android.mk文件的目录。对每一个目录DIR执行以下操作</p><pre><code>4.1 由于目录DIR后面可能会通过冒号指定有模块名称，因此就先通过两个sed命令来获得这些模块名称。第一个sed命令获得的是一系列以逗号分隔的模块名称列表，第二个sed命令用来将前面获得的以逗号分隔的模块名称列表转化为以空格分隔的模块名称列表。最后，获得的以空格分隔的模块名称列表保存在变量MODULES中。由于目录DIR后面也可能不指定有模块名称，因此前面得到的变量MODULES的值就会为空。在这种情况下，需要将变量MODULES的值设置为“all_modules”，表示要编译的是所有模块。4.2 通过两个sed命令获得真正的目录DIR。第一个sed命令将原来DIR字符串后面的冒号以及冒号后面的模块列表字符串删掉。第二个sed命令将执行前面一个sed命令获得的目录后面的&quot;/&quot;斜线去掉，最后就得到一个末尾不带有斜线“/”的路径，并且保存在变量DIR中。4.3 如果变量DIR描述的是一个真正的路径，也就是在该路径下存在一个Android.mk文件，那么就进行以下处理：        4.3.1 统计Android源码根目录T包含的字符数，并且将这个字符数加1，得到的值保存在变量TO_CHOP中。        4.3.2 通过执行/bin/pwd命令获得当前执行命令mmm的目录START。        4.3.3 通过cut命令获得当前目录START相对于Android源码根目录T的路径，并且保存在变量MFILE中。        4.3.4 如果变量MFILE的值等于空，就表明是在Android源码根目录T中执行mmm命令，这时候就表明变量DIR描述的就是相对Android源码根目录T的一个目录，这时候指定的Android.mk文件相对于Android源码根目录T的路径就为$DIR/Android.mk。        4.3.5 如果变量MFILE的值不等于空，就表明是在Android源码根目录T的某一个子目录中执行mmm命令，这时候$MFILE/$DIR/Android.mk表示的Android.mk文件路径才是相对于Android源码根目录T的。        4.3.6 将获得的Android.mk路径MFILE附加在变量MAKEFILE描述的字符串的后面，并且以空格分隔。4.4 如果变量DIR描述的不是一个真正的路径，并且它的值等于&quot;snod&quot;、&quot;showcomands&quot;、“dist”或者“incrementaljavac”，那么它描述的其实是make修饰命令。这四个修饰命令的含义分别如下所示：    4.4.1 snod是“systemimage with no dependencies”的意思，表示忽略依赖性地重新打包system.img。    4.4.2 showcommands表示显示编译过程中执行的命令。    4.4.3 dist表示将编译后产生的发布文件拷贝到out/dist目录中。    4.4.4 incrementaljavac表示对Java源文件采用增量式编译，也就是如果一个Java文件如果没有修改过，那么就不要重新生成对应的class文件。</code></pre></li><li><p>上面的for循环执行完毕，变量MAKEFILE保存的是要编译的Android.mk文件列表，它们都是相对于Android源码根目录的路径，变量DASH_ARGS保存的是原来执行mmm命令时带的选项参数，变量MODULES保存的是指定要编译的模块名称，变量ARGS保存的是修饰命令。其中，变量MAKEFILE的内容通过环境变量ONE_SHOT_MAKEFILE传递给make命令，而其余变量都是通过参数的形式传递给make命令，并且变量MODULES作为make命令的目标</p></li></ol><p>从上面的函数m、mm和mmm的具体代码，我们就可以知道：</p><ol><li><p>mm和mmm命令是类似的，它们都是用来编译某些模块。</p></li><li><p>m命令是make的简单封装，用来编译所有模块。</p></li></ol><p>这里引用罗老师博客中的图片来说明其编译过程：</p><img src="/FuckCode/2018/06/27/Android源码编译之make流程分析/make_jiagou.png" class="make编译流程一览"><h4 id="main-mk文件分析"><a href="#main-mk文件分析" class="headerlink" title="main.mk文件分析"></a>main.mk文件分析</h4><p>main.mk文件存在与build/core文件夹下，其通过Android源码根目录下的Makefile文件引用进来，当在源码跟路径下make时候，便会自动调用到main.mk，其代码如下：</p><pre><code>### DO NOT EDIT THIS FILE ###include build/core/main.mk### DO NOT EDIT THIS FILE ###</code></pre><p>build/core/main.mk是Android编译系统的入口文件，它通过加载其它的mk文件来对Android源码中的各个模块进行编译，以及将编译出来的文件打包成各种镜像文件。以下就是build/core/main.mk文件的主要内容：</p><pre><code>......# This is the default target.  It must be the first declared target..PHONY: droidDEFAULT_GOAL := droid$(DEFAULT_GOAL):......# These goals don&apos;t need to collect and include Android.mks/CleanSpec.mks# in the source tree.dont_bother_goals := clean clobber dataclean installclean \    help out \    snod systemimage-nodeps \    stnod systemtarball-nodeps \    userdataimage-nodeps userdatatarball-nodeps \    cacheimage-nodeps \    vendorimage-nodeps \    ramdisk-nodeps \    bootimage-nodeps \    recoveryimage-nodepsifneq ($(filter $(dont_bother_goals), $(MAKECMDGOALS)),)dont_bother := trueendif# Targets that provide quick help on the build system.include $(BUILD_SYSTEM)/help.mk# Set up various standard variables based on configuration# and host information.include $(BUILD_SYSTEM)/config.mk# CTS-specific config.-include cts/build/config.mk# This allows us to force a clean build - included after the config.mk# environment setup is done, but before we generate any dependencies.  This# file does the rm -rf inline so the deps which are all done below will# be generated correctlyinclude $(BUILD_SYSTEM)/cleanbuild.mk# Include the google-specific config-include vendor/google/build/config.mk......ifneq ($(ONE_SHOT_MAKEFILE),)# We&apos;ve probably been invoked by the &quot;mm&quot; shell function# with a subdirectory&apos;s makefile.include $(ONE_SHOT_MAKEFILE)......else # ONE_SHOT_MAKEFILE## Include all of the makefiles in the system## Can&apos;t use first-makefiles-under here because# --mindepth=2 makes the prunes not work.subdir_makefiles := \    $(shell build/tools/findleaves.py --prune=out --prune=.repo --prune=.git $(subdirs) Android.mk)include $(subdir_makefiles)endif # ONE_SHOT_MAKEFILEifneq ($(dont_bother),true)## Include all of the makefiles in the system## Can&apos;t use first-makefiles-under here because# --mindepth=2 makes the prunes not work.subdir_makefiles := \    $(shell build/tools/findleaves.py $(FIND_LEAVES_EXCLUDES) $(subdirs) Android.mk)$(foreach mk, $(subdir_makefiles), $(info including $(mk) ...)$(eval include $(mk)))endif # dont_bother......# -------------------------------------------------------------------# Define dependencies for modules that require other modules.# This can only happen now, after we&apos;ve read in all module makefiles.## TODO: deal with the fact that a bare module name isn&apos;t# unambiguous enough.  Maybe declare short targets like# APPS:Quake or HOST:SHARED_LIBRARIES:libutils.# BUG: the system image won&apos;t know to depend on modules that are# brought in as requirements of other modules.define add-required-deps$(1): $(2)endef$(foreach m,$(ALL_MODULES), \  $(eval r := $(ALL_MODULES.$(m).REQUIRED)) \  $(if $(r), \    $(eval r := $(call module-installed-files,$(r))) \    $(eval $(call add-required-deps,$(ALL_MODULES.$(m).INSTALLED),$(r))) \   ) \ )......modules_to_install := $(sort \    $(ALL_DEFAULT_INSTALLED_MODULES) \    $(product_FILES) \    $(foreach tag,$(tags_to_install),$($(tag)_MODULES)) \    $(call get-tagged-modules, shell_$(TARGET_SHELL)) \    $(CUSTOM_MODULES) \  )......# build/core/Makefile contains extra stuff that we don&apos;t want to pollute this# top-level makefile with.  It expects that ALL_DEFAULT_INSTALLED_MODULES# contains everything that&apos;s built during the current make, but it also further# extends ALL_DEFAULT_INSTALLED_MODULES.ALL_DEFAULT_INSTALLED_MODULES := $(modules_to_install)include $(BUILD_SYSTEM)/Makefilemodules_to_install := $(sort $(ALL_DEFAULT_INSTALLED_MODULES))ALL_DEFAULT_INSTALLED_MODULES :=endif # dont_bother......# -------------------------------------------------------------------# This is used to to get the ordering right, you can also use these,# but they&apos;re considered undocumented, so don&apos;t complain if their# behavior changes..PHONY: prebuiltprebuilt: $(ALL_PREBUILT)......# All the droid stuff, in directories.PHONY: filesfiles: prebuilt \        $(modules_to_install) \        $(modules_to_check) \        $(INSTALLED_ANDROID_INFO_TXT_TARGET)......# Build files and then package it into the rom formats.PHONY: droidcoredroidcore: files \    systemimage \    $(INSTALLED_BOOTIMAGE_TARGET) \    $(INSTALLED_RECOVERYIMAGE_TARGET) \    $(INSTALLED_USERDATAIMAGE_TARGET) \    $(INSTALLED_CACHEIMAGE_TARGET) \    $(INSTALLED_FILES_FILE)......# Dist for droid if droid is among the cmd goals, or no cmd goal is given.ifneq ($(filter droid,$(MAKECMDGOALS))$(filter ||,|$(filter-out $(INTERNAL_MODIFIER_TARGETS),$(MAKECMDGOALS))|),)ifneq ($(TARGET_BUILD_APPS),)  # If this build is just for apps, only build apps and not the full system by default........PHONY: apps_onlyapps_only: $(unbundled_build_modules)droid: apps_onlyelse # TARGET_BUILD_APPS......# Building a full system-- the default is to build droidcoredroid: droidcore dist_filesendif # TARGET_BUILD_APPSendif # droid in $(MAKECMDGOALS)......# phony target that include any targets in $(ALL_MODULES).PHONY: all_modulesall_modules: $(ALL_MODULES)......</code></pre><p>以上罗列了main.mk文件中重要的部分，由于本人能力有限，只能理解一部分，这里绝大部分参考了罗老师的博客内容，文章结尾会给出参考文章链接。</p><ol><li>定义默认make目标为droid。目标droid根据不同的情形有不同的依赖关系。如果在初始化编译环境时，指定了TARGET_BUILD_APPS环境变量，那么就表示当前只编译特定的模块，这些特定的模块保存在变量unbundled_build_modules中，这时候目标droid就透过另外一个伪目标app_only依赖它们。如果在初始化编译环境时没有指定TARGET_BUILD_APPS环境变量，那么目标droid就依赖于另外两个文件droidcore和dist_files。droidcore是一个make伪目标，它依赖于各种预编译文件，以及system.img、boot.img、recovery.img和userdata.img等镜像文件。dist_files也是一个make伪目标，用来指定一些需要在编译后拷贝到out/dist目录的文件。也就是说，当我们在Android源码目录中执行不带目标的make命令时，默认就会对目标droid进行编译，也就是会将整个Android系统编译出来。</li><li><p>加载build/core/config.mk文件。从前面Android编译系统环境初始化过程分析一文可以知道，在加载build/core/config.mk文件的过程中，会在执行make命令的进程中完成对Android编译环境的初始化过程，也就是会指定好目标设备以及编译类型。</p></li><li><p>加载build/croe/definitions.mk文件。该文件定义了很多在编译过程中要用到的宏，相当于就是定义了很多通用函数，供编译过程调用。</p></li><li><p>如果在执行make命令时，指定的不是清理文件相关的目标，也就是不是clean、clobber、dataclean和installclean等目标，那么就会将变量dont_bother的值设置为true，表示接下来要执行的是编译命令。</p></li><li><p>在变量dont_bother的值等于true的情况下，如果环境变量ONE_SHOT_MAKEFILE的值不等于空，也就是我们执行的是mm或者mmm命令，那么就表示要编译的是特定的模块。这些指定要编译的模块的Android.mk文件路径就保存在环境变量ONE_SHOT_MAKEFILE中，因此直接将这些Android,mk文件加载进来就获得相应的编译规则。另一方面，如果环境变量ONE_SHOT_MAKEFILE的值等于空，那么就说明我们执行的是m或者make命令，那么就表示要对Android源代码中的所有模块进行编译，这时候就通过build/tools/findleaves.py脚本获得Android源代码工程下的所有Android.mk文件的路径列表，并且将这些Android.mk文件加载进行获得相应的编译规则。</p></li><li><p>上一步指定的Android.mk文件加载完成之后，变量ALL_MODULES就包含了所有要编译的模块的名称，这些模块名称以空格来分隔形成成一个列表。</p></li><li><p>生成模块依赖规则。每一个模块都可以通过LOCAL_REQUIRED_MODULES来指定它所依赖的其它模块，也就是说当一个模块被安装时，它所依赖的其它模块也同样会被安装。每一个模块m依赖的所有模块都会被保存在ALL_MODULES.$(m).REQUIRED变量中。对于每一个被依赖模块r，我们需要获得它的安装文件，也就是最终生成的模块文件的文件路径，以便可以生成相应的编译规则。获得一个模块m的安装文件是通过调用函数module-installed-files来实现的，实质上就是保存在$(ALL_MODULES.$(m).INSTALLED变量中。知道了一个模块m的所依赖的模块的安装文件路径之后，我们就可以通过函数add-required-deps来指定它们之间的依赖关系了。注意，这里实际上指定的是模块m的安装文件与它所依赖的模块r的安装文件的依赖关系。</p></li><li><p>将所有要安装的模块都保存在变量ALL_DEFAULT_INSTALLED_MODULES中，并且将build/core/Makefie文件加载进来。 build/core/Makefie文件会根据要安装的模块产成system.img、boot.img和recovery.img等镜像文件的生成规则。</p></li><li><p>前面提到，当执行mm命令时，make目标指定为all_moudles。另外，当执行mmm命令时，默认的make目标也指定为all_moudles。因此，我们需要指定目标all_modules的编译规则，实际上只要将它依赖于当前要编译的所有模块就行了，也就是依赖于由变量ALL_MODULES所描述的模块。</p></li></ol><p>写到这里，很是纠结，能力有限，内容无法继续下去，这里就告一段落吧！</p><h4 id="mk模块文件分析"><a href="#mk模块文件分析" class="headerlink" title="mk模块文件分析"></a>mk模块文件分析</h4><p>Android源码内的工程跟目录下都有一个Android.mk的编译文件，我们随便挑一个来分析一下，如下：</p><pre><code>LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_PACKAGE_NAME := ProvisionLOCAL_CERTIFICATE := platformLOCAL_PROGUARD_FLAG_FILES := proguard.flagsinclude $(BUILD_PACKAGE)</code></pre><p>以上为安卓项目中的一个正常的Android.mk文件内容，下面我们来分析一下：</p><ol><li>每个Android.mk文件开头都要声明一个重要的变量LOCAL_PATH，用来指定当前正在编译的模块的目录。这里通过调用宏my-dir来获得，其具体方法定义在build/core/definitions.mk文件，此文件还封装了其他相关常用的mk文件操作方法，具体可自行查看。</li><li>每一个模块在开始编译之前，都必须显示的先对内部变量进行清理，然后再进行初始化。Android编译系统定义了非常多的模块局部变量，因此我们不可能手动地一个一个清理，需要加载一个由变量CLEAR_VARS指定的Makefile脚本来帮我们自动清理。变量CLEAR_VARS的值定义在build/core/config.mk文件，它的值等于build/core/clear_vars.mk。</li><li>Android.mk文件接下来就是通过其它的LOCAL变量定义模块名称、源文件，以及所要依赖的各种库文件等等。例如，在我们这个例子，模块名称定义为Provision，参与编译的源文件通过调用生命好的函数call all-subdir-java-files来获取。</li><li>LOCAL_MODULE_TAGS 指定编译选项，optional指该模块在所有版本下都编译，其他还有user，eng等。</li><li>LOCAL_CERTIFICATE 指定平台签名platform，相当于app发布所需的签名文件，在make系统中使用此标签指定系统签名。</li><li>LOCAL_PROGUARD_FLAG_FILES 指的是代码混淆参考文件，这里不多说了。</li><li><p>BUILD_PACKAGE 指定编译文件类型。mk文件通过加载一个模板文件来告诉编译系统它所要编译的模块的类型。例如，上面 include $(BUILD_PACKAGE) 表示编译的APK文件，其定义在build/core/package.mk中。其他的编译类型如下：</p><pre><code>BUILD_PACKAGE：指向build/core/package.mk，用来编译APK文件。BUILD_JAVA_LIBRARY：指向build/core/java_library.mk，用来编译Java库文件。BUILD_STATIC_JAVA_LIBRARY：指向build/core/tatic_java_library.mk，用来编译Java静态库文件。BUILD_STATIC_LIBRARY：指向build/core/static_library.mk，用来编译静态库文件。也就是.a文件。BUILD_EXECUTABLE：指向build/core/executable.mk，用来编译可执行文件。BUILD_PREBUILT：指向build/core/prebuilt.mk。用来编译已经预编译好的第三方库文件，实际上是将这些预编译好的第三方库文件拷贝到合适的位置去，以便可以让其它模块引用。</code></pre></li></ol><p>更多的Android.mk标签内容还有很多，这里就不多做介绍。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>本想将安卓编译系统分三步走的方式系统的梳理一遍，无奈到了make模块时真的感觉自己是有心无力，能力有限，很多东西吃不透。其中很大部分借鉴了罗升阳老师博客中的内容，自己初看的时候也基本是一头雾水，无从下笔。但是还是硬生生的憋出来了部分，主要还是安卓源码诺大的工程，岂能是一两字说得清楚。</p></li><li><p>到这里make部分只能先告一段落，以上内容分析并不够彻底，有很大程度的借鉴学习。日后随着本人能力的不断提升，后续有所悟，再继续回来修改补充，进一步完善。</p></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><a href="https://blog.csdn.net/luoshengyang/article/details/19023609" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>推荐博文：老罗的Android之旅</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码编译之lunch流程分析</title>
      <link href="/FuckCode/2018/06/27/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8Blunch%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/FuckCode/2018/06/27/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8Blunch%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>通过之前介绍的source导入编译源码的相关配置，下面就进入了lunch操作。用户通过source build/envsetup.sh命令后，系统初始化相关变量环境工作，脚本提供一个lunch函数，让用户选择自己想要编译的版本分支，下面我们就来具体分析一下。</strong></p><a id="more"></a><h3 id="lunch选择合适的编译版本"><a href="#lunch选择合适的编译版本" class="headerlink" title="lunch选择合适的编译版本"></a>lunch选择合适的编译版本</h3><p>在source流程之后，紧接着就是执行lunch操作，lunch操作执行的其实就是build/envsetup.sh脚本中的lunch函数，下面看看lunch函数如何执行。由于lunch代码众多，这里就不总的例举，下面分模块进行具体分析。</p><h4 id="lunch参数处理"><a href="#lunch参数处理" class="headerlink" title="lunch参数处理"></a>lunch参数处理</h4><h5 id="读取lunch参数"><a href="#读取lunch参数" class="headerlink" title="读取lunch参数"></a>读取lunch参数</h5><p>获取用户编译目标到answer变量，如果用户没有输入参数，调用print_lunch_menu打印可选编译项，提示用户继续输入</p><pre><code>local answerif [ &quot;$1&quot; ] ; then    # lunch后面直接带参数    answer=$1else    # lunch后面不带参数，则打印处所有的target product和variant菜单提供用户选择    print_lunch_menu    echo -n &quot;Which would you like? [aosp_arm-eng] &quot;    read answerfi</code></pre><p>打印函数print_lunch_menu如下：</p><pre><code>#该函数负责打印已经定义的版本function print_lunch_menu(){    local uname=$(uname)    echo    echo &quot;You&apos;re building on&quot; $uname    echo    echo &quot;Lunch menu... pick a combo:&quot;    local i=1    local choice    for choice in ${LUNCH_MENU_CHOICES[@]}    do        echo &quot;     $i. $choice&quot;        # i自增1        i=$(($i+1))    done    echo}</code></pre><h5 id="根据参数，判断选择对应的编译版本"><a href="#根据参数，判断选择对应的编译版本" class="headerlink" title="根据参数，判断选择对应的编译版本"></a>根据参数，判断选择对应的编译版本</h5><pre><code>如果判断answer值是否为空，空即默认值缺省值aosp_arm-eng。之后对answer进行异常判断，因为用户输入多样性，需要适当的过滤。    local selection=    if [ -z &quot;$answer&quot; ]    then        # 如果用户在菜单中没有选择，直接回车，则为系统缺省的aosp_arm-eng        selection=aosp_arm-eng    # 不换行输出answer值，静默指定字符匹配开头数字两位内容    elif (echo -n $answer | grep -q -e &quot;^[0-9][0-9]*$&quot;)    then        # 如果answer是选择菜单的数字，则获取该数字对应的字符串        if [ $answer -le ${#LUNCH_MENU_CHOICES[@]} ]        then            selection=${LUNCH_MENU_CHOICES[$(($answer-1))]}        fi    # 如果 answer字符串匹配 *-*模式(*的开头不能为-)    elif (echo -n $answer | grep -q -e &quot;^[^\-][^\-]*-[^\-][^\-]*$&quot;)    then        selection=$answer    fi    if [ -z &quot;$selection&quot; ]    then        echo        echo &quot;Invalid lunch combo: $answer&quot;        return 1    fi</code></pre><p>筛选过程总结如下：</p><ol><li><p>输入为空，静默值aosp_arm-eng</p></li><li><p>输入数字，取出数字前两位</p></li><li><p>输入数字前两位小于编译版本可选项，选定指定数字的编译版本（可选项存在数组，下标为0，需要answer-1）</p></li><li><p>输入字符串，进行匹配过滤。字符串使用”-”连接，而且”-”连接的前后两个子串中都没有”-”，则认为是板型名称字符串，直接赋给selection</p></li></ol><p>经过筛选，selection值还是空，直接报错。</p><h5 id="分离selection中参数product"><a href="#分离selection中参数product" class="headerlink" title="分离selection中参数product"></a>分离selection中参数product</h5><p>将 product-variant模式中的product分离出来，类似从字符串”aosp_arm-eng”中取出”aosp_arm”，具体如下：</p><pre><code>export TARGET_BUILD_APPS=# 将 product-variant模式中的product分离出来local product=$(echo -n $selection | sed -e &quot;s/-.*$//&quot;)# 检查product，调用关系 check_product()-&gt;get_build_var()-&gt;build/core/config.mkcheck_product $productif [ $? -ne 0 ]then    echo    echo &quot;** Don&apos;t have a product spec for: &apos;$product&apos;&quot;    echo &quot;** Do you have the right repo manifest?&quot;    product=fi</code></pre><p>代码具体流程如下：</p><ol><li><p>echo -n $selection | sed -e “s/-.*$//“ </p><p> 不换行取出用户输入的selection，使用sed -e “s/-.<em>$//“过滤掉selection字符串中”-**</em>“的部分后，例如从”aosp_arm-eng”过滤”-eng”得到”aosp_arm”，赋值到product中</p></li></ol><p>2.调用check_product，传入product赋值到TARGET_PRODUCT，之后流程如下：</p><pre><code># 检查指定的TARGET_PRODUCT是否允许，默认的有sim和generic。如果不允许，则输出错误信息，允许则不显示function check_product(){    T=$(gettop)    if [ ! &quot;$T&quot; ]; then        echo &quot;Couldn&apos;t locate the top of the tree.  Try setting TOP.&quot; &gt;&amp;2        return    fi        TARGET_PRODUCT=$1 \        TARGET_BUILD_VARIANT= \        TARGET_BUILD_TYPE= \        TARGET_BUILD_APPS= \        get_build_var TARGET_DEVICE &gt; /dev/null    # hide successful answers, but allow the errors to show}        # 列出make脚本中某变量的值，当前为build/core/config.mkfunction get_build_var(){    T=$(gettop)    if [ ! &quot;$T&quot; ]; then        echo &quot;Couldn&apos;t locate the top of the tree.  Try setting TOP.&quot; &gt;&amp;2        return    fi    (\cd $T; CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core \      command make --no-print-directory -f build/core/config.mk dumpvar-$1)}</code></pre><p> T=$(gettop)获取源码顶层目录，这里不做过多解释。下面是get_build_var中比较复杂的部分：</p><pre><code>(\cd $T; CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core \              command make --no-print-directory -f build/core/config.mk dumpvar-$1)</code></pre><ol><li><p>首先进入源码根目录</p></li><li><p>设置两个静态变量 CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core</p></li><li><p>shell环境中command命令执行make，指定文件build/core/config.mk</p></li><li><p>config.mk会include dumpvar.mk,这个文件中会提取我们传入的dumpvar-TARGET_DEVICE变量中的TARGET_DEVICE，打印TARGET_PRODUCT</p></li></ol><p>总之，函数get_build_var实际上就是通过make命令在Android源代码工程根目录中执行build/core/config.mk文件，并且将make目标设置为dumpvar-$1，也就是dumpvar-TARGET_DEVICE。这里函数如果执行成功，便返回0</p><p>文件build/core/config.mk的内容比较多，这里我们只关注与产品名称合法性检查相关的逻辑，这些逻辑也基本上涵盖了Android编译系统初始化的逻辑，下面具体分析。</p><h4 id="依赖mk文件的导入分析"><a href="#依赖mk文件的导入分析" class="headerlink" title="依赖mk文件的导入分析"></a>依赖mk文件的导入分析</h4><h5 id="相关mk文件的导入"><a href="#相关mk文件的导入" class="headerlink" title="相关mk文件的导入"></a>相关mk文件的导入</h5><p>build/core/config.mk 中 include 了众多的mk文件，这里例举其中重要的部分：</p><pre><code>...# Various mappings to avoid hard-coding paths all over the placeinclude $(BUILD_SYSTEM)/pathmap.mk# ---------------------------------------------------------------# Define most of the global variables.  These are the ones that# are specific to the user&apos;s build configuration.include $(BUILD_SYSTEM)/envsetup.mk...include $(BUILD_SYSTEM)/dumpvar.mk</code></pre><p>其中比较重要的是中间的 envsetup.mk 这个文件</p><h5 id="envsetup-mk-文件分析"><a href="#envsetup-mk-文件分析" class="headerlink" title="envsetup.mk 文件分析"></a>envsetup.mk 文件分析</h5><p>envsetup.mk 文件中逻辑众多，这里我们只关注重要的两个逻辑：AndroidProduct.mk和BoardCong.mk 文件的搜集工作。代码如下：</p><pre><code>...# 搜集AndroidProduct.mk文件include $(BUILD_SYSTEM)/product_config.mk# Boards may be defined under $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)# or under vendor/*/$(TARGET_DEVICE).  Search in both places, but# make sure only one exists.# Real boards should always be associated with an OEM vendor.# 搜集BoardConfig.mk文件board_config_mk := \    $(strip $(wildcard \        $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)/BoardConfig.mk \        $(shell test -d device &amp;&amp; find device -maxdepth 4 -path &apos;*/$(TARGET_DEVICE)/BoardConfig.mk&apos;) \        $(shell test -d vendor &amp;&amp; find vendor -maxdepth 4 -path &apos;*/$(TARGET_DEVICE)/BoardConfig.mk&apos;) \    ))ifeq ($(board_config_mk),)  $(error No config file found for TARGET_DEVICE $(TARGET_DEVICE))endififneq ($(words $(board_config_mk)),1)  $(error Multiple board config files for TARGET_DEVICE $(TARGET_DEVICE): $(board_config_mk))endifinclude $(board_config_mk)ifeq ($(TARGET_ARCH),)  $(error TARGET_ARCH not defined by board config: $(board_config_mk))endifTARGET_DEVICE_DIR := $(patsubst %/,%,$(dir $(board_config_mk)))board_config_mk :=...</code></pre><h5 id="AndroidProducts-mk文件搜集及TARGET-DEVICE值的确定"><a href="#AndroidProducts-mk文件搜集及TARGET-DEVICE值的确定" class="headerlink" title="AndroidProducts.mk文件搜集及TARGET_DEVICE值的确定"></a>AndroidProducts.mk文件搜集及TARGET_DEVICE值的确定</h5><p>envsetup.mk 文件首先会 include product_config.mk文件，这个文件中设置了相关的变量，如下：</p><pre><code># 步骤1ifneq ($(strip $(TARGET_BUILD_APPS)),)all_product_configs := $(call get-product-makefiles,\    $(SRC_TARGET_DIR)/product/AndroidProducts.mk)elseall_product_configs := $(get-all-product-makefiles)endif# 步骤2current_product_makefile :=all_product_makefiles :=$(foreach f, $(all_product_configs),\    $(eval _cpm_words := $(subst :,$(space),$(f)))\    $(eval _cpm_word1 := $(word 1,$(_cpm_words)))\    $(eval _cpm_word2 := $(word 2,$(_cpm_words)))\    $(if $(_cpm_word2),\        $(eval all_product_makefiles += $(_cpm_word2))\        $(if $(filter $(TARGET_PRODUCT),$(_cpm_word1)),\            $(eval current_product_makefile += $(_cpm_word2)),),\        $(eval all_product_makefiles += $(f))\        $(if $(filter $(TARGET_PRODUCT),$(basename $(notdir $(f)))),\            $(eval current_product_makefile += $(f)),)))_cpm_words :=_cpm_word1 :=_cpm_word2 :=current_product_makefile := $(strip $(current_product_makefile))all_product_makefiles := $(strip $(all_product_makefiles))# 步骤3ifneq (,$(filter product-graph dump-products, $(MAKECMDGOALS)))$(call import-products, $(all_product_makefiles))elseifndef current_product_makefile$(error Can not locate config makefile for product &quot;$(TARGET_PRODUCT)&quot;)endififneq (1,$(words $(current_product_makefile)))$(error Product &quot;$(TARGET_PRODUCT)&quot; ambiguous: matches $(current_product_makefile))endif$(call import-products, $(current_product_makefile))endif  # Import all or just the current product makefile$(check-all-products)ifneq ($(filter dump-products, $(MAKECMDGOALS)),)$(dump-products)$(error done)endif# 步骤4INTERNAL_PRODUCT := $(call resolve-short-product-name, $(TARGET_PRODUCT))ifneq ($(current_product_makefile),$(INTERNAL_PRODUCT))$(error PRODUCT_NAME inconsistent in $(current_product_makefile) and $(INTERNAL_PRODUCT))endifcurrent_product_makefile :=all_product_makefiles :=all_product_configs :=# 步骤5PRODUCT_BOOT_JARS := $(strip $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_BOOT_JARS))PRODUCT_SYSTEM_SERVER_JARS := $(strip $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_SYSTEM_SERVER_JARS))TARGET_DEVICE := $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE)</code></pre><ol><li><p>检查环境变量TARGET_BUILD_APPS的值是否等于空。如果不等于空，那么就说明此次编译不是针对整个系统，因此只要将核心的产品相关的Makefile文件加载进来就行了，否则的话，就要将所有与产品相关的Makefile文件加载进来的。核心产品Makefile文件在$(SRC_TARGET_DIR)/product/AndroidProducts.mk文件中指定，也就是在build/target/product/AndroidProducts.mk文件，通过调用函数get-product-makefiles可以获得。所有与产品相关的Makefile文件可以通过另外一个函数get-all-product-makefiles获得。无论如何，最终获得的产品Makefie文件列表保存在变量all_product_configs中。</p></li><li><p>遍历变量all_product_configs所描述的产品Makefile列表，并且在这些Makefile文件中，找到名称与环境变量TARGET_PRODUCT的值相同的文件，保存在另外一个变量current_product_makefile中，作为需要为当前指定的产品所加载的Makefile文件列表。在这个过程当中，上一步找到的所有的产品Makefile文件也会保存在变量all_product_makefiles中。注意，环境变量TARGET_PRODUCT的值是在我们执行lunch命令的时候设置并且传递进来的。</p></li><li><p>如果指定的make目标等于product-graph或者dump-products，那么就将所有的产品相关的Makefile文件加载进来，否则的话，只加载与目标产品相关的Makefile文件。从前面的分析可以知道，此时的make目标为dumpvar-TARGET_DEVICE，因此接下来只会加载与目标产品，即$(TARGET_PRODUCT)，相关的Makefile文件，这是通过调用另外一个函数import-products实现的。</p></li><li><p>调用函数resolve-short-product-name解析环境变量TARGET_PRODUCT的值，将它变成一个Makefile文件路径。并且保存在变量INTERNAL_PRODUCT中。这里要求变量INTERNAL_PRODUCT和current_product_makefile的值相等，否则的话，就说明用户指定了一个非法的产品名称。</p></li><li><p>找到一个名称为PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE的变量，并且将它的值保存另外一个变量TARGET_DEVICE中。变量PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE是在加载产品Makefile文件的过程中定义的，用来描述当前指定的产品的名称</p></li></ol><p>上述过程主要涉及到了get-all-product-makefiles、import-products和resolve-short-product-name三个关键函数，理解它们的执行过程对理解Android编译系统的初始化过程很有帮助，接下来我们分别分析它们的实现。</p><h5 id="查找product相关文件的mk实现"><a href="#查找product相关文件的mk实现" class="headerlink" title="查找product相关文件的mk实现"></a>查找product相关文件的mk实现</h5><p>其主要方法集中在 build/core/product.mk 文件中，下面具体分析：</p><ol><li><p>get-all-product-makefiles的具体实现</p><pre><code>define get-all-product-makefiles$(call get-product-makefiles,$(_find-android-products-files))endef</code></pre><p> 首先是调用函数_find-android-products-files来找到Android源代码目录中定义的所有AndroidProducts.mk文件，然后再调用函数get-product-makefiles获得在这里AndroidProducts.mk文件里面定义的产品Makefile文件。</p></li><li><p>_find-android-products-files的具体实现</p><pre><code>define _find-android-products-files$(shell test -d device &amp;&amp; find device -maxdepth 6 -name AndroidProducts.mk) \  $(shell test -d vendor &amp;&amp; find vendor -maxdepth 6 -name AndroidProducts.mk) \  $(SRC_TARGET_DIR)/product/AndroidProducts.mkendef</code></pre><p> 从这里就可以看出，Android源代码目录中定义的所有AndroidProducts.mk文件位于device、vendor或者build/target/product目录或者相应的子目录（最深是6层）中。</p></li><li><p>get-product-makefiles的具体实现</p><pre><code>define get-product-makefiles$(sort \  $(foreach f,$(1), \    $(eval PRODUCT_MAKEFILES :=) \    $(eval LOCAL_DIR := $(patsubst %/,%,$(dir $(f)))) \    $(eval include $(f)) \    $(PRODUCT_MAKEFILES) \   ) \  $(eval PRODUCT_MAKEFILES :=) \  $(eval LOCAL_DIR :=) \ )endef</code></pre><p> 这个函数实际上就是遍历参数$1所描述的AndroidProucts.mk文件列表，并且将定义在这些AndroidProucts.mk文件中的变量PRODUCT_MAKEFILES的值提取出来，形成一个列表返回给调用者。</p><p> 例如：在build/target/product/AndroidProducts.mk文件中，变量PRODUCT_MAKEFILES的值如下所示：</p><pre><code>ifneq ($(TARGET_BUILD_APPS),)PRODUCT_MAKEFILES := \    $(LOCAL_DIR)/aosp_arm.mk \    $(LOCAL_DIR)/full.mk \    ...    $(LOCAL_DIR)/aosp_mips64.mk \    $(LOCAL_DIR)/aosp_x86_64.mkelsePRODUCT_MAKEFILES := \    $(LOCAL_DIR)/core.mk \    $(LOCAL_DIR)/generic.mk \    $(LOCAL_DIR)/generic_x86.mk \    ...endif</code></pre><p> 这里列出的每一个文件都对应于一个产品</p></li><li><p>import-products的具体实现</p><pre><code>define import-products$(call import-nodes,PRODUCTS,$(1),$(_product_var_list))endef</code></pre><p> 它调用另外一个函数import-nodes来加载由参数$1所指定的产品Makefile文件，并且指定了另外两个参数PRODUCTS和$(_product_var_list)。其中，变量_product_var_list也是定义在文件build/core/product.mk中，它的值如下所示：</p><pre><code>_product_var_list := \    PRODUCT_NAME \    PRODUCT_MODEL \    PRODUCT_LOCALES \    PRODUCT_AAPT_CONFIG \    PRODUCT_AAPT_PREF_CONFIG \    PRODUCT_AAPT_PREBUILT_DPI \    PRODUCT_PACKAGES \    PRODUCT_PACKAGES_DEBUG \    PRODUCT_PACKAGES_ENG \    PRODUCT_PACKAGES_TESTS \    PRODUCT_DEVICE \    ...</code></pre><p> 它描述的是在产品Makefile文件中定义在各种变量。import-nodes定义在文件build/core/node_fns.mk中，如下所示:</p><pre><code>## $(1): output list variable name, like &quot;PRODUCTS&quot; or &quot;DEVICES&quot;# $(2): list of makefiles representing nodes to import# $(3): list of node variable names#define import-nodes$(if \  $(foreach _in,$(2), \    $(eval _node_import_context := _nic.$(1).[[$(_in)]]) \    $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \                should be empty here: $(_include_stack))),) \    $(eval _include_stack := ) \    $(call _import-nodes-inner,$(_node_import_context),$(_in),$(3)) \    $(call move-var-list,$(_node_import_context).$(_in),$(1).$(_in),$(3)) \    $(eval _node_import_context :=) \    $(eval $(1) := $($(1)) $(_in)) \    $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \                should be empty here: $(_include_stack))),) \   ) \,)endef</code></pre><ol><li><p>调用函数_import-nodes-inner将参数$2描述的每一个产品Makefile文件加载进来。</p><ol start="2"><li><p>调用函数move-var-list将定义在前面所加载的产品Makefile文件里面的由参数$3指定的变量的值分别拷贝到另外一组独立的变量中。</p></li><li><p>将参数$2描述的每一个产品Makefile文件路径以空格分隔保存在参数$1所描述的变量中，也就是保存在变量PRODUCTS中。</p></li></ol><p>上述第二件事情需要进一步解释一下。由于当前加载的每一个文件都会定义相同的变量，为了区分这些变量，我们需要在这些变量前面加一些前缀。例如，假设加载了build/target/product/full.mk这个产品Makefile文件，它里面定义了以下几个变量：</p><p>PRODUCT_NAME := full<br>PRODUCT_DEVICE := generic<br>PRODUCT_BRAND := Android<br>PRODUCT_MODEL := Full Android on Emulator  </p><p>当调用了函数move-var-list对它进行解析后，就会得到以下的新变量：</p><p>PRODUCTS.build/target/product/full.mk.PRODUCT_NAME := full<br>PRODUCTS.build/target/product/full.mk.PRODUCT_DEVICE := generic<br>PRODUCTS.build/target/product/full.mk.PRODUCT_BRAND := Android<br>PRODUCTS.build/target/product/full.mk.PRODUCT_MODEL := Full Android on Emulator  </p><p>正是由于调用了函数move-var-list，我们在build/core/product_config.mk文件中可以通过PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE来设置变量TARGET_DEVICE的值，这样就确定了PRODUCT_DEVICE的值。</p></li></ol></li></ol><h4 id="BoardConfig-mk文件的加载过程"><a href="#BoardConfig-mk文件的加载过程" class="headerlink" title="BoardConfig.mk文件的加载过程"></a>BoardConfig.mk文件的加载过程</h4><p>分析完AndroidProduct.mk文件的加载，回到build/core/config.mk文件中，接下来我们再看BoardConfig.mk文件的加载过程。</p><h5 id="BoardConfig-mk文件加载"><a href="#BoardConfig-mk文件加载" class="headerlink" title="BoardConfig.mk文件加载"></a>BoardConfig.mk文件加载</h5><pre><code># Boards may be defined under $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)# or under vendor/*/$(TARGET_DEVICE).  Search in both places, but# make sure only one exists.# Real boards should always be associated with an OEM vendor.# 搜集BoardConfig.mk文件board_config_mk := \    $(strip $(wildcard \        $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)/BoardConfig.mk \        $(shell test -d device &amp;&amp; find device -maxdepth 4 -path &apos;*/$(TARGET_DEVICE)/BoardConfig.mk&apos;) \        $(shell test -d vendor &amp;&amp; find vendor -maxdepth 4 -path &apos;*/$(TARGET_DEVICE)/BoardConfig.mk&apos;) \    ))ifeq ($(board_config_mk),)  $(error No config file found for TARGET_DEVICE $(TARGET_DEVICE))endififneq ($(words $(board_config_mk)),1)  $(error Multiple board config files for TARGET_DEVICE $(TARGET_DEVICE): $(board_config_mk))endifinclude $(board_config_mk)ifeq ($(TARGET_ARCH),)  $(error TARGET_ARCH not defined by board config: $(board_config_mk))endifTARGET_DEVICE_DIR := $(patsubst %/,%,$(dir $(board_config_mk)))board_config_mk :=</code></pre><p>其中注释内容已经说的很明白了，board_config_mk 实现了查找BoardConfig.mk文件的具体方法。对应的文件的路径存在两个路径下：(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)和vendor/*/$(TARGET_DEVICE)。</p><ol><li><p>strip $(wildcard \</p><pre><code>$(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)/BoardConfig.mk \$(***))</code></pre><p> wildcard 表示扩展通配符，将（***）内容匹配到$(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)/BoardConfig.mk形式中去</p><p> strip 表示去除结果中的空字符串</p></li><li><p>shell test -d device &amp;&amp; find device -maxdepth 4 -path ‘*/$(TARGET_DEVICE)/BoardConfig.mk’</p><p> shell脚本检查device是否为文件夹，之后查找其内部深度最大4级下,用户选定的编译版本（TARGET_DEVICE）目录下是否存在BoardConfig.mk文件。</p></li></ol><p>BoardConfig.mk文件的位置主要就是由环境变量TARGET_DEVICE来确定，它是用来描述目标产品的硬件模块信息的，例如CPU体系结构。环境变量TARGET_DEVICE用来描述目标设备，它的值是在envsetup.mk文件加载的过程中确定的。一旦目标设备确定后，就可以在$(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)、device/<em>/$(TARGET_DEVICE)和vendor/</em>/$(TARGET_DEVICE)目录中找到对应的BoradConfig.mk文件。注意，变量SRC_TARGET_DIR的值等于build/target。</p><h4 id="小结依赖mk文件的导入"><a href="#小结依赖mk文件的导入" class="headerlink" title="小结依赖mk文件的导入"></a>小结依赖mk文件的导入</h4><ul><li><p><strong>build/core/config.mk</strong> 通过 include 操作依赖众多相关mk文件，比较重要的有以下几个：</p><pre><code>build/envsetup.mkbuild/dumpvar.mk</code></pre></li><li><p>其中<strong>envsetup.mk</strong>包含了：</p><pre><code>build/product_config.mkbuild/board_config.mk</code></pre></li><li><p><strong>product_config.mk</strong> 中实现了product相关方法的实现，完成 AndroidProduct.mk 文件的查找和解析，确定了 TARGET_DECVICE 。其依赖的mk有：</p><pre><code>build/node_fns.mkbuild/product.mkbuild/device.mk</code></pre></li><li><p><strong>board_config.mk</strong> 中实现了 BoardConfig.mk 文件的查找，确定主板配置的相关编译信息。</p></li></ul><h4 id="继续分析lunch参数的处理"><a href="#继续分析lunch参数的处理" class="headerlink" title="继续分析lunch参数的处理"></a>继续分析lunch参数的处理</h4><h5 id="分离selection中参数variant"><a href="#分离selection中参数variant" class="headerlink" title="分离selection中参数variant"></a>分离selection中参数variant</h5><p>接着上面从selection中分离参数product后，便执行分离variant参数的操作，流程如下：</p><pre><code># 将 product-variant模式中的variant分离出来local variant=$(echo -n $selection | sed -e &quot;s/^[^\-]*-//&quot;)# 检查之，看看是否在 (user userdebug eng) 范围内check_variant $variantif [ $? -ne 0 ]then    echo    echo &quot;** Invalid variant: &apos;$variant&apos;&quot;    echo &quot;** Must be one of ${VARIANT_CHOICES[@]}&quot;    variant=fiif [ -z &quot;$product&quot; -o -z &quot;$variant&quot; ]then    echo    return 1fi</code></pre><p>步骤分析如下：</p><ol><li><p>echo -n $selection | sed -e “s/^[^-]*-//“</p><p> 获取过滤字符串中最后一个不是以”-“结尾，且删除”-“之前字符串后剩下的字符串</p></li><li><p>riant $variant</p><pre><code>function check_variant(){    for v in ${VARIANT_CHOICES[@]}    do        if [ &quot;$v&quot; = &quot;$1&quot; ]        then            return 0        fi    done    return 1}</code></pre><p> 检查获取的variant值是否在可选编译项中，在则返回0，否则返回1</p></li></ol><h5 id="导出变量"><a href="#导出变量" class="headerlink" title="导出变量"></a>导出变量</h5><pre><code>export TARGET_PRODUCT=$productexport TARGET_BUILD_VARIANT=$variantexport TARGET_BUILD_TYPE=releaseecho</code></pre><p>代码执行到此处，导出三个系统全局变量TARGET_PRODUCT，TARGET_BUILD_VARIANT，TARGET_BUILD_TYPE</p><h4 id="设置其他编译环境，打印配置信息"><a href="#设置其他编译环境，打印配置信息" class="headerlink" title="设置其他编译环境，打印配置信息"></a>设置其他编译环境，打印配置信息</h4><p>到这里，基本就完成了编译选项的信息采集，下面最后的工作，设置编译环境参数和打印配置信息</p><h5 id="设置其他编译环境"><a href="#设置其他编译环境" class="headerlink" title="设置其他编译环境"></a>设置其他编译环境</h5><pre><code>set_stuff_for_environmentprintconfig</code></pre><p>set_stuff_for_environment 补充剩余环境参数</p><pre><code># 设置android编译需要的环境变量function set_stuff_for_environment(){    settitle    set_java_home    setpaths    set_sequence_number    # MStar Android Patch Begin    set_ota    # MStar Android Patch End    export ANDROID_BUILD_TOP=$(gettop)    # With this environment variable new GCC can apply colors to warnings/errors    export GCC_COLORS=&apos;error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01&apos;    export ASAN_OPTIONS=detect_leaks=0}</code></pre><p>此函数继续补充编译中的一些其他变量。其中set_java_home会检查导出JAVA_HOME这个环境变量，这个环境变量就是JDK所在的路径；setpaths函数会给PATH环境变量补充编译Android需要的一些路径；set_ota则是本源码分支（MSTAR电视系统）配置ota升级文件的相关配置</p><h5 id="打印配置信息"><a href="#打印配置信息" class="headerlink" title="打印配置信息"></a>打印配置信息</h5><p>调用 get_build_var函数，参数 report_config，来打印配置信息</p><pre><code>function printconfig(){    T=$(gettop)    if [ ! &quot;$T&quot; ]; then        echo &quot;Couldn&apos;t locate the top of the tree.  Try setting TOP.&quot; &gt;&amp;2        return    fi    get_build_var report_config}</code></pre><p>至此，lunch流程就分析完毕了。</p><h3 id="make正式编译系统"><a href="#make正式编译系统" class="headerlink" title="make正式编译系统"></a>make正式编译系统</h3><p>具体流程请待下节分析。</p><hr><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>本内容针对 MASTR定制的安卓6.0电视系统，本人能力有限，在分析过程查找了相关的资料，比较有参考价值的在下面链接中提到。</p><p><a href="Android编译系统环境初始化过程分析">参考博客</a></p><blockquote><p>老罗的Android之旅</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Makefile </category>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码编译 </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码编译之source初始化环境分析</title>
      <link href="/FuckCode/2018/06/25/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8Bsource%E5%88%9D%E5%A7%8B%E5%8C%96%E7%8E%AF%E5%A2%83/"/>
      <url>/FuckCode/2018/06/25/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8Bsource%E5%88%9D%E5%A7%8B%E5%8C%96%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p><strong>Android这个庞大的系统，采用的是自己的Android Makefile来进行编译的。在编译系统时，我们通常需要命令行 source build/envsetup.sh 导入相关环境变量，之后 lunch 选择自己想要编译的版本，最后 make 才可进行系统的全局编译。首先我们来分析source build/envsetup.sh的具体执行流程。</strong></p><a id="more"></a><h3 id="编译脚本的导入"><a href="#编译脚本的导入" class="headerlink" title="编译脚本的导入"></a>编译脚本的导入</h3><p>编译安卓系统之前，我们需要在shell环境中，进入安卓源码跟路径下，通过 source build/envsetup.sh 脚本导入安卓系统相关的环境变量。脚本文件提供了很多方法，下面我们来具体分析一下。</p><h4 id="多个方法的声明"><a href="#多个方法的声明" class="headerlink" title="多个方法的声明"></a>多个方法的声明</h4><p>文件build/envsetup.sh是一个bash shell脚本，从它里面定义的函数hmm可以知道，它提供了lunch、m、mm和mmm等命令供我们初始化编译环境或者编译Android源码。</p><pre><code>#!/usr/bin/env bashfunction hmm() {cat &lt;&lt;EOFInvoke &quot;. build/envsetup.sh&quot; from your shell to add the following functions to your environment:- lunch:   lunch &lt;product_name&gt;-&lt;build_variant&gt;- tapas:   tapas [&lt;App1&gt; &lt;App2&gt; ...] [arm|x86|mips|armv5|arm64|x86_64|mips64] [eng|userdebug|user]- croot:   Changes directory to the top of the tree.- m:       Makes from the top of the tree.- mm:      Builds all of the modules in the current directory, but not their dependencies.- mmm:     Builds all of the modules in the supplied directories, but not their dependencies.           To limit the modules being built use the syntax: mmm dir/:target1,target2.- mma:     Builds all of the modules in the current directory, and their dependencies.- mmma:    Builds all of the modules in the supplied directories, and their dependencies....EOF    T=$(gettop)    local A    A=&quot;&quot;    for i in `cat $T/build/envsetup.sh | sed -n &quot;/^[ \t]*function /s/function \([a-z_]*\).*/\1/p&quot; | sort | uniq`; do      A=&quot;$A $i&quot;    done    echo $A}</code></pre><p>函数hmm主要完成三个工作：</p><ol><li>调用另外一个函数gettop获得Android源码的根目录T</li><li>通过cat命令显示一个Here Document，说明$T/build/envsetup.sh文件加载到当前终端后所提供的主要命令</li><li>通过sed命令解析$T/build/envsetup.sh文件，并且获得在里面定义的所有函数的名称，这些函数名称就是$T/build/envsetup.sh文件加载到当前终端后提供的所有命令。</li></ol><p>注意，sed命令是一个强大的文本分析工具，它以行为单位为执行文本替换、删除、新增和选取等操作。函数hmm通过执行以下的sed命令来获得在$T/build/envsetup.sh文件定义的函数的名称：</p><pre><code>cat $T/build/envsetup.sh | sed -n &quot;/^[ \t]*function /s/function \([a-z_]*\).*/\1/p&quot;1. cat读入$T/build/envsetup.sh脚本文件2. 管道命令sed -n &quot;.../p&quot;一起使用，表示单行处理数据3. 命令&quot;/^[ \t]*function /s/function \([a-z_]*\).*/\1&quot;表示匹配文本内容以若干制表符开头的连接字符&quot;function&quot;字符（声明的方法），使用&quot;function ***&quot;替换,其中&quot;***&quot;内容是匹配若干以&quot;a-z&quot;或者&quot;_&quot;为内容的字符串，即声明的方法规则必须是这两种情况4. 最后那个&quot;\1&quot;为样式匹配，表示获取得到匹配并替换后的第一个符合字符串结果</code></pre><p>上面的分析主要是获取脚本文件中声明的各种方法并打印出来。这里可以在控制台输入hmm，即可最后打印出脚本文件所有声明可用的方法。至于其他的方法，这里就不一一例举了，直接进入添加编译分支部分。</p><h4 id="添加默认编译版本"><a href="#添加默认编译版本" class="headerlink" title="添加默认编译版本"></a>添加默认编译版本</h4><p>build/envsetup.sh脚本中开头声明了众多函数，之间夹杂着添加默认编译版本的代码，具体如下：</p><pre><code># 滞空LUNCH_MENU_CHOICES变量值unset LUNCH_MENU_CHOICES# 向环境变量LUNCH_MENU_CHOICES标识的列表中添加项function add_lunch_combo(){    local new_combo=$1    local c    for c in ${LUNCH_MENU_CHOICES[@]} ; do        if [ &quot;$new_combo&quot; = &quot;$c&quot; ] ; then            return        fi    done    LUNCH_MENU_CHOICES=(${LUNCH_MENU_CHOICES[@]} $new_combo)}# add the default one hereadd_lunch_combo aosp_arm-engadd_lunch_combo aosp_arm64-engadd_lunch_combo aosp_mips-engadd_lunch_combo aosp_mips64-engadd_lunch_combo aosp_x86-engadd_lunch_combo aosp_x86_64-eng</code></pre><p>其步骤总结如下：</p><ol><li>滞空LUNCH_MENU_CHOICES变量值用于重新赋值</li><li>声明add_lunch_combo方法，用于向环境变量LUNCH_MENU_CHOICES标识的列表中添加项</li><li>添加默认的几个编译版本</li><li>注意，${LUNCH_MENU_CHOICES[@]}表示数组LUNCH_MENU_CHOICES的所有元素</li></ol><p>其中方法add_lunch_combo中，首先遍历获取LUNCH_MENU_CHOICES中的值，查看取出的值是否和添加的一致，不一致才会执行添加操作</p><h4 id="检查当前shell版本"><a href="#检查当前shell版本" class="headerlink" title="检查当前shell版本"></a>检查当前shell版本</h4><p>对当前的编译系统的shell进行检查和警告。这里只支持bash，如果是其他的shell会发出这个WARNING。之后便是厂商定制脚本的导入部分：</p><pre><code>if [ &quot;x$SHELL&quot; != &quot;x/bin/bash&quot; ]; then    case `ps -o command -p $$` in        *bash*)            ;;        *)            echo &quot;WARNING: Only bash is supported, use of other shell would lead to erroneous results&quot;            ;;    esacfi</code></pre><h4 id="导入厂商定制的脚本"><a href="#导入厂商定制的脚本" class="headerlink" title="导入厂商定制的脚本"></a>导入厂商定制的脚本</h4><p>查找指定文件夹下，指定层级深度的指定文件脚本进行导入，代码如下：</p><pre><code># Execute the contents of any vendorsetup.sh files we can find.for f in `test -d device &amp;&amp; find -L device -maxdepth 4 -name &apos;vendorsetup.sh&apos; 2&gt; /dev/null | sort` \         `test -d vendor &amp;&amp; find -L vendor -maxdepth 4 -name &apos;vendorsetup.sh&apos; 2&gt; /dev/null | sort`do    echo &quot;including $f&quot;    . $fdoneunset f</code></pre><p>下面对上面代码进行解释：</p><ol><li>test -d device ：查看device是否为文件夹，如果是文件夹返回ture。这里device显然是文件夹，返回true，通过 &amp;&amp; 操作符连接后面的指令</li><li>find -L device -maxdepth 4 -name ‘vendorsetup.sh’ 2&gt; /dev/null  ：查找当前decice目录下最深层级4级下名为”vendorsetup.sh”的文件（-L表示跟随所有的符号连接），并且将错误信息丢弃</li><li>| sort  ：附加管道命令，对查询结果进行排序</li><li>echo “including $f”：  打印输出当前找到的 vendorsetup.sh 信息</li><li>. $f： 导入脚本到当前环境中（. 后面有空格，导入当前shell环境，同source，不另开shell进程）</li><li>unset f： 删除shell变量f</li></ol><p>从上面分析，可以看出：脚本文件 build/envsetup.sh 被source到当前shell的过程中，会在vendor和device两个目录将厂商指定的 envsetup.sh 也source到当前shell当中，这样就可以获得厂商提供的产品配置信息。</p><p>例如如下厂商MSTAR定制的脚本信息：</p><pre><code>--&gt; /device/mstar/avocado/vendorsetup.shadd_lunch_combo aosp_avocado-userdebugadd_lunch_combo aosp_avocado_dtmb-userdebug</code></pre><h4 id="addcompletions完成脚本的导入"><a href="#addcompletions完成脚本的导入" class="headerlink" title="addcompletions完成脚本的导入"></a>addcompletions完成脚本的导入</h4><p>在导入三方定制的初始化脚本信息后，便调用addcompletions完成最后的操作，其具体代码如下：</p><pre><code>addcompletionsfunction addcompletions(){    local T dir f    # Keep us from trying to run in something that isn&apos;t bash.    if [ -z &quot;${BASH_VERSION}&quot; ]; then        return    fi    # Keep us from trying to run in bash that&apos;s too old.    if [ ${BASH_VERSINFO[0]} -lt 3 ]; then        return    fi    dir=&quot;sdk/bash_completion&quot;    if [ -d ${dir} ]; then        for f in `/bin/ls ${dir}/[a-z]*.bash 2&gt; /dev/null`; do            echo &quot;including $f&quot;            . $f        done    fi}</code></pre><p>这里主要分为有三步：</p><ol><li>判断安装在系统里的Bash版本，Bash版本名称为空直接返回。可通过echo ${BASH_VERSION}获取版本名</li><li><p>判断系统Bash主版本号是否小于3，是即直接返回</p><pre><code>${BASH_VERSINFO}返回一个数组，这个数组含有6个元素，指示了安装的Bash版本的信息。# BASH_VERSINFO[0] = 3                      # 主版本号.# BASH_VERSINFO[1] = 00                     # 次版本号.# BASH_VERSINFO[2] = 14                     # 补丁级.# BASH_VERSINFO[3] = 1                      # 编译版本.# BASH_VERSINFO[4] = release                # 发行状态.# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # 结构体系</code></pre></li><li><p>判断给定的”sdk/bash_completion”是否为文件夹，是文件夹变列出此文件夹下以[a-z]小写开头的.bash文件，错误信息直接抛弃，之后有的话直接打印输出，并通过”. $f”导入当前shell环境</p></li></ol><p>到此，source导入脚本初始化编译环境部分就告一段落了。</p><h3 id="lunch选择合适的编译版本"><a href="#lunch选择合适的编译版本" class="headerlink" title="lunch选择合适的编译版本"></a>lunch选择合适的编译版本</h3><ul><li>原本打算一次性将编译安卓系统的三步骤一起讲完，但由于具体分析脚本文件内容比较多，这里就按照编译步骤，也分为三部分。下面两节便分别具体分析一下lunch和make的具体流程。</li></ul><hr><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本内容针对 MASTR定制的安卓6.0电视系统，本人能力有限，在分析过程查找了相关的资料，比较有参考价值的在下面链接中提到。</p><p><a href="https://blog.csdn.net/luoshengyang/article/details/18466779" target="_blank" rel="noopener">参考博客</a></p><blockquote><p>老罗的Android之旅</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码编译 </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Andnroid系统odex优化加快开机速度</title>
      <link href="/FuckCode/2018/06/25/Andnroid%E7%B3%BB%E7%BB%9Fodex%E4%BC%98%E5%8C%96%E5%8A%A0%E5%BF%AB%E5%BC%80%E6%9C%BA%E9%80%9F%E5%BA%A6/"/>
      <url>/FuckCode/2018/06/25/Andnroid%E7%B3%BB%E7%BB%9Fodex%E4%BC%98%E5%8C%96%E5%8A%A0%E5%BF%AB%E5%BC%80%E6%9C%BA%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><strong>对于如何提高安卓6.0首次开机启动的时间，其关键就是打开系统的预编译odex优化开关。简而言之，就是将系统的jar包提前在服务器上根据相对应的平台进行预优化，对应的预装应用也从apk的class文件中优化得到odex文件从而加快首次开机PMS便利扫描apk包的时间。</strong></p><a id="more"></a><h3 id="odex-预编译加快开机速度"><a href="#odex-预编译加快开机速度" class="headerlink" title="odex 预编译加快开机速度"></a>odex 预编译加快开机速度</h3><h4 id="各种虚拟机的了解"><a href="#各种虚拟机的了解" class="headerlink" title="各种虚拟机的了解"></a>各种虚拟机的了解</h4><ol><li><p>JVM虚拟机运行的是java字节码：</p><p> java -&gt; java bytecode（class）-&gt; java bytecode（jar）<br> 注！java虚拟机基于栈，基于栈的机器必须使用指令来载入和操作栈上的数据，所需指令相对来说比较多。</p></li><li><p>Dalvik虚拟机解释执行的dex字节码：</p><p> java -&gt; java bytecode（class）-&gt; dalvik bytecode（dex）<br> 注：相对JVM，Dalvik基于寄存器，且经过优化并允许有限的内存中同时运行多个虚拟机实例，每个Dalvik应用作为一个独立的Linxu进程执行。如果一个应用中有很多类，编译后会相应生成很多class文件，class文件之间也会有不少冗余信息，dex格式文件把所有classs文件内容整合到一个文件，这样可以减少整体文件占用，IO操作，同时也提高了类的查找速度。此外，dex格式文件增加了新的操作码支持，文件结构也相对简洁，使用等长的指令来提高解析速度。而且dex文件会尽量扩大只读结构的大小，来提高进程间数据共享的速度。</p></li><li><p>ART虚拟机执行的本地机器码：</p><p> java -&gt; java bytecode（class）-&gt; dalvik bytecode（dex）-&gt; optimized android runtime machine code（oat）<br> 注：ART所使用的AOT（Ahead-Of-Time）编译，在应用首次安装时，字节码预编译成机器码存储在本地，也就是说在程序运行前编译。而Dalvik是典型的JIT（Just_In_Time），此模式下，应用每次运行的时候，字节码都需要即时编译器转换为机器码再执行，也就是在程序运行时编译。因此在App运行时，ART模式相对于Dalvik省去了解释字节码的过程，占用内存也相应减少，进而提高App的运行效率。</p></li></ol><h4 id="Odex相关介绍"><a href="#Odex相关介绍" class="headerlink" title="Odex相关介绍"></a>Odex相关介绍</h4><ol><li><p>apk内容</p><p> 在编译打包APK时，Java类会被编译成一个或者多个字节码文件（.class），通过dx工具CLASS文件转换成一个DEX（Dalvik Executable）文件。通常情况下，我们看到的Android应用程序实际上是一个以.apk为后缀名的压缩文件。我们可以通过压缩工具对apk进行解压，解压出来的内容中有一个名为classes.dex的文件。那么我们首次开机的时候系统需要将其从apk中解压出来保存在data/app目录中。</p></li><li><p>Dalvik虚拟机：</p><p> 如果当前运行在Dalvik虚拟机下，Dalvik会对classes.dex进行一次“翻译”，“翻译”的过程也就是守护进程installd的函数dexopt来对dex字节码进行优化，实际上也就是由dex文件生成odex文件，最终odex文件被保存在手机的VM缓存目录data/dalvik-cache下（注意！这里所生成的odex文件依旧是以dex为后缀名，格式如：system@priv-app@<a href="mailto:Settings@Settings.apk" target="_blank" rel="noopener">Settings@Settings.apk</a>@classes.dex）。</p></li><li><p>Art虚拟机：</p><p> 如果当前运行于Art模式下，Art同样会在首次进入系统的时候调用/system/bin/dexopt工具来将dex字节码翻译成本地机器码<strong>（而非Dalvik虚拟机仅仅优化的字节码，机器码不需要解释器解释便可直接运行）</strong>，保存在data/dalvik-cache下。</p></li><li><p>相关注意</p><p> 从上面虚拟机运行机制可以看出，无论是对dex字节码进行优化，还是将dex字节码翻译成本地机器码，最终得到的结果都是保存在相同名称的一个odex文件里面的。但是前者Dalvik对应的是一个dey文件（表示这是一个优化过的dex），后者Art虚拟机对应的是一个oat文件（实际上是一个自定义的elf文件，里面包含的都是本地机器指令）。简单来说无论是Art模式，还是DVM，优化的结果都是一个odex文件，只是这两种odex文件有着本质的区别（一个是dey字节码，一个是oat机器码）。之所以这么设计，主要通过这种方式，原来任何通过绝对路径引用了该odex文件的代码就都不需要修改了，可以理解为这是art与dalvik兼容的结果。</p></li><li><p>优化缘由</p><p> 由于在系统首次启动时会对应用进行安装，那么在预置APK比较多的情况下，将会大大增加系统首次启动的时间。从前面的描述可知，既然无论是DVM还是ART，对DEX的优化结果都是保存在一个相同名称的odex文件，那么如果我们把这两个过程在ROM编译的时候预处理提取Odex文件将会大大优化系统首次启动的时间。</p></li></ol><h4 id="预编译提取Odex"><a href="#预编译提取Odex" class="headerlink" title="预编译提取Odex"></a>预编译提取Odex</h4><h5 id="几个重要的宏定义"><a href="#几个重要的宏定义" class="headerlink" title="几个重要的宏定义"></a>几个重要的宏定义</h5><p>安卓源码中提供了宏定义开关提前odex优化代码，对应于各个分支的BoardConfig.mk中定义。分别是DISABLE_DEXPREOPT、WITH_DEXPREOPT这两个宏。但这两者还是有点分别的。</p><ol><li><p>DISABLE_DEXPREOPT</p><p> 在user-builds中，默认是开启的，即进行odex优化操作，如果不需要优化可以注释掉或者强制设置为true。</p></li><li><p>WITH_DEXPREOPT</p><p> 在eng/others-build中，默认是关闭的，不进行优化。其他user-builds版本上是默认开启的，意思就是user-builds要开odex预编译。这会导致system image中的所有东西都被提前优化（pre-optimized），导致system image非常大。</p></li><li><p>LOCAL_DEX_PREOPT</p><p> 在App的Android.mk文件里面添加这个宏开关，可以控制这个App时候要预编译。一般预置的第三方App都会把这个宏开关置为false，这样既可以避免提取odex出现异常导致App功能异常，也能节省一定空间消耗。</p></li></ol><h5 id="odex预提取"><a href="#odex预提取" class="headerlink" title="odex预提取"></a>odex预提取</h5><ol><li><p>由于编译时提取Odex会增加一定的空间，预置太多apk，会导致system.img 过大，而编译不过。可以适当增加此分区大小，一般在 BoardConfig.mk 中有配置，直接调整，注意存储空间有限，这里增加必然要相应减少其他分区的大小，以避免编译后刷写系统失败。</p><pre><code>userdata       (1G)BOARD_USERDATAIMAGE_PARTITION_SIZE   := 0x40000000这里的 0x40000000 是十六进制的转换，1G = 1024*1024*1024，之后再转换成16进制的值</code></pre></li><li><p>开启 BoardConfig.mk 中 关键的两个宏开关。DISABLE_DEXPREOPT := true 和 WITH_DEXPREOPT := true。这里建议是打开和关闭注释的方式，以避免默认配置导致自己理解混乱。</p><pre><code>DISABLE_DEXPREOPT := trueWITH_DEXPREOPT := true</code></pre></li><li><p>预编译开关控制的不仅仅是apk，包括/system/framework/目录下面的jar包也会参与预编译优化，如果想控制不参与jar的odex优化，可以在 /buid/core/java_library.mk 文件中设置，这样在编译时，jar包就不会做odex优化。</p><pre><code>LOCAL_DEX_PREOPT := false</code></pre></li><li><p>实际编译中，因为各种未知原因导致编译出错，或者编译成功刷写开机后系统应用莫名crash，这里提供两种方法跳过对应应用，避免其进行预编译优化操作导致系统莫名问题。</p><p> 方法一：</p><pre><code>单独控制。直接在对应源码apk的Android.mk文件中添加如下脚本，确保其不进行odex优化操作。LOCAL_DEX_PREOPT := false</code></pre><p> 方法二：</p><pre><code>全局控制，在目录 \build\core\dex_preopt_odex_install.mk 中对应位置添加过滤脚本代码：# add by allies begin# 添加过滤应用,否则导致odex优化编译不过，应用crash导致系统崩溃# ifeq ($(LOCAL_MODULE),MLeanbackTv)ifneq (,$(filter $(LOCAL_MODULE),MLeanbackTv MTvService))LOCAL_DEX_PREOPT:=endif# add by allies end# 在此处原生代码上面添加built_odex :=installed_odex :=</code></pre><p> MLeanbackTv 可替换为需要跳过提取odex的apk的 <strong>LOCAL_MODULE</strong> 。如果需要过滤多个，可以操考实例中的代码，使用filter过滤，逗号后面直接列出过滤的应用，中间以空格隔断即可。</p></li></ol><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>安卓更新迭代到5.0后，其虚拟机由Dalvik转为Art具有划时代的意义。安卓设备的卡顿的现象出现了明显的转变，这是安卓进步的重要一步。对于系统进行odex与编译优化，虽然极大程度上提高了首次开机的时间，但并非完全有益，主要总结有以下几点：</p><ol><li>odex优化进一步的适应于art虚拟机，首次安装即将字节码转成机器码，进一步提高系统流畅度</li><li>提升流畅度的前提是以牺牲若干系统存储空间的前提下进行的，这是以空间换时间的一种策略</li><li>未知原因预编译优化会导致odex应用会莫名crash，并不能保证完美的兼容性</li><li>预编译优化的系统将不能独立编译模块push更改操作，这对于开发者来说是不利的</li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>以上文章并非自己完全独立写作出来，在这里声明出来。文章本着自己实际工作中总结的经验，在网络上无数优秀的博客中删选，总结出适合自己的、有益的内容，同时其中加上自己的一点思考，这也算是自己不断进步的印证吧！</p><p><a href="https://blog.csdn.net/huangyabin001/article/details/46973625" target="_blank" rel="noopener">参考博客</a></p><p><a href="https://blog.csdn.net/croop520/article/details/73930184" target="_blank" rel="noopener">看考博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码编译 </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析之Launcher启动流程</title>
      <link href="/FuckCode/2018/06/14/%E5%BC%80%E6%9C%BALauncher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/FuckCode/2018/06/14/%E5%BC%80%E6%9C%BALauncher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>之前分析了安卓开机启动流程，详细可以查看Zygote和SystemServer相关的博客。系统开机经由init进程拉起后，调用Zygote孵化器开启SystemServer服务，其中系统核心重要的服务都在SystemServer中加载完成，之后便进入各个服务的SystemReady状态。由此，我们从这里开始分析。</strong></p><a id="more"></a><h3 id="源码分析之Launcher启动流程"><a href="#源码分析之Launcher启动流程" class="headerlink" title="源码分析之Launcher启动流程"></a>源码分析之Launcher启动流程</h3><h4 id="具体流程分析"><a href="#具体流程分析" class="headerlink" title="具体流程分析"></a>具体流程分析</h4><h5 id="AMS进入SystemReady状态"><a href="#AMS进入SystemReady状态" class="headerlink" title="AMS进入SystemReady状态"></a>AMS进入SystemReady状态</h5><p>ActivityManagerService启动完成后，便进入SystemReady状态，代码如下：</p><pre><code>--&gt; /frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic void systemReady(final Runnable goingCallback) {        ...       // Start up initial activity.        mBooting = true;        // 以当前userid，启动主页        startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;);        ...}</code></pre><p>AMS的systemReady中有很多复杂的逻辑，例如广播发送，工厂模式的判定等，这里我们只关心主页的启动。通过startHomeActivityLocked以当前userid启动主页。</p><h5 id="startHomeActivityLocked"><a href="#startHomeActivityLocked" class="headerlink" title="startHomeActivityLocked"></a>startHomeActivityLocked</h5><pre><code>    boolean startHomeActivityLocked(int userId, String reason) {        //工厂模式启动失败        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL                &amp;&amp; mTopAction == null) {            return false;        }        // 获取主页意图        Intent intent = getHomeIntent();        ActivityInfo aInfo =            resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);        if (aInfo != null) {            intent.setComponent(new ComponentName(                    aInfo.applicationInfo.packageName, aInfo.name));            // Don&apos;t do this if the home app is currently being            // instrumented.            aInfo = new ActivityInfo(aInfo);            aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);            ProcessRecord app = getProcessRecordLocked(aInfo.processName,                    aInfo.applicationInfo.uid, true);            if (app == null || app.instrumentationClass == null) {                intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);                // 根据获取的intent，启动主页应用                mStackSupervisor.startHomeActivity(intent, aInfo, reason);            }        }        return true;    }通过给定intent过滤信息，通过调用resolveActivityInfo检索出合适的主页应用，回传回来ActivityInfo，然后初始化新应用的相关信息，调用mStackSupervisor.startHomeActivity启动主页。--&gt; /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java    Intent getHomeIntent() {        Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);        intent.setComponent(mTopComponent);        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {            intent.addCategory(Intent.CATEGORY_HOME);        }        return intent;    }</code></pre><h5 id="resolveActivityInfo筛选合适的应用信息"><a href="#resolveActivityInfo筛选合适的应用信息" class="headerlink" title="resolveActivityInfo筛选合适的应用信息"></a>resolveActivityInfo筛选合适的应用信息</h5><p>resolveActivityInfo中判断系统是否处于工厂模式，如果是，直接根据ComponentName调用PMS的getActivityInfo来获取应用信息；如果不是，则调用PMS的resolveIntent全局筛选合适的主页应用。</p><pre><code>private ActivityInfo resolveActivityInfo(Intent intent, int flags, int userId) {        ActivityInfo ai = null;        ComponentName comp = intent.getComponent();        try {            if (comp != null) {                // 工厂模式                ai = AppGlobals.getPackageManager().getActivityInfo(comp, flags, userId);            } else {                    // 调用PMS全局筛选合适的主页应用                ResolveInfo info = AppGlobals.getPackageManager().resolveIntent(                        intent,                        intent.resolveTypeIfNeeded(mContext.getContentResolver()),                        flags, userId);                if (info != null) {                    ai = info.activityInfo;                }            }        } catch (RemoteException e) {        }        return ai;    }</code></pre><h5 id="PMS筛选主页应用信息"><a href="#PMS筛选主页应用信息" class="headerlink" title="PMS筛选主页应用信息"></a>PMS筛选主页应用信息</h5><pre><code>--&gt;/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.javaAMS通过Binder通信，获取PMS，调用resolveIntent查找出合适Intent的应用信息    public ResolveInfo resolveIntent(Intent intent, String resolvedType,                int flags, int userId) {        // userID检测        if (!sUserManager.exists(userId)) return null;        // 权限检测        enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, &quot;resolve intent&quot;);        // 全局包名查询意图匹配的应用信息        List&lt;ResolveInfo&gt; query = queryIntentActivities(intent, resolvedType, flags, userId);        return chooseBestActivity(intent, resolvedType, flags, query, userId);    }</code></pre><p>resolveIntent中主要实现的逻辑如下：</p><ol><li>检测UserManager是否存在当前的用户id</li><li>检测调用方法者是否拥有相应的权限</li><li>通过queryIntentActivities全局查找出合适的应用信息</li><li>通过chooseBestActivity进一步筛选出最合适的应用</li></ol><h5 id="queryIntentActivities全局查询合适intent"><a href="#queryIntentActivities全局查询合适intent" class="headerlink" title="queryIntentActivities全局查询合适intent"></a>queryIntentActivities全局查询合适intent</h5><p>queryIntentActivities会根据传入的intent来选择查找方式，一种是没有包名，再系统所有的包中查找，否则查找安装包中指定的包。</p><pre><code>public List&lt;ResolveInfo&gt; queryIntentActivities(Intent intent,        String resolvedType, int flags, int userId) {    if (!sUserManager.exists(userId)) return Collections.emptyList();    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, &quot;query intent activities&quot;);    ComponentName comp = intent.getComponent();    if (comp == null) {        if (intent.getSelector() != null) {            intent = intent.getSelector();            comp = intent.getComponent();        }    }    if (comp != null) {        final List&lt;ResolveInfo&gt; list = new ArrayList&lt;ResolveInfo&gt;(1);        final ActivityInfo ai = getActivityInfo(comp, flags, userId);        if (ai != null) {            final ResolveInfo ri = new ResolveInfo();            ri.activityInfo = ai;            list.add(ri);        }        return list;    }    // reader    synchronized (mPackages) {        final String pkgName = intent.getPackage();        // 包名信息为空，全局查找        if (pkgName == null) {            List&lt;CrossProfileIntentFilter&gt; matchingFilters =                    getMatchingCrossProfileIntentFilters(intent, resolvedType, userId);            // Check for results that need to skip the current profile.            ResolveInfo xpResolveInfo  = querySkipCurrentProfileIntents(matchingFilters, intent,                    resolvedType, flags, userId);            if (xpResolveInfo != null &amp;&amp; isUserEnabled(xpResolveInfo.targetUserId)) {                List&lt;ResolveInfo&gt; result = new ArrayList&lt;ResolveInfo&gt;(1);                result.add(xpResolveInfo);                return filterIfNotPrimaryUser(result, userId);            }            // Check for results in the current profile.            List&lt;ResolveInfo&gt; result = mActivities.queryIntent(                    intent, resolvedType, flags, userId);            // Check for cross profile results.            xpResolveInfo = queryCrossProfileIntents(                    matchingFilters, intent, resolvedType, flags, userId);            if (xpResolveInfo != null &amp;&amp; isUserEnabled(xpResolveInfo.targetUserId)) {                result.add(xpResolveInfo);                // 排序                Collections.sort(result, mResolvePrioritySorter);            }            result = filterIfNotPrimaryUser(result, userId);            if (hasWebURI(intent)) {                CrossProfileDomainInfo xpDomainInfo = null;                final UserInfo parent = getProfileParent(userId);                if (parent != null) {                    xpDomainInfo = getCrossProfileDomainPreferredLpr(intent, resolvedType,                            flags, userId, parent.id);                }                if (xpDomainInfo != null) {                    if (xpResolveInfo != null) {                        // If we didn&apos;t remove it, the cross-profile ResolveInfo would be twice                        // in the result.                        result.remove(xpResolveInfo);                    }                    if (result.size() == 0) {                        result.add(xpDomainInfo.resolveInfo);                        return result;                    }                } else if (result.size() &lt;= 1) {                    return result;                }                result = filterCandidatesWithDomainPreferredActivitiesLPr(intent, flags, result,                        xpDomainInfo, userId);                Collections.sort(result, mResolvePrioritySorter);            }            return result;        }        // 根据包名查找        final PackageParser.Package pkg = mPackages.get(pkgName);        if (pkg != null) {            return filterIfNotPrimaryUser(                    mActivities.queryIntentForPackage(                            intent, resolvedType, flags, pkg.activities, userId),                    userId);        }        return new ArrayList&lt;ResolveInfo&gt;();    }}</code></pre><h5 id="chooseBestActivity筛选最合适的应用"><a href="#chooseBestActivity筛选最合适的应用" class="headerlink" title="chooseBestActivity筛选最合适的应用"></a>chooseBestActivity筛选最合适的应用</h5><p>对于前面传来的List<resolveinfo>集合，需要从中筛选出最合适的应用。</resolveinfo></p><pre><code>private ResolveInfo chooseBestActivity(Intent intent, String resolvedType,        int flags, List&lt;ResolveInfo&gt; query, int userId) {    if (query != null) {        final int N = query.size();        if (N == 1) {                // 只有一条，直接返回            return query.get(0);        } else if (N &gt; 1) {            final boolean debug = ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);            // If there is more than one activity with the same priority,            // then let the user decide between them.            ResolveInfo r0 = query.get(0);            ResolveInfo r1 = query.get(1);            if (DEBUG_INTENT_MATCHING || debug) {                Slog.v(TAG, r0.activityInfo.name + &quot;=&quot; + r0.priority + &quot; vs &quot;                        + r1.activityInfo.name + &quot;=&quot; + r1.priority);            }            // If the first activity has a higher priority, or a different            // default, then it is always desireable to pick it.            // 取前两条，选择优先级高的            if (r0.priority != r1.priority                    || r0.preferredOrder != r1.preferredOrder                    || r0.isDefault != r1.isDefault) {                return query.get(0);            }            // 已经设置过合适的主页应用，返回它            ResolveInfo ri = findPreferredActivity(intent, resolvedType,                    flags, query, r0.priority, true, false, debug, userId);            if (ri != null) {                return ri;            }            ri = new ResolveInfo(mResolveInfo);            ri.activityInfo = new ActivityInfo(ri.activityInfo);            ri.activityInfo.applicationInfo = new ApplicationInfo(                    ri.activityInfo.applicationInfo);            if (userId != 0) {                ri.activityInfo.applicationInfo.uid = UserHandle.getUid(userId,                        UserHandle.getAppId(ri.activityInfo.applicationInfo.uid));            }            // Make sure that the resolver is displayable in car mode            if (ri.activityInfo.metaData == null) ri.activityInfo.metaData = new Bundle();            ri.activityInfo.metaData.putBoolean(Intent.METADATA_DOCK_HOME, true);            return ri;        }    }    return null;}</code></pre><p>筛选逻辑总结如下：</p><ol><li>只存在一条信息，直接返回</li><li>存在两条以上，获取前两条，比较优先级高的返回</li><li>如果一样，查看之前用户是否设置过合适的主页，返回它</li></ol><p>到此，超找到合适的主页应用信息，直接调用之前的mStackSupervisor.startHomeActivity便可以启动主页应用</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>了解了主页应用的启动流程，可以方便我们入手定制系统信息的Launcher，一般实现用户自定的主页可以有以下几个实现方式：</p><ol><li>修改应用层在Manifest.xml文件，设置优先级属性等，例如priority默认值为0，设置的值越大优先级越高</li><li>framework可以仿照源码中工厂模式，在工厂模式检测前返回自己的主页应用</li><li>在chooseBestActivity代码的筛选中添加合适代码直接放回自己的主页应用</li></ol><hr><h4 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h4><p>在主页的启动流程中涉及到了安卓新手引导页的相关知识，具体可以参考一下博文</p><pre><code>[请戳这里](https://github.com/Huoxubeiyin/SourceCode/blob/master/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8B%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC.md)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Launcher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析之智能指针RefBase</title>
      <link href="/FuckCode/2018/06/13/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88RefBase/"/>
      <url>/FuckCode/2018/06/13/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88RefBase/</url>
      
        <content type="html"><![CDATA[<p><strong>智能指针，是安卓为了照顾Java层代码，为C层适配的一种自动管理内存对象的方案。由于C层对象不能够像Java层代码一样由虚拟机自动释放，很容易造成内存泄漏等问题，其生命周期要求开发者自行管理，为了解决这个问题，安卓系统便引入了智能指针的概念。在我们了解它之后，对于源码的阅读，无疑将会变得更加轻松！</strong></p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>智能指针能够通过引用计数来维护对象的生命周期</li><li>智能指针是一个对象，而不是一个指针</li><li>智能指针构造时，增加它引用对象的引用计数，析构时，减少引用对象的引用计数</li><li>对象的生命周期只受强引用计数控制，不受弱引用计数控制</li><li>“父” 对象通过强引用计数引用 “子” 对象，“子” 对象通过弱引用计数引用 “父” 对象</li><li>轻量级指针，强指针，弱指针</li></ul><h1 id="LightRefBase"><a href="#LightRefBase" class="headerlink" title="LightRefBase"></a>LightRefBase</h1><h2 id="LightRefBase轻量级指针"><a href="#LightRefBase轻量级指针" class="headerlink" title="LightRefBase轻量级指针"></a>LightRefBase轻量级指针</h2><h3 id="RefBase"><a href="#RefBase" class="headerlink" title="RefBase"></a>RefBase</h3><p>如果一个类支持使用轻量级指针，那么就必须继承LightRefBase，其源码如下</p><p>–&gt; /system/core/include/utils/RefBase.h</p><pre><code>template &lt;class T&gt;class LightRefBase{public:    // 引用计数值，初始化值0    inline LightRefBase() : mCount(0) { }    // 增加引用计数    inline void incStrong(__attribute__((unused)) const void* id) const {        android_atomic_inc(&amp;mCount);    }    // 减少引用计数    inline void decStrong(__attribute__((unused)) const void* id) const {        // 根据减少引用计数之前的值，判断是否释放相应内存        if (android_atomic_dec(&amp;mCount) == 1) {            delete static_cast&lt;const T*&gt;(this);        }    }    //! DEBUGGING ONLY: Get current strong ref count.    inline int32_t getStrongCount() const {        return mCount;    }    typedef LightRefBase&lt;T&gt; basetype;protected:    inline ~LightRefBase() { }private:    friend class ReferenceMover;    inline static void renameRefs(size_t n, const ReferenceRenamer&amp; renamer) { }    inline static void renameRefId(T* ref,            const void* old_id, const void* new_id) { }private:    mutable volatile int32_t mCount;};</code></pre><p>LightRefBase是一个模版类，T代表的是实际的类型，继承LightRefBase</p><ol><li>基类初始化时，内部的mCount为0，用来描述引用计数值</li><li>通过incStrong（）实现引用计数的增加，decStrong（）减少引用计数</li><li>在引用计数为0时，需要删除对象，释放内存</li></ol><h3 id="LightRefBase实现类"><a href="#LightRefBase实现类" class="headerlink" title="LightRefBase实现类"></a>LightRefBase实现类</h3><p>轻量级指针的实现类为StrongPointer，同时也是强指针的实现类。</p><p>–&gt; /system/core/include/utils/StrongPointer.h</p><pre><code>template&lt;typename T&gt;class sp {public:    // m_ptr指向实际引用的对象    inline sp() : m_ptr(0) { }    // 四种构造函数    sp(T* other);    sp(const sp&lt;T&gt;&amp; other);    template&lt;typename U&gt; sp(U* other);    template&lt;typename U&gt; sp(const sp&lt;U&gt;&amp; other);    ~sp();    // 运算操作符重载    sp&amp; operator = (T* other);    sp&amp; operator = (const sp&lt;T&gt;&amp; other);    template&lt;typename U&gt; sp&amp; operator = (const sp&lt;U&gt;&amp; other);    template&lt;typename U&gt; sp&amp; operator = (U* other);    //! Special optimization for use by ProcessState (and nobody else).    void force_set(T* other);    // Reset    void clear();    // Accessors    inline  T&amp;      operator* () const  { return *m_ptr; }    inline  T*      operator-&gt; () const { return m_ptr;  }    inline  T*      get() const         { return m_ptr; }    // Operators    COMPARE(==)    COMPARE(!=)    COMPARE(&gt;)    COMPARE(&lt;)    COMPARE(&lt;=)    COMPARE(&gt;=)private:        //私有成员中生命友元成员，强指针对象sp，和若指针对象wp    template&lt;typename Y&gt; friend class sp;    template&lt;typename Y&gt; friend class wp;    void set_pointer(T* ptr);    T* m_ptr;};</code></pre><p> 构造函数</p><pre><code>// 普通构造函数template&lt;typename T&gt;sp&lt;T&gt;::sp(T* other)        : m_ptr(other) {    if (other)        other-&gt;incStrong(this);}// 拷贝构造函数template&lt;typename T&gt;sp&lt;T&gt;::sp(const sp&lt;T&gt;&amp; other)        : m_ptr(other.m_ptr) {    if (m_ptr)        m_ptr-&gt;incStrong(this);}</code></pre><p>构造函数中，由于m_ptr从父类LightRefBase继承下来，这里调用的是LightRefBase的成员函数incStrong（）方法实现引用计数的增加。</p><h3 id="LightRefBase的析构函数"><a href="#LightRefBase的析构函数" class="headerlink" title="LightRefBase的析构函数"></a>LightRefBase的析构函数</h3><pre><code>// 析构函数template&lt;typename T&gt;sp&lt;T&gt;::~sp() {    if (m_ptr)        m_ptr-&gt;decStrong(this);}</code></pre><p>同样，析构函数中，也是通过m_ptr调用父类的decStrong（）实现引用计数的减少。</p><hr><p><strong><em>强指针和弱指针是配合在一起使用的，通过强引用计数和弱引用计数来维护对象的生命周期。其必须继承RefBase类，RefBase类内部提供了强弱指针计数器</em></strong></p><h1 id="StrongPointer"><a href="#StrongPointer" class="headerlink" title="StrongPointer"></a>StrongPointer</h1><h2 id="强指针sp实现类"><a href="#强指针sp实现类" class="headerlink" title="强指针sp实现类"></a>强指针sp实现类</h2><p>弱指针的实现类和强指针都是一个模版类，具体的定义如下：</p><p>–&gt; system/core/include/utils/StrongPointer.h</p><pre><code>template&lt;typename T&gt;class sp {public:    // 指向实际引用的对象    inline sp() : m_ptr(0) { }    // 4种方式初始化sp对象    sp(T* other);    sp(const sp&lt;T&gt;&amp; other);    template&lt;typename U&gt; sp(U* other);    template&lt;typename U&gt; sp(const sp&lt;U&gt;&amp; other);    ~sp();    sp&amp; operator = (T* other);    sp&amp; operator = (const sp&lt;T&gt;&amp; other);    template&lt;typename U&gt; sp&amp; operator = (const sp&lt;U&gt;&amp; other);    template&lt;typename U&gt; sp&amp; operator = (U* other);    void force_set(T* other);    void clear();    // 强指针运算符重载了*、-&gt;,可以直接操作对象    inline  T&amp;      operator* () const  { return *m_ptr; }    inline  T*      operator-&gt; () const { return m_ptr;  }    inline  T*      get() const         { return m_ptr; }    // Operators    COMPARE(==)    COMPARE(!=)    COMPARE(&gt;)    COMPARE(&lt;)    COMPARE(&lt;=)    COMPARE(&gt;=)private:        // 强指针和弱指针sp，wp均是模版类    template&lt;typename Y&gt; friend class sp;    template&lt;typename Y&gt; friend class wp;    void set_pointer(T* ptr);    // 私有成员，指向模版类传入的RefBase子类    T* m_ptr;};</code></pre><h3 id="sp的初始化"><a href="#sp的初始化" class="headerlink" title="sp的初始化"></a>sp的初始化</h3><p>sp强引用，内部提供四种初始化方式，方式1，2:调用目标对象的incStrong()方法；方式3，4:则调用目标对象的incStrong()方法，再调用旧对象decStrong()方法</p><pre><code>// 方式1，普通构造函数template&lt;typename T&gt;sp&lt;T&gt;::sp(T* other)        : m_ptr(other) {    if (other)        other-&gt;incStrong(this);}// 方式2，拷贝构造函数template&lt;typename T&gt;sp&lt;T&gt;::sp(const sp&lt;T&gt;&amp; other)        : m_ptr(other.m_ptr) {    if (m_ptr)        m_ptr-&gt;incStrong(this);}// 方式3template&lt;typename T&gt; template&lt;typename U&gt;sp&lt;T&gt;::sp(U* other)        : m_ptr(other) {    if (other)        ((T*) other)-&gt;incStrong(this);}// 方式4template&lt;typename T&gt; template&lt;typename U&gt;sp&lt;T&gt;::sp(const sp&lt;U&gt;&amp; other)        : m_ptr(other.m_ptr) {    if (m_ptr)        m_ptr-&gt;incStrong(this);}</code></pre><p>具体实现见下面的分析。</p><h3 id="弱指针wp实现"><a href="#弱指针wp实现" class="headerlink" title="弱指针wp实现"></a>弱指针wp实现</h3><p>弱指针实现相比强指针实现要复杂，强弱指针都是配合使用。</p><p>–&gt; /system/core/include/utils/RefBase.h</p><pre><code>template &lt;typename T&gt;class wp{public:    typedef typename RefBase::weakref_type weakref_type;    // 构造函数    inline wp() : m_ptr(0) { }    // 提供6中初始化方式    wp(T* other);    wp(const wp&lt;T&gt;&amp; other);    wp(const sp&lt;T&gt;&amp; other);    template&lt;typename U&gt; wp(U* other);    template&lt;typename U&gt; wp(const sp&lt;U&gt;&amp; other);    template&lt;typename U&gt; wp(const wp&lt;U&gt;&amp; other);    ~wp();    // Assignment    wp&amp; operator = (T* other);    wp&amp; operator = (const wp&lt;T&gt;&amp; other);    wp&amp; operator = (const sp&lt;T&gt;&amp; other);    template&lt;typename U&gt; wp&amp; operator = (U* other);    template&lt;typename U&gt; wp&amp; operator = (const wp&lt;U&gt;&amp; other);    template&lt;typename U&gt; wp&amp; operator = (const sp&lt;U&gt;&amp; other);    void set_object_and_refs(T* other, weakref_type* refs);    // 升级弱指针至强指针    sp&lt;T&gt; promote() const;    // 重置    void clear();    // Accessors    inline  weakref_type* get_refs() const { return m_refs; }    inline  T* unsafe_get() const { return m_ptr; }    // Operators    COMPARE_WEAK(==)    COMPARE_WEAK(!=)    COMPARE_WEAK(&gt;)    COMPARE_WEAK(&lt;)    COMPARE_WEAK(&lt;=)    COMPARE_WEAK(&gt;=)    // 运算符重载    inline bool operator == (const wp&lt;T&gt;&amp; o) const {        return (m_ptr == o.m_ptr) &amp;&amp; (m_refs == o.m_refs);    }    template&lt;typename U&gt;    inline bool operator == (const wp&lt;U&gt;&amp; o) const {        return m_ptr == o.m_ptr;    }    ...private:    template&lt;typename Y&gt; friend class sp;    template&lt;typename Y&gt; friend class wp;    T*              m_ptr;// 指向引用对象    weakref_type*   m_refs;// 维护对象的弱引用计数器};</code></pre><h3 id="具体的6种初始化方式"><a href="#具体的6种初始化方式" class="headerlink" title="具体的6种初始化方式"></a>具体的6种初始化方式</h3><pre><code>template&lt;typename T&gt;wp&lt;T&gt;::wp(T* other)    : m_ptr(other){    if (other) m_refs = other-&gt;createWeak(this);}template&lt;typename T&gt;wp&lt;T&gt;::wp(const wp&lt;T&gt;&amp; other)    : m_ptr(other.m_ptr), m_refs(other.m_refs){    if (m_ptr) m_refs-&gt;incWeak(this);}template&lt;typename T&gt;wp&lt;T&gt;::wp(const sp&lt;T&gt;&amp; other)    : m_ptr(other.m_ptr){    if (m_ptr) {        m_refs = m_ptr-&gt;createWeak(this);    }}template&lt;typename T&gt; template&lt;typename U&gt;wp&lt;T&gt;::wp(U* other)    : m_ptr(other){    if (other) m_refs = other-&gt;createWeak(this);}template&lt;typename T&gt; template&lt;typename U&gt;wp&lt;T&gt;::wp(const wp&lt;U&gt;&amp; other)    : m_ptr(other.m_ptr){    if (m_ptr) {        m_refs = other.m_refs;        m_refs-&gt;incWeak(this);    }}template&lt;typename T&gt; template&lt;typename U&gt;wp&lt;T&gt;::wp(const sp&lt;U&gt;&amp; other)    : m_ptr(other.m_ptr){    if (m_ptr) {        m_refs = m_ptr-&gt;createWeak(this);    }}</code></pre><p>无论哪种方式，最终走到incWeak，增加实际引用对象的弱引用计数</p><pre><code>void RefBase::weakref_type::incWeak(const void* id){    // 转为实现类weakref_impl来创建弱引用    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);    impl-&gt;addWeakRef(id);    const int32_t c __unused = android_atomic_inc(&amp;impl-&gt;mWeak);    ALOG_ASSERT(c &gt;= 0, &quot;incWeak called on %p after last weak ref&quot;, this);}</code></pre><p>具体实现如下：</p><pre><code>void addWeakRef(const void* id) {    addRef(&amp;mWeakRefs, id, mWeak);}void addRef(ref_entry** refs, const void* id, int32_t mRef){    if (mTrackEnabled) {        AutoMutex _l(mMutex);        ref_entry* ref = new ref_entry;        ref-&gt;ref = mRef;        ref-&gt;id = id;        ref-&gt;next = *refs;        *refs = ref;    }}</code></pre><p>弱引用和强引用最大的区别是弱引用不能直接操作对象，因为它所引用的可能是不受弱引用计数控制的，即可能是一个无效对象。如果需要操作弱引用对象，必须调用promote方法要将其升级成强引用才能操作，但是不一定能升级成功。</p><h3 id="再看RefBase"><a href="#再看RefBase" class="headerlink" title="再看RefBase"></a>再看RefBase</h3><p>RefBase内部声明了了强弱指针的基本逻辑，具体代码如下：</p><pre><code>class RefBase{public:            // 强引用计数的增减操作            void            incStrong(const void* id) const;            void            decStrong(const void* id) const;            void            forceIncStrong(const void* id) const;            //! DEBUGGING ONLY: Get current strong ref count.            int32_t         getStrongCount() const;    // 内部类，弱引用的相关操作    class weakref_type    {    public:        RefBase*            refBase() const;        void                incWeak(const void* id);        void                decWeak(const void* id);        bool                attemptIncStrong(const void* id);        bool                attemptIncWeak(const void* id);        int32_t             getWeakCount() const;        void                printRefs() const;        void                trackMe(bool enable, bool retain);    };            weakref_type*   createWeak(const void* id) const;            weakref_type*   getWeakRefs() const;    inline  void            printRefs() const { getWeakRefs()-&gt;printRefs(); }    inline  void            trackMe(bool enable, bool retain)    {         getWeakRefs()-&gt;trackMe(enable, retain);     }    typedef RefBase basetype;protected:                            RefBase();    virtual                 ~RefBase();    //! Flags for extendObjectLifetime()    // 生命周期的控制方式    enum {        OBJECT_LIFETIME_STRONG  = 0x0000,        OBJECT_LIFETIME_WEAK    = 0x0001,        OBJECT_LIFETIME_MASK    = 0x0001    };            void            extendObjectLifetime(int32_t mode);    //! Flags for onIncStrongAttempted()    // 强引用计数值的默认值    enum {        FIRST_INC_STRONG = 0x0001    };    // 根据引用的计数值的改变回调相应方法    virtual void            onFirstRef();    virtual void            onLastStrongRef(const void* id);    virtual bool            onIncStrongAttempted(uint32_t flags, const void* id);    virtual void            onLastWeakRef(const void* id);private:    friend class weakref_type;    class weakref_impl;                            RefBase(const RefBase&amp; o);            RefBase&amp;        operator=(const RefBase&amp; o);private:    friend class ReferenceMover;    static void renameRefs(size_t n, const ReferenceRenamer&amp; renamer);    static void renameRefId(weakref_type* ref,            const void* old_id, const void* new_id);    static void renameRefId(RefBase* ref,            const void* old_id, const void* new_id);        // weakref_type的实现类        weakref_impl* const mRefs;};</code></pre><ol><li>RefBase内部可以直接操作强引用计数，实现增加和减少引用</li><li>对于弱引用，则通过内部类 weakref_type 的内部成员refBase，间接调用内部类的方法实现引用计数的增减，后续分析会讲到</li><li>为了方便操作弱引用对象，内部类提供升级弱引用到强引用的方法，但需要结合特定条件，不一定升级成功</li><li>私有成员weakref_impl实现weakref_type方法，后续讲到</li><li>生命周期的控制方式<br> OBJECT_LIFETIME_STRONG  强引用计数控制<br> OBJECT_LIFETIME_WEAK    强弱引用计数控制<br> OBJECT_LIFETIME_FOREVER 完全无视（4.4后弃用）    </li></ol><p>这里引用Gityuan博客内的UML类图来说明一下</p><img src="/FuckCode/2018/06/13/源码分析之智能指针RefBase/RefBase_class.png" title="RefBase_class.png"><h3 id="weakref-imp的实现"><a href="#weakref-imp的实现" class="headerlink" title="weakref_imp的实现"></a>weakref_imp的实现</h3><p>weakref_imp继承于weakref_type，是其具体逻辑的实现类</p><pre><code>class RefBase::weakref_impl : public RefBase::weakref_type{public:    volatile int32_t    mStrong;// 强引用值    volatile int32_t    mWeak;// 弱引用值    RefBase* const      mBase;// 指向父类的RefBase    volatile int32_t    mFlags;// 对象声明周期控制方式    // 通过初始化列表初始化相应的值    weakref_impl(RefBase* base)        : mStrong(INITIAL_STRONG_VALUE)        , mWeak(0)        , mBase(base)        , mFlags(0)        , mStrongRefs(NULL)        , mWeakRefs(NULL)        , mTrackEnabled(!!DEBUG_REFS_ENABLED_BY_DEFAULT)        , mRetain(false)    {    }    // 析构函数实现    ~weakref_impl()    {        bool dumpStack = false;        if (!mRetain &amp;&amp; mStrongRefs != NULL) {            dumpStack = true;            ALOGE(&quot;Strong references remain:&quot;);            ref_entry* refs = mStrongRefs;            while (refs) {                char inc = refs-&gt;ref &gt;= 0 ? &apos;+&apos; : &apos;-&apos;;                ALOGD(&quot;\t%c ID %p (ref %d):&quot;, inc, refs-&gt;id, refs-&gt;ref);                refs = refs-&gt;next;            }        }        if (!mRetain &amp;&amp; mWeakRefs != NULL) {            dumpStack = true;            ALOGE(&quot;Weak references remain!&quot;);            ref_entry* refs = mWeakRefs;            while (refs) {                char inc = refs-&gt;ref &gt;= 0 ? &apos;+&apos; : &apos;-&apos;;                ALOGD(&quot;\t%c ID %p (ref %d):&quot;, inc, refs-&gt;id, refs-&gt;ref);                refs = refs-&gt;next;            }        }        if (dumpStack) {            ALOGE(&quot;above errors at:&quot;);            CallStack stack(LOG_TAG);        }    }    ...};</code></pre><p>weakref_imp实现了weakref_type内部的若干方法，其内部相关变量维持对象引用的相关信息，具体的实现过程见下分析。</p><p>INITIAL_STRONG_VALUE (1&lt;&lt;28)，至于初始值不为0后续会分析得到。</p><h2 id="引用计数的增减逻辑"><a href="#引用计数的增减逻辑" class="headerlink" title="引用计数的增减逻辑"></a>引用计数的增减逻辑</h2><h3 id="强引用计数增加逻辑incStrong"><a href="#强引用计数增加逻辑incStrong" class="headerlink" title="强引用计数增加逻辑incStrong"></a>强引用计数增加逻辑incStrong</h3><pre><code>void RefBase::incStrong(const void* id) const{    weakref_impl* const refs = mRefs;    refs-&gt;incWeak(id);    refs-&gt;addStrongRef(id);    const int32_t c = android_atomic_inc(&amp;refs-&gt;mStrong);    ALOG_ASSERT(c &gt; 0, &quot;incStrong() called on %p after last strong ref&quot;, refs);    if (c != INITIAL_STRONG_VALUE)  {        return;    }    android_atomic_add(-INITIAL_STRONG_VALUE, &amp;refs-&gt;mStrong);    refs-&gt;mBase-&gt;onFirstRef();}</code></pre><p>mRefs为RefBase的成员变量，在RefBase的构造函数中实现</p><pre><code>RefBase::RefBase()    : mRefs(new weakref_impl(this)){}</code></pre><p>mRefs的类型为weakref_impl，incStrong增加强引用计数实际上是调用weakref_impl的具体方法实现的</p><ol><li>增加弱引用计数</li><li>增加强引用计数</li><li>原子层实现mStrong的值增加，返回先前值</li><li>根据返回值c，如果是首次增加即c=INITIAL_STRONG_VALUE，那么回调引用对象mBase（RefBase的引用）的onFirstRef方法，子类可以自己实现一些首次绑定的相关逻辑</li></ol><p>这里可以看出初始化值INITIAL_STRONG_VALUE的作用了，因为需要判断一个状态就是强引用计数有没有被使用过，如果用0的话，那么就不能区分0值代表是没使用过，还是使用过了清零了，所以这里不用0来做初始化值。</p><pre><code>void RefBase::weakref_type::incWeak(const void* id){    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);    impl-&gt;addWeakRef(id);    const int32_t c __unused = android_atomic_inc(&amp;impl-&gt;mWeak);    ALOG_ASSERT(c &gt;= 0, &quot;incWeak called on %p after last weak ref&quot;, this);}</code></pre><p>弱引用计数的增加，同样是通过weakref_impl实现类addWeakRef来实现，在原子层实现。同时，weakref_impl在声明时，即对addWeakRef实现了具体的方法，通过传入mWeakRefs，mWeakRefs是弱引用计数值的引用。</p><pre><code>void addWeakRef(const void* id) {addRef(&amp;mWeakRefs, id, mWeak);}void addRef(ref_entry** refs, const void* id, int32_t mRef){    if (mTrackEnabled) {        AutoMutex _l(mMutex);        ref_entry* ref = new ref_entry;        // Reference count at the time of the snapshot, but before the        // update.  Positive value means we increment, negative--we        // decrement the reference count.        ref-&gt;ref = mRef;        ref-&gt;id = id;        ref-&gt;next = *refs;        *refs = ref;    }}</code></pre><p>addStrongRef也是通过实现类weakref_impl来实现的，这里传入的值为mStrongRefs，实现方法同上面的addRef</p><pre><code>void addStrongRef(const void* id) {    addRef(&amp;mStrongRefs, id, mStrong);}</code></pre><h3 id="减少强引用计数逻辑decStrong"><a href="#减少强引用计数逻辑decStrong" class="headerlink" title="减少强引用计数逻辑decStrong"></a>减少强引用计数逻辑decStrong</h3><pre><code>void RefBase::decStrong(const void* id) const{    weakref_impl* const refs = mRefs;    refs-&gt;removeStrongRef(id);    const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);    if (c == 1) {        refs-&gt;mBase-&gt;onLastStrongRef(id);        // 周期控制方式为强引用控制方式，无引用即删除对象，释放内存        if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {            delete this;        }    }    refs-&gt;decWeak(id);}</code></pre><p>强引用计数的减少，流程如下：</p><ol><li>通过实现类weakref_impl，首先减少强引用计数</li><li>如果强引用计数为0（无引用），回调onLastStrongRef方法，子类可以在删除对象前实现自定的逻辑</li><li>根据对象的生命周期控制方式，删除对象，释放内存</li><li>减少弱引用对象引用计数</li></ol><p>首先减少对应的强引用计数</p><pre><code>void removeStrongRef(const void* id) {    if (!mRetain) {        removeRef(&amp;mStrongRefs, id);    } else {        addRef(&amp;mStrongRefs, id, -mStrong);    }}</code></pre><p> mRetain初始化是默认值false，通过传入的mStrongRefs引用值，实现值的减少。</p><pre><code> void removeRef(ref_entry** refs, const void* id){    if (mTrackEnabled) {        AutoMutex _l(mMutex);        ref_entry* const head = *refs;        ref_entry* ref = head;        while (ref != NULL) {            if (ref-&gt;id == id) {                *refs = ref-&gt;next;                delete ref;                return;            }            refs = &amp;ref-&gt;next;            ref = *refs;        }        ref = head;        while (ref) {            char inc = ref-&gt;ref &gt;= 0 ? &apos;+&apos; : &apos;-&apos;;            ALOGD(&quot;\t%c ID %p (ref %d):&quot;, inc, ref-&gt;id, ref-&gt;ref);            ref = ref-&gt;next;        }        CallStack stack(LOG_TAG);    }}</code></pre><p>再减少弱引用计数</p><pre><code>void RefBase::weakref_type::decWeak(const void* id){    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);    impl-&gt;removeWeakRef(id);    const int32_t c = android_atomic_dec(&amp;impl-&gt;mWeak);    // 回传先前c值，如果c=1,代表此时不存在弱引用对应了，需要具体判断处理    if (c != 1) return;    if ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) {        if (impl-&gt;mStrong == INITIAL_STRONG_VALUE) {            delete impl-&gt;mBase;        } else {            delete impl;        }    } else {        impl-&gt;mBase-&gt;onLastWeakRef(id);        if ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) {            delete impl-&gt;mBase;        }    }}</code></pre><p>根据代码可以看出，如果此时减少弱引用计数，如果不存在引用对象，需要具体操作，否则操作完直接返回。<br>生命周期控制方式为强引用情况下：</p><pre><code>1. 强引用计数值为恢复初始状态，从未被强引用引用过，此时弱引用又为0，可以删除对象了。2. 对象生命周期受强引用计数控制，被强引用过，现在弱引用为0（强引用之前也必定为0），也就是说，对象已经在decStrong中释放掉了，这里需要释放内部的引用计数器实现类weakref_impl</code></pre><p>其次，如果是受其他方式控制，弱引用计数值为0时</p><pre><code>1. 回调RefBase的onLastWeakRef方法，子类实现弱引用删除前的一些自定操作，2. 控制方式为弱引用方式，删除对象</code></pre><h3 id="小结强引用"><a href="#小结强引用" class="headerlink" title="小结强引用"></a>小结强引用</h3><ol><li>如果对象声明周期只受强引用控制，如果强引用计数值为0，系统自动释放这个对象</li><li>如果对象生命周期只受弱引用控制，只有当强引用值和弱引用值都为0时，系统才会释放这个对象</li><li>系统释放对象前，会回调一些方法由子类实现自定逻辑</li></ol><h2 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h2><h3 id="sp析构过程"><a href="#sp析构过程" class="headerlink" title="sp析构过程"></a>sp析构过程</h3><ol><li><p>模版类sp通过RefBase类m_ptr调用decStrong方法</p><pre><code>template&lt;typename T&gt;sp&lt;T&gt;::~sp() {    if (m_ptr)        m_ptr-&gt;decStrong(this);}</code></pre></li><li><p>sp析构过程，调用RefBase的decStrong实现</p><pre><code>void RefBase::decStrong(const void* id) const{    weakref_impl* const refs = mRefs;    refs-&gt;removeStrongRef(id);    const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);    ALOG_ASSERT(c &gt;= 1, &quot;decStrong() called on %p too many times&quot;, refs);    if (c == 1) {        refs-&gt;mBase-&gt;onLastStrongRef(id);        if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {            delete this;        }    }    // 减少弱引用    refs-&gt;decWeak(id);}</code></pre></li></ol><h3 id="wp析构过程"><a href="#wp析构过程" class="headerlink" title="wp析构过程"></a>wp析构过程</h3><ol><li><p>模版类wp</p><pre><code>template&lt;typename T&gt;wp&lt;T&gt;::~wp(){    if (m_ptr) m_refs-&gt;decWeak(this);}</code></pre></li><li><p>弱引用wp的析构过程调用RefBase内部类weakref_type的decWeak实现</p><pre><code>void RefBase::weakref_type::decWeak(const void* id){    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);    impl-&gt;removeWeakRef(id);    const int32_t c = android_atomic_dec(&amp;impl-&gt;mWeak);    ALOG_ASSERT(c &gt;= 1, &quot;decWeak called on %p too many times&quot;, this);    if (c != 1) return;    if ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) {        if (impl-&gt;mStrong == INITIAL_STRONG_VALUE) {            delete impl-&gt;mBase;        } else {            delete impl;        }    } else {        impl-&gt;mBase-&gt;onLastWeakRef(id);        if ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) {            delete impl-&gt;mBase;        }    }}</code></pre></li></ol><h2 id="RefBase析构过程"><a href="#RefBase析构过程" class="headerlink" title="RefBase析构过程"></a>RefBase析构过程</h2><p>RefBase析构过程涉及到其内部引用对象的减少以及释放，其过程涉及到sp和wp的析构过程，具体实现如下：</p><pre><code>RefBase::~RefBase(){    // 释放weakref_impl对象    if (mRefs-&gt;mStrong == INITIAL_STRONG_VALUE) {        delete mRefs;    } else {        // 非STRONG模式下，弱引用计数为0，则释放weakref_impl对象        if ((mRefs-&gt;mFlags &amp; OBJECT_LIFETIME_MASK) != OBJECT_LIFETIME_STRONG) {            if (mRefs-&gt;mWeak == 0) {                delete mRefs;            }        }    }    const_cast&lt;weakref_impl*&amp;&gt;(mRefs) = NULL;}</code></pre><h3 id="decStrong执行强指针sp的析构过程"><a href="#decStrong执行强指针sp的析构过程" class="headerlink" title="decStrong执行强指针sp的析构过程"></a>decStrong执行强指针sp的析构过程</h3><pre><code>void RefBase::decStrong(const void* id) const{    weakref_impl* const refs = mRefs;    refs-&gt;removeStrongRef(id);    const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);    ALOG_ASSERT(c &gt;= 1, &quot;decStrong() called on %p too many times&quot;, refs);    if (c == 1) {        refs-&gt;mBase-&gt;onLastStrongRef(id);        if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {            delete this;        }    }    refs-&gt;decWeak(id);}</code></pre><p>总结decStrong逻辑如下：</p><ol><li>减少对应的强引用计数值</li><li>强引用计数为0，回调onLastStrongRef方法</li><li>无引用且生命周期控制方式为强引用，删除对象操作</li><li>减少弱引用计数值</li></ol><h3 id="decWeak的具体实现"><a href="#decWeak的具体实现" class="headerlink" title="decWeak的具体实现"></a>decWeak的具体实现</h3><p>decWeak执行了弱指针wp的析构过程</p><pre><code>void RefBase::weakref_type::decWeak(const void* id){    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);    impl-&gt;removeWeakRef(id);    const int32_t c = android_atomic_dec(&amp;impl-&gt;mWeak);    ALOG_ASSERT(c &gt;= 1, &quot;decWeak called on %p too many times&quot;, this);    if (c != 1) return;    if ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) {        if (impl-&gt;mStrong == INITIAL_STRONG_VALUE) {            delete impl-&gt;mBase;        } else {            delete impl;        }    } else {        impl-&gt;mBase-&gt;onLastWeakRef(id);        if ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) {            delete impl-&gt;mBase;        }    }}</code></pre><p>总结decWeak逻辑如下：</p><ol><li>减少对应的弱引用计数</li><li>如果弱引用计数为0（相应的强引用计数值肯定为0），根据情况决定操作：<ul><li>强引用控制方式情况下：<ol><li>强引用计数值为初始化的默认值，弱引用计数值为0，释放引用对象</li><li>其他情况，强引用计数值为0，在decStrong释放对象内存，这里弱引用也为0，释放内部的引用计数器weakref_impl对象</li></ol></li><li>其他控制方式<ol><li>回调onLastWeakRef，子类自定实现逻辑</li><li>若果是弱引用控制方式，删除对象引用</li></ol></li></ul></li></ol><p>这样，在RefBase完成析构过程中，就完成了其内部关联的强引用、弱引用对象的减少以及必要的对象的内存释放，当然具体的逻辑需要看对象生命周期的控制方式。</p><h2 id="弱指针升级过程分析"><a href="#弱指针升级过程分析" class="headerlink" title="弱指针升级过程分析"></a>弱指针升级过程分析</h2><p>弱指针如果想要操作引用对象，需要通过promote方法将弱指针升级到强指针，因为涉及到引用对象生命周期控制方式以及对象的存在与否，逻辑相对复杂。</p><h3 id="promote升级指针"><a href="#promote升级指针" class="headerlink" title="promote升级指针"></a>promote升级指针</h3><p>promote，弱指针内部声明了promote()方法，其具体实现如下：</p><pre><code>template&lt;typename T&gt;sp&lt;T&gt; wp&lt;T&gt;::promote() const{    sp&lt;T&gt; result;    if (m_ptr &amp;&amp; m_refs-&gt;attemptIncStrong(&amp;result)) {        result.set_pointer(m_ptr);    }    return result;}</code></pre><p>m_ptr指向引用对象的地址，只有m_ptr不为NULL，执行m_refs-&gt;attemptIncStrong(&amp;result)方法</p><h3 id="attemptIncStrong-尝试增减引用计数"><a href="#attemptIncStrong-尝试增减引用计数" class="headerlink" title="attemptIncStrong 尝试增减引用计数"></a>attemptIncStrong 尝试增减引用计数</h3><pre><code>bool RefBase::weakref_type::attemptIncStrong(const void* id){    // 首先增加对应的弱引用计数    incWeak(id);    // 转为weakref_impl获取强引用计数值    weakref_impl* const impl = static_cast&lt;weakref_impl*&gt;(this);    int32_t curCount = impl-&gt;mStrong;    ALOG_ASSERT(curCount &gt;= 0,            &quot;attemptIncStrong called on %p after underflow&quot;, this);    // 强引用计数大于0，且初始化过（不是默认值），对象肯定存在    while (curCount &gt; 0 &amp;&amp; curCount != INITIAL_STRONG_VALUE) {        // 此弱引用对象存在强引用，可以升级，成功返回0        if (android_atomic_cmpxchg(curCount, curCount+1, &amp;impl-&gt;mStrong) == 0) {            break;        }        curCount = impl-&gt;mStrong;    }    // 弱引用对象的强引用计数值小于等于0（存在）或者初始化值为默认值（不存在）    if (curCount &lt;= 0 || curCount == INITIAL_STRONG_VALUE) {        // 生命周期受强引用计数控制        if ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) {            // 引用对象的强引用计数值小于等0，不存在了            if (curCount &lt;= 0) {                // 减少之前增加的弱引用计数值，升级失败                decWeak(id);                return false;            }            // 这种条件下，引用对象计数值为默认值，又因为只受强引用控制，肯定存在可以升级            while (curCount &gt; 0) {                // 因为原子性操作问题，循环操作升级逻辑                if (android_atomic_cmpxchg(curCount, curCount + 1,                        &amp;impl-&gt;mStrong) == 0) {                    break;                }                curCount = impl-&gt;mStrong;            }            // 升级后引用值还是小于等于0，升级失败，执行减少之前弱引用计数值操作            if (curCount &lt;= 0) {            decWeak(id);                return false;            }        } else {            // 判断对象是否允许强指针引用它            if (!impl-&gt;mBase-&gt;onIncStrongAttempted(FIRST_INC_STRONG, id)) {                // 不允许，减少之前的弱引用计数，升级失败                decWeak(id);                return false;            }            // 权限通过，执行升级操作            curCount = android_atomic_inc(&amp;impl-&gt;mStrong);        }        // 已经被强指针引用了，还要升级！此时onLastStrongRef持有了无用的引用，这里调用并释放它。注意确保这不是第一次引用的情况        if (curCount &gt; 0 &amp;&amp; curCount &lt; INITIAL_STRONG_VALUE) {            impl-&gt;mBase-&gt;onLastStrongRef(id);        }    }    impl-&gt;addStrongRef(id);    curCount = impl-&gt;mStrong;    // 由于初始化的强引用计数值不是0，这里需要矫正强引用计数值    while (curCount &gt;= INITIAL_STRONG_VALUE) {        ALOG_ASSERT(curCount &gt; INITIAL_STRONG_VALUE,                &quot;attemptIncStrong in %p underflowed to INITIAL_STRONG_VALUE&quot;,                this);        if (android_atomic_cmpxchg(curCount, curCount-INITIAL_STRONG_VALUE,                &amp;impl-&gt;mStrong) == 0) {            break;        }        curCount = impl-&gt;mStrong;    }    // 升级成功    return true;}</code></pre><p>这里的逻辑在代码中已经有相关的注释，总结一下弱指针升级强指针的流程：</p><ol><li>强指针引用的增加必然导致弱引用的增加，因此首先增加弱引用计数值</li><li>获取引用对象的强引用计数值</li><li>强引用计数值大于0且初始化过，对象一定存在，直接升级，并增加强引用计数值</li><li>升级失败，减少之前弱引用计数值，返回升级失败</li><li>其他条件下：<ol><li>对象受强引用控制，且强引用计数值小于等于0，对象不存在，无法升级，执行<strong><em>升级失败操作，减少开始弱引用计数值，升级失败，直接返回</em></strong></li><li>受强引用控制，且对象强引用计数值为初始值，对象肯定存在，多线程下循环升级保持原子性</li><li>检查步骤2升级是否成功，失败便执行上述升级失败操作<ol start="4"><li>对象不受强引用控制，判断是否允许强指针引用它，不通过，执行实际失败操作；权限通过便执行升级</li></ol></li></ol></li><li>最后，判断如下情况：对象已经被强指针引用了，还要升级！此时onLastStrongRef持有了无用的引用，这里调用并释放它。注意确保不是首次强引用的情况下！</li><li>由于初始化的强引用计数值不是0，这里需要在结尾处矫正强引用计数值</li><li>返回升级结果，升级成功</li></ol><p>到此，弱指针升级到强指针的逻辑就分析完毕了，升级后的强引用对象可以直接操作的，愿意就是强指针内部重载了对应的操作符。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="强弱引用关系"><a href="#强弱引用关系" class="headerlink" title="强弱引用关系"></a>强弱引用关系</h2><ul><li>对象通过extendObjectLifetime()方法设置生命后期的控制方式</li><li>引用对象生命周期无论受强引用还是弱引用控制，弱引用计数始终大于等于强引用</li><li>强引用控制情况下：强引用值的增减都和弱引用值同步，且强引用计数值为0便删除引用对象，与弱引用值无关，弱引用计数此时控制weakref_impl的生命周期</li><li>弱引用控制情况下：弱引用计数值为0才进行对象的删除，同时删除weakref_impl对象</li></ul><h2 id="RefBase的方法回调时机"><a href="#RefBase的方法回调时机" class="headerlink" title="RefBase的方法回调时机"></a>RefBase的方法回调时机</h2><ul><li>首次调用对象incStrong()，回调该对象的onFirstRef().</li><li>调用decStrong()的最后一次，回调该对象的onLastStrongRef()</li><li>调用decWeak()的最后一次，回调对象的onLastWeakRef()</li></ul><h1 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h1><blockquote><p><a href="http://gityuan.com/2015/12/05/android-refbase/" target="_blank" rel="noopener">参考链接</a></p></blockquote><blockquote><p> 参考书籍：Android系统源代码情景分析</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能指针 </tag>
            
            <tag> RefBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootanim压缩包源码分析</title>
      <link href="/FuckCode/2018/06/09/bootanim-zip%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/FuckCode/2018/06/09/bootanim-zip%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="bootanim-zip文件及源码分析"><a href="#bootanim-zip文件及源码分析" class="headerlink" title="bootanim.zip文件及源码分析"></a>bootanim.zip文件及源码分析</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ol><li>bootanim.zip 是安卓开机动画显示的文件</li><li>文件位置在安卓系统目录的 “/oem/media/bootanimation.zip” OR “/system/media/bootanimation.zip”</li></ol><ul><li>三方定制开机动画，根据自己的平台，制作bootanim.zip，放置到指定目录下，安卓系统开机自动会播放文件夹中的动画</li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ul><li><p>bootanim.cpp 文件中采用三种方式播放动画，对于zip包形式的解析代码如下：</p><pre><code>bool BootAnimation::movie(){    String8 desString;    // 读取文件中的 desc.txt 文件    if (!readFile(&quot;desc.txt&quot;, desString)) {        return false;    }    char const* s = desString.string();    // 根据 audio_conf.txt 是否初始化音频    String8 audioConf;    if (readFile(&quot;audio_conf.txt&quot;, audioConf)) {        mAudioPlayer = new AudioPlayer;        if (!mAudioPlayer-&gt;init(audioConf.string())) {            ALOGE(&quot;mAudioPlayer.init failed&quot;);            mAudioPlayer = NULL;        }    }    Animation animation;    // 解析描述文件    for (;;) {        // 读取一行数据        const char* endl = strstr(s, &quot;\n&quot;);        if (endl == NULL) break;        String8 line(s, endl - s);        const char* l = line.string();        int fps, width, height, count, pause;        char path[ANIM_ENTRY_NAME_MAX];        char color[7] = &quot;000000&quot;; // default to black if unspecified        char pathType;        // 数据项3个，分别为 动画宽，高，刷新率fps        if (sscanf(l, &quot;%d %d %d&quot;, &amp;width, &amp;height, &amp;fps) == 3) {            ALOGD(&quot;&gt; w=%d, h=%d, fps=%d&quot;, width, height, fps);            animation.width = width;            animation.height = height;            animation.fps = fps;        }        // 描述项参数大于等于4，分别为：动画类型，动画是否循环，暂停时间，动画路径        else if (sscanf(l, &quot; %c %d %d %s #%6s&quot;, &amp;pathType, &amp;count, &amp;pause, path, color) &gt;= 4) {            ALOGD(&quot;&gt; type=%c, count=%d, pause=%d, path=%s, color=%s&quot;, pathType, count, pause, path, color);            Animation::Part part;            part.playUntilComplete = pathType == &apos;c&apos;;            part.count = count;            part.pause = pause;            part.path = path;            part.audioFile = NULL;            if (!parseColor(color, part.backgroundColor)) {                ALOGE(&quot;&gt; invalid color &apos;#%s&apos;&quot;, color);                part.backgroundColor[0] = 0.0f;                part.backgroundColor[1] = 0.0f;                part.backgroundColor[2] = 0.0f;            }            // 一个part描述一个动画文件夹中的内容            animation.parts.add(part);        }        s = ++endl;    }    // 读取动画个数    const size_t pcount = animation.parts.size();    void *cookie = NULL;    if (!mZip-&gt;startIteration(&amp;cookie)) {        return false;    }    ZipEntryRO entry;    char name[ANIM_ENTRY_NAME_MAX];    while ((entry = mZip-&gt;nextEntry(cookie)) != NULL) {        const int foundEntryName = mZip-&gt;getEntryFileName(entry, name, ANIM_ENTRY_NAME_MAX);        if (foundEntryName &gt; ANIM_ENTRY_NAME_MAX || foundEntryName == -1) {            ALOGE(&quot;Error fetching entry file name&quot;);            continue;        }        const String8 entryName(name);        const String8 path(entryName.getPathDir());        const String8 leaf(entryName.getPathLeaf());        if (leaf.size() &gt; 0) {            for (size_t j=0 ; j&lt;pcount ; j++) {                if (path == animation.parts[j].path) {                    uint16_t method;// MStar Android Patch Begin#ifdef ENABLE_SUPPORT_ETC1_COMPRESS_DATA_IMAGE                    uint32_t uncompLen;                    if (mZip-&gt;getEntryInfo(entry, &amp;method, &amp;uncompLen, 0, 0, 0, 0)) {                        if (method == ZipFileRO::kCompressDeflated) {                            char* buf = new char[uncompLen];                            if (!mZip-&gt;uncompressEntry(entry, buf,uncompLen)) {                                delete [] buf;                        } else {                                Animation::Part&amp; part(animation.parts.editItemAt(j));                                if (leaf == &quot;audio.wav&quot;) {                                    ALOGE(&quot;audio.wav don&apos;t support kCompressDeflated\n&quot;);                                } else {                                    Animation::Frame frame;                                    frame.name = leaf;                                    frame.data = buf;                                    frame.data_length = uncompLen;                                    part.frames.add(frame);                                }                            }                        } else if (method == ZipFileRO::kCompressStored) {#else                    // 仅支持png存储的文件                    if (mZip-&gt;getEntryInfo(entry, &amp;method, NULL, NULL, NULL, NULL, NULL)) {                        if (method == ZipFileRO::kCompressStored) {#endif// MStar Android Patch End                            FileMap* map = mZip-&gt;createEntryFileMap(entry);                            if (map) {                                Animation::Part&amp; part(animation.parts.editItemAt(j));                                if (leaf == &quot;audio.wav&quot;) {                                    // a part may have at most one audio file                                    part.audioFile = map;                                } else {                                    Animation::Frame frame;                                    frame.name = leaf;// MStar Android Patch Begin#ifdef ENABLE_SUPPORT_ETC1_COMPRESS_DATA_IMAGE                                    frame.data = map-&gt;getDataPtr();                                    frame.data_length = map-&gt;getDataLength();#endif// MStar Android Patch End                                    frame.map = map;                                    part.frames.add(frame);                                }                            }                        }                    }                }            }        }    }    mZip-&gt;endIteration(cookie);    // 清除屏幕    glShadeModel(GL_FLAT);    glDisable(GL_DITHER);    glDisable(GL_SCISSOR_TEST);    glDisable(GL_BLEND);    // MStar Android Patch Begin    // avoid one black frame which maybe last hundreds of milliseconds    glClearColor(0,0,0,0);    // MStar Android Patch End    glClear(GL_COLOR_BUFFER_BIT);    eglSwapBuffers(mDisplay, mSurface);    // MStar Android Patch Begin    // Restore the clearcolor to black    glClearColor(0,0,0,1);    // MStar Android Patch End    glBindTexture(GL_TEXTURE_2D, 0);    glEnable(GL_TEXTURE_2D);    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    const int xc = (mWidth - animation.width) / 2;    const int yc = ((mHeight - animation.height) / 2);    nsecs_t frameDuration = s2ns(1) / animation.fps;    Region clearReg(Rect(mWidth, mHeight));    clearReg.subtractSelf(Rect(xc, yc, xc+animation.width, yc+animation.height));    for (size_t i=0 ; i&lt;pcount ; i++) {        const Animation::Part&amp; part(animation.parts[i]);        const size_t fcount = part.frames.size();        glBindTexture(GL_TEXTURE_2D, 0);        // 循环显示文件夹下的图片        for (int r=0 ; !part.count || r&lt;part.count ; r++) {            // Exit any non playuntil complete parts immediately            if(exitPending() &amp;&amp; !part.playUntilComplete)                break;            // only play audio file the first time we animate the part            if (r == 0 &amp;&amp; mAudioPlayer != NULL &amp;&amp; part.audioFile) {                mAudioPlayer-&gt;playFile(part.audioFile);            }            glClearColor(                    part.backgroundColor[0],                    part.backgroundColor[1],                    part.backgroundColor[2],                    1.0f);            for (size_t j=0 ; j&lt;fcount &amp;&amp; (!exitPending() || part.playUntilComplete) ; j++) {                const Animation::Frame&amp; frame(part.frames[j]);                nsecs_t lastFrame = systemTime();                if (r &gt; 0) {                    glBindTexture(GL_TEXTURE_2D, frame.tid);                } else {                    if (part.count != 1) {                        glGenTextures(1, &amp;frame.tid);                        glBindTexture(GL_TEXTURE_2D, frame.tid);                        glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);                        glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);                    }                    initTexture(frame);                }                if (!clearReg.isEmpty()) {                    Region::const_iterator head(clearReg.begin());                    Region::const_iterator tail(clearReg.end());                    glEnable(GL_SCISSOR_TEST);                    while (head != tail) {                        const Rect&amp; r2(*head++);                        glScissor(r2.left, mHeight - r2.bottom,                                r2.width(), r2.height());                        glClear(GL_COLOR_BUFFER_BIT);                    }                    glDisable(GL_SCISSOR_TEST);                }                // specify the y center as ceiling((mHeight - animation.height) / 2)                // which is equivalent to mHeight - (yc + animation.height)                glDrawTexiOES(xc, mHeight - (yc + animation.height),                              0, animation.width, animation.height);                eglSwapBuffers(mDisplay, mSurface);                nsecs_t now = systemTime();                nsecs_t delay = frameDuration - (now - lastFrame);                //ALOGD(&quot;%lld, %lld&quot;, ns2ms(now - lastFrame), ns2ms(delay));                lastFrame = now;                if (delay &gt; 0) {                    struct timespec spec;                    spec.tv_sec  = (now + delay) / 1000000000;                    spec.tv_nsec = (now + delay) % 1000000000;                    int err;                    do {                        err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;spec, NULL);                    } while (err&lt;0 &amp;&amp; errno == EINTR);                }                checkExit();            }// MStar Android Patch Begin#ifdef ENABLE_STR            char property[PROPERTY_VALUE_MAX] = {0};            property_get(&quot;mstar.str.suspending&quot;, property, &quot;0&quot;);            int strResume = atoi(property);            if (strResume) {                for (int n=0; n&lt;64; n++) {                    checkExit();                    if (exitPending()) {                        ALOGD(&quot;STR bootanimation should exit strResume=%d, n=%d&quot;, strResume, n);                        break;                    } else {                        usleep((part.pause * ns2us(frameDuration))&gt;&gt;6);                    }                }                if (exitPending())                    break;            } else {                usleep(part.pause * ns2us(frameDuration));                // For infinite parts, we&apos;ve now played them at least once, so perhaps exit                if (exitPending() &amp;&amp; !part.count)                    break;            }#else            usleep(part.pause * ns2us(frameDuration));            // For infinite parts, we&apos;ve now played them at least once, so perhaps exit            if (exitPending() &amp;&amp; !part.count)                break;#endif// MStar Android Patch End        }        // 释放内存        if (part.count != 1) {            for (size_t j=0 ; j&lt;fcount ; j++) {                const Animation::Frame&amp; frame(part.frames[j]);                glDeleteTextures(1, &amp;frame.tid);            }        }    }return false;}</code></pre><p>  代码内容由于是定制的Mstar的电视平台，增加了电视平台上自己定制的播放视屏的代码以及STC功能，但是重要的解析代码还是可以一览无余的。<br>  文件解析工作主要由以下几个方面：</p><ol><li>获取zip文件的 desc.txt 准备解析</li><li>根据是否存在 audio_conf.txt 初始化音频操作</li><li>以行数据为单位，三项数据，分别对应： 宽，高，fps</li><li>四项数据及以上，分别对应：  动画类型，循环方式，暂停时间，动画路径</li><li>以 part 为单位，统一保存zip文件夹中的动画内容</li><li>根据 part 内容，循环播放动画（存在音频，仅首次播放一次）</li><li>监测动画结束，关闭动画</li><li>图片内容仅支持png存储格式</li></ol></li><li><p>zip文件解压后文件结构分析</p><p>  手头上有公司电视平台的bootanim，我们解压来看一下</p><p>  三个文件：</p><pre><code>1. desc.txt 纯文本文档2. 两个文件夹，part1，part2</code></pre><p>  desc.txt 文件内容：</p><pre><code>1920 1080 3p 1 0 part1p 0 0 part2</code></pre><p>  由代码解析分析可以得出：</p><pre><code>宽 1920， 高 1080， fps：3（1s播放3张）p 动画标志符； 1 只播放一次； 0 阶段间隔时间 0； 对应动画资源文件夹为 part1p 动画标志符； 0 循环播放； 0 阶段间隔时间 0； 对应动画资源文件夹 part2阶段间隔时间： 单位是一个帧的持续时间，比如帧数是30，那么帧的持续时间就是1秒/30 = 33.3毫秒。阶段切换间隔时间期间开机动画进程进入休眠，把CPU时间让给初始化系统使用。也就是间隔长启动会快，但会影响动画效果</code></pre></li><li><p>自定义zip包时候，压缩的时候压缩方式要选择存储，意思只是将文件进行打包，不进行实质内容意义上的压缩，否则开机时手机会不认的。</p></li><li><p>对于做好的zip包，拷贝到指定目录下，需要重新提权（一般是644）才能保证动画正常工作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开机动画流程分析</title>
      <link href="/FuckCode/2018/06/08/%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/FuckCode/2018/06/08/%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="Android-bootanim流程分析"><a href="#Android-bootanim流程分析" class="headerlink" title="Android bootanim流程分析"></a>Android bootanim流程分析</h3><h4 id="bootanim启动步骤"><a href="#bootanim启动步骤" class="headerlink" title="bootanim启动步骤"></a>bootanim启动步骤</h4><ol><li>init.rc 文件声明两个重要的服务 bootanim, surfaceflinger</li><li>启动界面依赖于 surface 管理服务，优先启动显示管理服务 surfaceflinger </li><li>surfaceflinger 服务完成后，通过 (“ctl.start”, “bootanim”) 启动 bootanim 开机动画</li><li><p>当 system_server 启动系统 HomeUI 的时候关闭 bootanim</p><p> 其具体流程可以参考下图所示</p> <img src="/FuckCode/2018/06/08/开机动画流程分析/bootanim1.png" title="bootanim1.png"></li></ol><ul><li><p>init.rc 文件相关声明</p><p>  surfaceflinger类属core，随core类服务一同启动，服务重启直接导致Zygote服务的重启</p><pre><code>service surfaceflinger /system/bin/surfaceflinger    class core    user system    group graphics drmrpc system    onrestart restart zygote</code></pre><p>  bootanim类属core，但是disable标志它不随core服务一同启动，用户及用户组均是graphics，而且仅启动一次oneshot</p><pre><code>service bootanim /system/bin/bootanimation    class core    user graphics    group graphics audio    disabled    oneshot</code></pre></li></ul><h4 id="surfaceflinger服务的启动流程"><a href="#surfaceflinger服务的启动流程" class="headerlink" title="surfaceflinger服务的启动流程"></a>surfaceflinger服务的启动流程</h4><ul><li><p>surfaceflinger 的 main 方法</p><p>  –&gt; frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp</p><pre><code>int main(int, char**) {    // 设置线程数量最大4    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);    // 开启线程池    sp&lt;ProcessState&gt; ps(ProcessState::self());    ps-&gt;startThreadPool();    // 实例surfaceflinger    sp&lt;SurfaceFlinger&gt; flinger = new SurfaceFlinger();    setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);    set_sched_policy(0, SP_FOREGROUND);    // 在客户端连接前初始化    flinger-&gt;init();    // 发布surfaceflinger就绪    sp&lt;IServiceManager&gt; sm(defaultServiceManager());    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false);    // 启动    flinger-&gt;run();    return 0;}</code></pre></li><li><p>surfaceflinger 在 init 中启动 bootanim 服务</p><p>  –&gt; frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</p><p>  surfaceflinger 的初始化工作代码众多，这里就不一一列举了，在其init过程中，启动了bootanim服务</p><pre><code>void SurfaceFlinger::init() {    // 初始化 EGL 用于显示    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);    eglInitialize(mEGLDisplay, NULL, NULL);    mHwc = new HWComposer(this,            *static_cast&lt;HWComposer::EventHandler *&gt;(this));    ...    mDrawingState = mCurrentState;    initializeDisplays();    // 启动 boot animation    startBootAnim();   ...}</code></pre></li><li><p>init 中通过 property_set(“ctl.start”, “bootanim”) 启动了 bootanim 服务</p><pre><code>void SurfaceFlinger::startBootAnim() {    // 开启 bootanim 服务    struct timespec t = {0, 0};    clock_gettime(CLOCK_MONOTONIC, &amp;t);    // 置位操作    property_set(&quot;service.bootanim.exit&quot;, &quot;0&quot;);    property_set(&quot;ctl.start&quot;, &quot;bootanim&quot;);}</code></pre></li></ul><h4 id="bootanim-服务的启动流程"><a href="#bootanim-服务的启动流程" class="headerlink" title="bootanim 服务的启动流程"></a>bootanim 服务的启动流程</h4><ul><li><p>总体概述</p><p>  –&gt; frameworks/base/cmds/bootanimation/BootAnimation.cpp</p><p>  bootanim 流程如下图所示:</p>  <img src="/FuckCode/2018/06/08/开机动画流程分析/bootanim2.png" title="bootanim2.png"><p>  bootanim内部有大量的逻辑用于初始化和surfaceflinger通信，其内部依赖于安卓独有的binder通信机制，这里不做过多的说明。关于binder通信机制，需要大量篇幅的介绍说明，个人目前还没有这个能力。下面我们来看点可以看得懂的干货</p></li><li><p>readyToRun 流程</p><pre><code>status_t BootAnimation::readyToRun() {   ...    // 创建 native层surface    sp&lt;SurfaceControl&gt; control = session()-&gt;createSurface(String8(&quot;BootAnimation&quot;),            dinfo.w, dinfo.h, PIXEL_FORMAT_RGBA_8888, 0);</code></pre></li></ul><pre><code>        SurfaceComposerClient::openGlobalTransaction();        SurfaceComposerClient::closeGlobalTransaction();        sp&lt;Surface&gt; s = control-&gt;getSurface();        // 初始化 opengl 和 egl        EGLint w, h;        EGLint numConfigs;        EGLConfig config;        EGLSurface surface;        EGLContext context;        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);        eglInitialize(display, 0, 0);        eglChooseConfig(display, attribs, &amp;config, 1, &amp;numConfigs);        ...        // 设备支持编码选项或者正处于编码进程中，显示编码动画        char decrypt[PROPERTY_VALUE_MAX];        property_get(&quot;vold.decrypt&quot;, decrypt, &quot;&quot;);        bool encryptedAnimation = atoi(decrypt) != 0 || !strcmp(&quot;trigger_restart_min_framework&quot;, decrypt);        ZipFileRO* zipFile = NULL;        if ((encryptedAnimation &amp;&amp;                (access(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE, R_OK) == 0) &amp;&amp;                ((zipFile = ZipFileRO::open(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE)) != NULL)) ||                ((access(OEM_BOOTANIMATION_FILE, R_OK) == 0) &amp;&amp;                ((zipFile = ZipFileRO::open(OEM_BOOTANIMATION_FILE)) != NULL)) ||                ((access(SYSTEM_BOOTANIMATION_FILE, R_OK) == 0) &amp;&amp;                ((zipFile = ZipFileRO::open(SYSTEM_BOOTANIMATION_FILE)) != NULL))) {            mZip = zipFile;        }        // 查看是否存在需要播放的video文件        if ((property_get(&quot;mstar.bootvideo&quot;, decrypt, NULL) &gt; 0) ||            (access(USER_BOOTVIDEO_FILE, F_OK) == 0)) {            mVideo = true;            mZip = NULL;        } else {            mVideo = false;            if(property_get(&quot;mstar.close.bootlogo.gop.frame&quot;, decrypt, NULL) &lt;= 0 ) {                property_set(&quot;mstar.close.bootlogo.gop.frame&quot;, &quot;3&quot;);            }        }           return NO_ERROR;    }这里需要注意mZip文件的获取，其三个文件的文件夹路径如下：    #define OEM_BOOTANIMATION_FILE &quot;/oem/media/bootanimation.zip&quot;    #define SYSTEM_BOOTANIMATION_FILE &quot;/system/media/bootanimation.zip&quot;    #define SYSTEM_ENCRYPTED_BOOTANIMATION_FILE &quot;/system/media/bootanimation-encrypted.zip&quot;    #define USER_BOOTVIDEO_FILE &quot;/data/video/video.ts&quot;通过代码可以看出，文件的获取优先级是bootanimation-encrypted.zip最高，/oem/media/文件夹下的bootanimation.zip次之，最低级的是/system/media/文件夹下的bootanimation.zip。最后在检查指定目录是否存在用于启动播放的video视频。</code></pre><ul><li><p>threadLoop 流程</p><pre><code>bool BootAnimation::threadLoop(){    bool r;    // 等待硬件初始化完成，开启 bootanim 动画    char property[PROPERTY_VALUE_MAX] = {0};    property_get(&quot;mstar.hw.init&quot;, property, &quot;0&quot;);    int hwInit = atoi(property);    memset(property, 0, PROPERTY_VALUE_MAX);    property_get(&quot;mstar.str.suspending&quot;, property, &quot;0&quot;);    int strSuspending = atoi(property);    if (hwInit == 0) {        int exitnow;        property_get(EXIT_PROP_NAME, property, &quot;0&quot;);        exitnow = atoi(property);        if (exitnow) {            r = false;            goto exit;        }        return true;    }    // 存在video，播放它    // 存在bootanim文件，播放它    // 其他情况，显示静态logo    if (mVideo &amp;&amp; (strSuspending == 0)) {        r = video();    } else if (mZip == NULL) {        r = android();    } else {        r = movie();    }exit:    eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);    eglDestroyContext(mDisplay, mContext);    eglDestroySurface(mDisplay, mSurface);    mFlingerSurface.clear();    mFlingerSurfaceControl.clear();    eglTerminate(mDisplay);    IPCThreadState::self()-&gt;stopProcess();    return r;}</code></pre><p>  线程循环等待中的逻辑就更简单了。首先监测系统的硬件是否初始化完成，确保播放动画的相关配置均已ok，然后分别对上面获取的指定文件进行判断，优先播放video视频，其次是自定义的bootanim动画，如果什么都没有，就显示静态logo。</p><p>  对于显示的具体流程这里就不做分析了，后续会对如何定制 bootanim.zip 文件进行集中的分析。这里我们只看一下代码显示logo中如何检测开机完成并关闭动画的逻辑。</p></li><li><p>动画显示关闭流程</p></li></ul><pre><code>    bool BootAnimation::android()    {        // 初始化静态logo图片        initTexture(&amp;mAndroid[0], mAssets, &quot;images/android-logo-mask.png&quot;);        initTexture(&amp;mAndroid[1], mAssets, &quot;images/android-logo-shine.png&quot;);        // 清除屏幕        glShadeModel(GL_FLAT);        glDisable(GL_DITHER);        glDisable(GL_SCISSOR_TEST);           ...        const nsecs_t startTime = systemTime();        do {            nsecs_t now = systemTime();            double time = now - startTime;            float t = 4.0f * float(time / us2ns(16667)) / mAndroid[1].w;            GLint offset = (1 - (t - floorf(t))) * mAndroid[1].w;            GLint x = xc - offset;            ...            // 12fps: don&apos;t animate too fast to preserve CPU            const nsecs_t sleepTime = 83333 - ns2us(systemTime() - now);            if (sleepTime &gt; 0)                usleep(sleepTime);            // 监测动画是否退出            checkExit();        } while (!exitPending());        glDeleteTextures(1, &amp;mAndroid[0].name);        glDeleteTextures(1, &amp;mAndroid[1].name);        return false;    }显示静态logo中，死循环监测动画是否退出。    void BootAnimation::checkExit() {        // Allow surface flinger to gracefully request shutdown        char value[PROPERTY_VALUE_MAX];        property_get(EXIT_PROP_NAME, value, &quot;0&quot;);        int exitnow = atoi(value);        if (exitnow) {            requestExit();            if (mAudioPlayer != NULL) {                mAudioPlayer-&gt;requestExit();            }        }    }    #define EXIT_PROP_NAME &quot;service.bootanim.exit&quot;checkExit中监测 value = &quot;service.bootanim.exit&quot; 的属性值，如果等于1，那么就要退出动画。</code></pre><h4 id="开机动画的关闭"><a href="#开机动画的关闭" class="headerlink" title="开机动画的关闭"></a>开机动画的关闭</h4><ul><li><p>概述</p><p>  当SystemServer将系统中的关键服务启动完成后，会启动桌面启动器Launcher。Launcher启动后，会向ActivityManagerService发送一个Activity组件空闲通知，AMS收到该通知后，就会调用成员函数enableScreenAfterBoot()停止开机动画，以便让屏幕显示桌面。</p></li><li><p>AMS -&gt; enableScreenAfterBoot</p><pre><code>void enableScreenAfterBoot() {    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_ENABLE_SCREEN,            SystemClock.uptimeMillis());    // 通知WMS enableScreenAfterBoot    mWindowManager.enableScreenAfterBoot();    synchronized (this) {        updateEventDispatchingLocked();    }}</code></pre></li><li><p>WMS -&gt; enableScreenAfterBoot</p><pre><code>由AMS间接调用WMS的enableScreenAfterBoot通知开机完成。public void enableScreenAfterBoot() {    synchronized(mWindowMap) {        ...        mSystemBooted = true;        hideBootMessagesLocked();        // If the screen still doesn&apos;t come up after 30 seconds, give        // up and turn it on.        mH.sendEmptyMessageDelayed(H.BOOT_TIMEOUT, 30*1000);    }    mPolicy.systemBooted();    // 系统启动完成，准备显示桌面    performEnableScreen();}</code></pre></li><li><p>准备桌面 -&gt; performEnableScreen</p><pre><code>public void performEnableScreen() {    synchronized(mWindowMap) {        ...        if (!mBootAnimationStopped) {            // Do this one time.            try {                // 通过binder通信机制，向SurfaceFlinger发送消息，停止开机动画                IBinder surfaceFlinger = ServiceManager.getService(&quot;SurfaceFlinger&quot;);                if (surfaceFlinger != null) {                    Parcel data = Parcel.obtain();                    data.writeInterfaceToken(&quot;android.ui.ISurfaceComposer&quot;);                    //消息内容为 IBinder.FIRST_CALL_TRANSACTION                    surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED                            data, null, 0);                    data.recycle();                }            } catch (RemoteException ex) {                Slog.e(TAG, &quot;Boot completed: SurfaceFlinger is dead!&quot;);            }            mBootAnimationStopped = true;        }        ...    }}</code></pre><p>  代码可以看出，通过binder通信机制，获取到远程的surfaceflinger服务，向其发送 IBinder.FIRST_CALL_TRANSACTION 消息，远程服务接收到此消息再做处理。</p></li><li><p>surfaceflinger 接收消息处理</p><p>  根据其传递的接口名”android.ui.ISurfaceComposer”，找到其文件位置，如下</p><p>  –&gt; frameworks/native/include/gui/ISurfaceComposer.h<br>  –&gt; frameworks/native/libs/gui/ISurfaceComposer.cpp</p><p>  其头文件又如下枚举定义值</p><pre><code>class BnSurfaceComposer: public BnInterface&lt;ISurfaceComposer&gt; {    public:        enum {            // Note: BOOT_FINISHED must remain this value, it is called from            // Java by ActivityManagerService.            BOOT_FINISHED = IBinder::FIRST_CALL_TRANSACTION,            CREATE_CONNECTION,            CREATE_GRAPHIC_BUFFER_ALLOC,            CREATE_DISPLAY_EVENT_CONNECTION,            ...            }}</code></pre><p>  这里可以看到BOOT_FINISHED消息的定义，之后我们可以在 ISurfaceComposer.cpp 中找到处理这个消息的逻辑</p></li><li><p>ISurfaceComposer.cpp 处理 BOOT_FINISHED 消息</p><pre><code>status_t BnSurfaceComposer::onTransact(    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags){    switch(code) {        ...        case BOOT_FINISHED: {            CHECK_INTERFACE(ISurfaceComposer, data, reply);            bootFinished();            return NO_ERROR;        }       ...    }}</code></pre><p>  在 ISurfaceComposer.cpp 中的onTransact方法中，集中处理发来的binder消息，这里可以看出在对WMS发来的 BOOT_FINISHED(IBinder::FIRST_CALL_TRANSACTION) 消息，直接回掉bootFinished()方法。</p><pre><code>virtual void bootFinished(){    Parcel data, reply;    data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());    remote()-&gt;transact(BnSurfaceComposer::BOOT_FINISHED, data, &amp;reply);}</code></pre></li><li><p>SurfaceFlinger 回掉 bootFinished</p><p>  SurfaceFlinger 继承 BnSurfaceComposer，BnSurfaceComposer 又继承 BnInterface，BnInterface 时定义好的模版，形参为 ISurfaceComposer。SurfaceFlinger的bootFinished方法如下：</p><pre><code>void SurfaceFlinger::bootFinished(){    const nsecs_t now = systemTime();    const nsecs_t duration = now - mBootTime;    mBootFinished = true;    struct timespec t = {0, 0};    clock_gettime(CLOCK_MONOTONIC, &amp;t);    const String16 name(&quot;window&quot;);    sp&lt;IBinder&gt; window(defaultServiceManager()-&gt;getService(name));    if (window != 0) {        window-&gt;linkToDeath(static_cast&lt;IBinder::DeathRecipient*&gt;(this));    }    // 置位关闭动画属性值    property_set(&quot;service.bootanim.exit&quot;, &quot;1&quot;);}</code></pre><p>  走到这里，serfaceflinger就完成了关闭动画的属性值更改操作，后面就是bootanim程序死循环中不断检测指定属性值实现动画的关闭。</p></li><li><p>bootanim 循环监测实现关闭动画</p><pre><code>void BootAnimation::checkExit() {    // Allow surface flinger to gracefully request shutdown    char value[PROPERTY_VALUE_MAX];    property_get(EXIT_PROP_NAME, value, &quot;0&quot;);    int exitnow = atoi(value);    if (exitnow) {        requestExit();        if (mAudioPlayer != NULL) {            mAudioPlayer-&gt;requestExit();        }    }}</code></pre></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>安卓开机动画的显示和消失，涉及的内容还是挺多的，想要详细了解其内部的实现流程还是有一定难度的。尤其是在binder消息的传递和处理上面，各个部分来回跳转，真的很头疼。对于bootanim.zip的自定义实现，后续会集中根据代码的解析来分析内部文件的具体含义。</p><ul><li><p>引用参考博客中很好的一幅图片来收尾：</p>  <img src="/FuckCode/2018/06/08/开机动画流程分析/bootanim3.png" title="bootanim3.png"></li></ul><blockquote><p><a href="https://blog.csdn.net/hovan/article/details/43198399" target="_blank" rel="noopener">参考博客地址</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
            <tag> bootanim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析之SystemServer流程分析2</title>
      <link href="/FuckCode/2018/06/07/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BSystemServer%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/"/>
      <url>/FuckCode/2018/06/07/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BSystemServer%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902/</url>
      
        <content type="html"><![CDATA[<h3 id="SystemServer启动流程分析2"><a href="#SystemServer启动流程分析2" class="headerlink" title="SystemServer启动流程分析2"></a>SystemServer启动流程分析2</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><p>由 Zygote 启动到 SystemServer 的过程主要如下：在 RuntimeInit.java 中invokeStaticMain方法通过创建并抛出异常 ZygoteInit.MethodAndArgsCaller ，在 ZygoteInit.java 中的 main() 方法会捕捉该异常，并调用 caller.run() ，再通过反射便会调用到 SystemServer.main() 方法，该方法主要执行流程：</p><pre><code>SystemServer.main    SystemServer.run        createSystemContext();        startBootstrapServices();        startCoreServices();        startOtherServices();        Looper.loop();</code></pre></li></ul><h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><ul><li><p>服务的具体启动流程一览图如下：</p>  <img src="/FuckCode/2018/06/07/源码分析之SystemServer流程分析2/system_server3.png" title="system_server3.png"></li><li><p>main</p><p>  –&gt; frameworks/base/services/java/com/android/server/SystemServer.java</p></li></ul><pre><code>    public static void main(String[] args) {        // 先初始化SystemServer对象，在调用器run()方法        new SystemServer().run();    }ZygoteInit 通过反射调用 SystemServer 的 main 方法，执行到此。  </code></pre><ul><li><p>run()</p><pre><code>private void run() {    // 系统时间早于1970，设置系统时间1970    if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) {        Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);    }    // core/jni/AndroidRuntime.cpp    if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) {        final String languageTag = Locale.getDefault().toLanguageTag();        SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag);        SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;);        SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;);        SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;);    }    // 变更虚拟机的库文件，对于Android6.0默认采用libart.so    SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary());    // 启用性能统计    if (SamplingProfilerIntegration.isEnabled()) {        SamplingProfilerIntegration.start();        mProfilerSnapshotTimer = new Timer();        mProfilerSnapshotTimer.schedule(new TimerTask() {            @Override            public void run() {                SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;, null);            }        }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);    }    // 清除vm内存增长上限，由于启动过程需要更多的虚拟机内存空间    VMRuntime.getRuntime().clearGrowthLimit();    // The system server has to run all of the time, so it needs to be    // 设置内存可能有效使用率0.8    VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);    // 针对部分设备依赖运行时就产生指纹信息，因此需要在开机完成前已经定义    Build.ensureFingerprintProperty();    // 访问环境变量前，需要明确的指定用户    Environment.setUserRequired(true);    // 确保当前系统进程的binder调用，总是在运行在前台优先级    BinderInternal.disableBackgroundScheduling(true);    android.os.Process.setThreadPriority(            android.os.Process.THREAD_PRIORITY_FOREGROUND);    android.os.Process.setCanSelfBackground(false);    // 主线程looper就在当前线程运行    Looper.prepareMainLooper();    // 加载Android.servers.so库    System.loadLibrary(&quot;android_servers&quot;);    // 检测上次关机过程是否失败    performPendingShutdown();    // 初始化系统上下文    createSystemContext();    // 创建系统服务管理通过反射开启相应类的服务    mSystemServiceManager = new SystemServiceManager(mSystemContext);    // 将mSystemServiceManager添加到本地服务的成员sLocalServiceObjects    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);    // Start services.    try {        // 启动引导服务        startBootstrapServices();        // 启动核心服务        startCoreServices();        // 启动其他服务        startOtherServices();    } catch (Throwable ex) {        Slog.e(&quot;System&quot;, &quot;******************************************&quot;);        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);        throw ex;    }    // 用于debug版本，将log事件不断循环地输出到dropbox（用于分析）    if (StrictMode.conditionallyEnableDebugLogging()) {        Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;);    }    // 一直循环执行    Looper.loop();    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);}</code></pre><p>  通过代码我们发现其主要方法如下：</p><ol><li>监测异常关机     performPendingShutdown()</li><li>创建系统上下文    createSystemContext()</li><li>启动引导服务        startBootstrapServices()</li><li>启动核心服务        startCoreServices()</li><li>启动其他服务        startOtherServices()</li><li>消息循环，等待处理        Looper.loop()</li></ol></li><li><p>异常关机监测处理</p><pre><code>private void performPendingShutdown() {    final String shutdownAction = SystemProperties.get(            ShutdownThread.SHUTDOWN_ACTION_PROPERTY, &quot;&quot;);    if (shutdownAction != null &amp;&amp; shutdownAction.length() &gt; 0) {        boolean reboot = (shutdownAction.charAt(0) == &apos;1&apos;);        final String reason;        if (shutdownAction.length() &gt; 1) {            reason = shutdownAction.substring(1, shutdownAction.length());        } else {            reason = null;        }        // 当&quot;sys.shutdown.requested&quot;的值不为空，则重启或者关机        ShutdownThread.rebootOrShutdown(null, reboot, reason);    }}</code></pre><p>  通过系统属性值 “sys.shutdown.requested” 来监测关机是否异常。</p></li><li><p>createSystemContext</p><pre><code>private void createSystemContext() {    // 创建system_server进程的上下文信息    ActivityThread activityThread = ActivityThread.systemMain();    mSystemContext = activityThread.getSystemContext();    // 设置主题    mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);}</code></pre><p>  系统上下文通过 ActivityThread 实例创建，该过程会创建对象有 Instrumentation, ContextImpl，LoadedApk，Application 等。</p></li><li><p>启动相关引导服务</p><pre><code>private void startBootstrapServices() {    // 阻塞等待与installd建立socket通道    Installer installer = mSystemServiceManager.startService(Installer.class);    mActivityManagerService = mSystemServiceManager.startService(            ActivityManagerService.Lifecycle.class).getService();    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);    mActivityManagerService.setInstaller(installer);    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);    mActivityManagerService.initPowerManagement();    mSystemServiceManager.startService(LightsService.class);    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);    // 当设备正在加密时，仅运行核心    String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);    if (ENCRYPTING_STATE.equals(cryptState)) {        Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;);        mOnlyCore = true;    } else if (ENCRYPTED_STATE.equals(cryptState)) {        Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;);        mOnlyCore = true;    }    // Start the package manager.    Slog.i(TAG, &quot;Package Manager&quot;);    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);    mFirstBoot = mPackageManagerService.isFirstBoot();    mPackageManager = mSystemContext.getPackageManager();    Slog.i(TAG, &quot;User Service&quot;);    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());    AttributeCache.init(mSystemContext);    // 设置AMS    mActivityManagerService.setSystemProcess();    // 启动传感器服务    startSensorService();}       </code></pre><p>  通览代码，其主要启动以下几个系统关键服务：</p><ol><li>ActivityManagerService</li><li>PowerManagerService</li><li>LightsService</li><li>DisplayManagerService</li><li>PackageManagerService</li><li>UserManagerService</li><li><p>sensor传感器服务</p><img src="/FuckCode/2018/06/07/源码分析之SystemServer流程分析2/system_server1.png" title="system_server1.png"></li></ol></li></ul><ul><li><p>启动系统关键服务</p><pre><code>private void startCoreServices() {    // 用于统计电池电量    mSystemServiceManager.startService(BatteryService.class);    //用于统计应用使用情况    mSystemServiceManager.startService(UsageStatsService.class);    mActivityManagerService.setUsageStatsManager(            LocalServices.getService(UsageStatsManagerInternal.class));    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();    // Tracks whether the updatable WebView is in a ready state and watches for update installs.    mSystemServiceManager.startService(WebViewUpdateService.class);}</code></pre><p>  以上主要启动服务有： BatteryService，UsageStatsService，WebViewUpdateService。</p></li></ul><ul><li><p>启动其他相关服务</p><p>  待系统关键服务启动起来之后，就需要将其他相关服务启动起来，例如：窗口管理，网络服务，电话服务等。</p>  <img src="/FuckCode/2018/06/07/源码分析之SystemServer流程分析2/system_server2.png" title="system_server2.png"><pre><code>private void startOtherServices() { // 若干服务变量声明 final Context context = mSystemContext; AccountManagerService accountManager = null; ContentService contentService = null; ... // 若干配置量获取 boolean disableStorage = SystemProperties.getBoolean(&quot;config.disable_storage&quot;, false); boolean disableBluetooth = SystemProperties.getBoolean(&quot;config.disable_bluetooth&quot;, false); boolean disableLocation = SystemProperties.getBoolean(&quot;config.disable_location&quot;, false); // 启动相关服务 try {     SystemConfig.getInstance();     ServiceManager.addService(&quot;scheduling_policy&quot;, new SchedulingPolicyService());     mSystemServiceManager.startService(TelecomLoaderService.class);     ...     // 初始化看门狗服务     final Watchdog watchdog = Watchdog.getInstance();     watchdog.init(context, mActivityManagerService);     //创建InputManager，用于下面初始化WindowManagerService     inputManager = new InputManagerService(context);     //调用WindowManagerService的main方法初始化     wm = WindowManagerService.main(context, inputManager,             mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,             !mFirstBoot, mOnlyCore);     ServiceManager.addService(Context.WINDOW_SERVICE, wm);     ServiceManager.addService(Context.INPUT_SERVICE, inputManager);     mActivityManagerService.setWindowManager(wm);     inputManager.setWindowManagerCallbacks(wm.getInputMonitor());     // 启动InputManager     inputManager.start(); try {     wm.displayReady(); } catch (Throwable e) {     reportWtf(&quot;making display ready&quot;, e); } ...     // 根据配置，初始化若干服务     if (!disableNetwork) {         try {             Slog.i(TAG, &quot;NetworkManagement Service&quot;);             networkManagement = NetworkManagementService.create(context);             ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);         } catch (Throwable e) {             reportWtf(&quot;starting NetworkManagement Service&quot;, e);         }     }   ...     // 安全模式判定        final boolean safeMode = wm.detectSafeMode(); if (safeMode) {     mActivityManagerService.enterSafeMode();     VMRuntime.getRuntime().disableJitCompilation(); } else {     VMRuntime.getRuntime().startJitCompilation(); } try {     vibrator.systemReady();     } catch (Throwable e) {         reportWtf(&quot;making Vibrator Service ready&quot;, e);     } mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY); mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY); try {     wm.systemReady(); } catch (Throwable e) {     reportWtf(&quot;making Window Manager Service ready&quot;, e); } if (safeMode) {     mActivityManagerService.showSafeModeOverlay(); }...mActivityManagerService.systemReady(new Runnable() {     @Override     public void run() {         //启动到阶段550         mSystemServiceManager.startBootPhase(                 SystemService.PHASE_ACTIVITY_MANAGER_READY);         try {             mActivityManagerService.startObservingNativeCrashes();         } catch (Throwable e) {             reportWtf(&quot;observing native crashes&quot;, e);         }        WebViewFactory.prepareWebViewInSystemServer();         // 启动SystemUI         try {             startSystemUi(context);         } catch (Throwable e) {             reportWtf(&quot;starting System UI&quot;, e);         }         // 相关服务回掉进入 systemReady() 状态         try {             if (networkScoreF != null) networkScoreF.systemReady();         } catch (Throwable e) {             reportWtf(&quot;making Network Score Service ready&quot;, e);         }        ...         // 开启看门狗服务         Watchdog.getInstance().start();</code></pre></li></ul><pre><code>                mSystemServiceManager.startBootPhase(                        SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);                // 相关服务回掉进入 systemRunning() 状态                try {                    if (wallpaperF != null) wallpaperF.systemRunning();                } catch (Throwable e) {                    reportWtf(&quot;Notifying WallpaperService running&quot;, e);                }               ...            }        });    }在启动其他服务时，SystemServiceManager的startBootPhase()贯穿system_server进程的整个启动过程。执行到此, System_server主线程的启动工作总算完成, 进入Looper.loop()状态,等待其他线程通过handler发送消息到主线再处理。</code></pre><h4 id="服务启动阶段分析"><a href="#服务启动阶段分析" class="headerlink" title="服务启动阶段分析"></a>服务启动阶段分析</h4><ul><li><p>系统服务的启动过程中，全程由 SystemServiceManager的startBootPhase()贯穿， 具体阶段内容引用 Gityuan博客中的图片：</p>  <img src="/FuckCode/2018/06/07/源码分析之SystemServer流程分析2/system_server4.png" title="system_server4.png"></li></ul><ol><li><p>PHASE_WAIT_FOR_DEFAULT_DISPLAY = 100</p><p> 启动系统四大引导服务：</p><pre><code>ActivityManagerServicePowerManagerServiceLightsServiceDisplayManagerService</code></pre></li><li><p>PHASE_SYSTEM_SERVICES_READY = 100</p><p> 进入阶段 PHASE_WAIT_FOR_DEFAULT_DISPLAY = 100 回调服务 DisplayManagerService ，然后创建大量服务下面列举部分:</p><p> PackageManagerService<br> WindowManagerService<br> InputManagerService<br> NetworkManagerService<br> …</p></li><li><p>PHASE_LOCK_SETTINGS_READY = 480</p><p> 进入阶段 PHASE_LOCK_SETTINGS_READY = 480 回调服务 DevicePolicyManagerService，此部分服务可以获取系统配置数据，然后立即进入 500 状态</p></li><li><p>PHASE_SYSTEM_SERVICES_READY = 500</p><p> 进入该阶段服务能安全地调用核心系统服务，例如 PowerManager 或者 PackageManager</p><pre><code>AlarmManagerServiceJobSchedulerServiceNotificationManagerServiceBackupManagerServiceUsageStatsServiceDeviceIdleControllerTrustManagerServiceUiModeManagerServiceBluetoothServiceBluetoothManagerServiceEthernetServiceWifiP2pServiceWifiScanningServiceWifiService...</code></pre><p> 各大服务执行systemReady():</p><pre><code>WindowManagerService.systemReady();PowerManagerService.systemReady();PackageManagerService.systemReady();DisplayManagerService.systemReady();</code></pre><p> 接下来就绪 AMS.systemReady 方法</p></li></ol><ul><li><p>PHASE_ACTIVITY_MANAGER_READY</p><p>  进入 PHASE_ACTIVITY_MANAGER_READY = 550， AMS.mSystemReady = true, 已准备就绪,进入该阶段服务能广播Intent;但是system_server主线程并没有就绪</p><pre><code>MountServiceTelecomLoaderServiceUsbServiceWebViewUpdateServiceDockObserverBatteryService</code></pre><p>  接下来执行: (AMS启动native crash监控, 加载WebView，启动SystemUi等),如下</p><pre><code>mActivityManagerService.startObservingNativeCrashes();WebViewFactory.prepareWebViewInSystemServer();startSystemUi(context);networkScoreF.systemReady();networkManagementF.systemReady();networkStatsF.systemReady();networkPolicyF.systemReady();connectivityF.systemReady();audioServiceF.systemReady();Watchdog.getInstance().start();</code></pre></li><li><p>PHASE_THIRD_PARTY_APPS_CAN_START</p><p>  进入此阶段 PHASE_THIRD_PARTY_APPS_CAN_START = 600， 服务可以开启绑定其他app，Apps可以通过Binder与客户端服务通信。</p><pre><code>JobSchedulerServiceNotificationManagerServiceBackupManagerServiceAppWidgetServiceGestureLauncherServiceDreamManagerServiceTrustManagerServiceVoiceInteractionManagerService</code></pre><p>  接下来,进入各种服务的 systemRunning 过程:</p><pre><code>WallpaperManagerServiceInputMethodManagerServiceLocationManagerServiceCountryDetectorService...</code></pre></li><li><p>PHASE_BOOT_COMPLETED</p><p>  经过一系列流程，再调用AMS.finishBooting()时，进入 PHASE_BOOT_COMPLETED = 1000 阶段，此阶段内服务可以与设备交互，设备完成启动，进入主页程序。</p></li></ul><p>到此，系统服务启动阶段完成就绪，system_server进程启动完成则进入Looper.loop()状态，随时待命，等待消息队列MessageQueue中的消息到来，则马上进入执行状态。</p><hr><h3 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h3><p>在学习源码中，参考了各位大神的博客内容。安卓源码本来就庞大无比，耐着性子慢慢钻研，还是可以消化掉的。这里推荐<strong><em>Gityuan</em></strong>的博客，博客内容针对6.0源码解析，详细周到，十分到位，很适合作为一手的学习资料。</p><blockquote><p><a href="http://gityuan.com/2016/02/20/android-system-server-2/" target="_blank" rel="noopener">Gityuan博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析之Zygote启动流程</title>
      <link href="/FuckCode/2018/06/06/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BZygote%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/FuckCode/2018/06/06/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BZygote%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>安卓中的Zygote进程，为万物进程的始祖进程。所有的应用创建都是基于此进程进行开辟的，其本名为受精卵，这里不免称其为进程孵化器。此篇文章就着重介绍Zygote的创建流程，继而分析后续安卓系统中进程的创建原理。</strong></p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>init进程解析完成rc脚本文件后，便进入Zygote的启动过程。</p><pre><code>service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server    class main  //伴随着main class的启动而启动    socket zygote stream 660 root system    //创建socket    onrestart write /sys/android_power/request_state wake    onrestart write /sys/power/state on    onrestart restart media //zygote重启，则会重启media    onrestart restart netd  //zygote重启，则会重启netd</code></pre><p>脚本文件指明服务名称 zygote，服务路径/system/bin/app_process,启动参数-Xzygote /system/bin –zygote –start-system-server</p><p>关于init.rc脚本分析<a href="https://891904833.gitee.io/fuckingcode/2018/05/22/init-rc%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/">请戳这里</a></p><p>关于init进程启动分析<a href="https://891904833.gitee.io/fuckingcode/2018/06/04/init%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">请戳这里</a></p><h1 id="启动流程分析"><a href="#启动流程分析" class="headerlink" title="启动流程分析"></a>启动流程分析</h1><p>上面rc的脚本可以看出，zygote进程开启的服务进程为app_process，程序路径位于 /system/bin/app_process， 以启动参数 -Xzygote /system/bin –zygote 执行。 –start-system-server</p><h2 id="app-process启动流程"><a href="#app-process启动流程" class="headerlink" title="app_process启动流程"></a>app_process启动流程</h2><p>app_process 进程的启动流程可以用下图来描述。</p><img src="/FuckCode/2018/06/06/源码分析之Zygote启动流程/zygote_init.png" title="zygote_init.png"><p>–&gt;frameworks/base/cmds/app_process/app_main.cpp</p><pre><code>// init.cpp解析init.rc文件，fork（）子进程执行到此int main(int argc, char* const argv[]){    ...    // 传递的参数为argv“-Xzygote /system/bin --zygote --start-system-server”    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));    argc--; // 忽略第一个参数    argv++;    int i;    for (i = 0; i &lt; argc; i++) {        if (argv[i][0] != &apos;-&apos;) {            break;        }        if (argv[i][1] == &apos;-&apos; &amp;&amp; argv[i][2] == 0) {            ++i; // Skip --.            break;        }        runtime.addOption(strdup(argv[i]));    }    // 参数解析    bool zygote = false;    bool startSystemServer = false;    bool application = false;    String8 niceName;    String8 className;    ++i;  // Skip unused &quot;parent dir&quot; argument.    while (i &lt; argc) {        const char* arg = argv[i++];        if (strcmp(arg, &quot;--zygote&quot;) == 0) {            zygote = true;            // 对于64系统nice_name为zygote64;32位系统为zygote            niceName = ZYGOTE_NICE_NAME;        } else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) {            startSystemServer = true;        } else if (strcmp(arg, &quot;--application&quot;) == 0) {            application = true;        } else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) {            niceName.setTo(arg + 12);        } else if (strncmp(arg, &quot;--&quot;, 2) != 0) {            className.setTo(arg);            break;        } else {            --i;            break;        }    }    Vector&lt;String8&gt; args;    if (!className.isEmpty()) {        // 运行application或tool程序        args.add(application ? String8(&quot;application&quot;) : String8(&quot;tool&quot;));        runtime.setClassNameAndArgs(className, argc - i, argv + i);    } else {        // 进入zygote模式，创建/data/dalvik-cache路径        maybeCreateDalvikCache();        if (startSystemServer) {            args.add(String8(&quot;start-system-server&quot;));        }        char prop[PROP_VALUE_MAX];        if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) {            LOG_ALWAYS_FATAL(&quot;app_process: Unable to determine ABI list from property %s.&quot;,                ABI_LIST_PROPERTY);            return 11;        }        String8 abiFlag(&quot;--abi-list=&quot;);        abiFlag.append(prop);        args.add(abiFlag);        // In zygote mode, pass all remaining arguments to the zygote        // main() method.        for (; i &lt; argc; ++i) {            args.add(String8(argv[i]));        }    }    // 设置进程名    if (!niceName.isEmpty()) {        runtime.setArgv0(niceName.string());        set_process_name(niceName.string());    }    if (zygote) {        // 启动AppRuntime        // framework/base/core/jni/AndroidRuntime.cpp        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);    } else if (className) {        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);    } else {        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);        app_usage();        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);        return 10;    }}</code></pre><p>上述代码执行的任务，主要可以总结以下：</p><ol><li>程序首先对传入的参数进行解析，获取其启动是的相关参数</li><li>创建虚拟机缓存 maybeCreateDalvikCache()</li><li>收集其他启动参数</li><li>设置进程名</li><li>启动AppRuntime.start()启动ZygoteInit首次进入Java世界</li></ol><h2 id="AppRuntime-start"><a href="#AppRuntime-start" class="headerlink" title="AppRuntime.start()"></a>AppRuntime.start()</h2><p>AppRuntime.start主要流程如下图所示：</p><img src="/FuckCode/2018/06/06/源码分析之Zygote启动流程/zygote_liucheng.png" title="zygote_liucheng.png"><p>AppRuntime继承自AndroidRuntime，其父类实现了start方法，如下</p><p>–&gt; framework/base/core/jni/AndroidRuntime.cpp</p><pre><code>// runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote){    ...    // 虚拟机创建    if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) {        return;    }    // 方法回调    onVmCreated(env);    // JNI方法注册    if (startReg(env) &lt; 0) {        ALOGE(&quot;Unable to register all android natives\n&quot;);        return;    }    ...    // 等价strArray = new String[options.size() + 1]    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);    assert(stringClass != NULL);    strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);    assert(strArray != NULL);    // 等价strArry[0] = &quot;com.android.internal.os.ZygoteInit&quot;    classNameStr = env-&gt;NewStringUTF(className);    assert(classNameStr != NULL);    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);    // 等价 strArry[1] = &quot;start-system-server&quot;;    // 等价 strArry[2] = &quot;--abi-list=xxx&quot;;    // 其中xxx为系统响应的cpu架构类型，比如arm64-v8a    for (size_t i = 0; i &lt; options.size(); ++i) {        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());        assert(optionsStr != NULL);        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);    }   // 将“com.android.internal.os.ZygoteInit”转换为“com/android/internal/os/ZygoteInit”    char* slashClassName = toSlashClassName(className);    jclass startClass = env-&gt;FindClass(slashClassName);    if (startClass == NULL) {        ALOGE(&quot;JavaVM unable to locate class &apos;%s&apos;\n&quot;, slashClassName);        /* keep going */    } else {        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,            &quot;([Ljava/lang/String;)V&quot;);        if (startMeth == NULL) {            ALOGE(&quot;JavaVM unable to find main() in &apos;%s&apos;\n&quot;, className);            /* keep going */        } else {            // 通过jni调用ZygoyeInit.main()方法,首次进入Java世界            // framework/base/core/java/com/android/internal/os/ZygoteInit.java            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);#if 0            if (env-&gt;ExceptionCheck())                threadExitUncaughtException(env);#endif        }    }    // 释放相应对象的内存空间    free(slashClassName);    ...}    </code></pre><p>AndroidRuntime的start函数中，其主要有以下几个重要步骤：</p><ol><li>startVm()    创建虚拟机</li><li>startReg()    注册系统JNI方法</li><li>CallStaticVoidMethod()    反射调用初始化ZygoteInit进入Java世界</li><li>释放内存操作</li></ol><h3 id="startVm-初始化虚拟机"><a href="#startVm-初始化虚拟机" class="headerlink" title="startVm()初始化虚拟机"></a>startVm()初始化虚拟机</h3><p>虚拟机的简要介绍如下：</p><img src="/FuckCode/2018/06/06/源码分析之Zygote启动流程/dalvik.png" title="dalvik.png"><pre><code>int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote){    // JNI检测功能，用于native层调用jni函数时进行常规检测，比较弱字符串格式是否符合要求，资源是否正确释放。该功能一般用于早期系统调试或手机Eng版，对于User版往往不会开启，引用该功能比较消耗系统CPU资源，降低系统性能。    bool checkJni = false;    property_get(&quot;dalvik.vm.checkjni&quot;, propBuf, &quot;&quot;);    if (strcmp(propBuf, &quot;true&quot;) == 0) {        checkJni = true;    } else if (strcmp(propBuf, &quot;false&quot;) != 0) {        property_get(&quot;ro.kernel.android.checkjni&quot;, propBuf, &quot;&quot;);        if (propBuf[0] == &apos;1&apos;) {            checkJni = true;        }    }    if (checkJni) {        addOption(&quot;-Xcheck:jni&quot;);    }    //虚拟机产生的trace文件，主要用于分析系统问题，路径默认为/data/anr/traces.txt    parseRuntimeOption(&quot;dalvik.vm.stack-trace-file&quot;, stackTraceFileBuf, &quot;-Xstacktracefile:&quot;);    //对于不同的软硬件环境，这些参数往往需要调整、优化，从而使系统达到最佳性能    parseRuntimeOption(&quot;dalvik.vm.heapstartsize&quot;, heapstartsizeOptsBuf, &quot;-Xms&quot;, &quot;4m&quot;);    parseRuntimeOption(&quot;dalvik.vm.heapsize&quot;, heapsizeOptsBuf, &quot;-Xmx&quot;, &quot;16m&quot;);    parseRuntimeOption(&quot;dalvik.vm.heapgrowthlimit&quot;, heapgrowthlimitOptsBuf, &quot;-XX:HeapGrowthLimit=&quot;);    parseRuntimeOption(&quot;dalvik.vm.heapminfree&quot;, heapminfreeOptsBuf, &quot;-XX:HeapMinFree=&quot;);    parseRuntimeOption(&quot;dalvik.vm.heapmaxfree&quot;, heapmaxfreeOptsBuf, &quot;-XX:HeapMaxFree=&quot;);    parseRuntimeOption(&quot;dalvik.vm.heaptargetutilization&quot;,                       heaptargetutilizationOptsBuf, &quot;-XX:HeapTargetUtilization=&quot;);    ...    //preloaded-classes文件内容是由WritePreloadedClassFile.java生成的，    //在ZygoteInit类中会预加载工作将其中的classes提前加载到内存，以提高系统性能    if (!hasFile(&quot;/system/etc/preloaded-classes&quot;)) {        return -1;    }    //初始化虚拟机    if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) {        ALOGE(&quot;JNI_CreateJavaVM failed\n&quot;);        return -1;    }}</code></pre><p>此部分代码太多，此部分不做过多的说明。</p><h3 id="startReg"><a href="#startReg" class="headerlink" title="startReg()"></a>startReg()</h3><p>注册系统JNI接口</p><pre><code>/* * Register android native functions with the VM. * 注册JNI方法，其中gRegJNI是一个数组，记录所有需要注册的jni方法， * 其中有一项便是REG_JNI(register_android_os_Binder) *//*static*/ int AndroidRuntime::startReg(JNIEnv* env){     // 设置线程创建方法为javaCreateThreadEtc    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);    env-&gt;PushLocalFrame(200);    // 进程JNI方法的注册    // 内部循环调用gRegJNI数组成员所对应的方法    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) {        env-&gt;PopLocalFrame(NULL);        return -1;    }    env-&gt;PopLocalFrame(NULL);    //createJavaThread(&quot;fubar&quot;, quickTest, (void*) &quot;hello&quot;);    return 0;}</code></pre><p>内部循环调用gRegJNI数组成员所对应的方法</p><pre><code>static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env){    for (size_t i = 0; i &lt; count; i++) {        if (array[i].mProc(env) &lt; 0) {#ifndef NDEBUG            ALOGD(&quot;----------!!! %s failed to load\n&quot;, array[i].mName);#endif            return -1;        }    }    return 0;}</code></pre><p>REG_JNI是一个宏定义，作用就是调用相应的方法</p><pre><code>// 该数组的每个成员都代表一个类文件的jni映射static const RegJNIRec gRegJNI[] = {    REG_JNI(register_com_android_internal_os_RuntimeInit),    REG_JNI(register_android_os_SystemClock),    REG_JNI(register_android_util_EventLog),    ...    // Binder-jni定义    REG_JNI(register_android_os_Binder),    REG_JNI(register_android_os_Parcel),    // 注册MessageQueue的native层jni实现    REG_JNI(register_android_os_MessageQueue),    REG_JNI(register_android_os_SELinux),    REG_JNI(register_android_os_Trace),    ...}</code></pre><p>array[i]是指gRegJNI数组, 该数组有100多个成员。其中每一项成员都是通过REG_JNI宏定义的</p><pre><code>#define REG_JNI(name)      { name, #name }struct RegJNIRec {    int (*mProc)(JNIEnv*);    const char* mName;};</code></pre><p>由此可见，调用mProc，就等价于调用其参数名所指向的函数。 </p><p>例如REG_JNI(register_com_android_internal_os_RuntimeInit).mProc也就是指进入register_com_android_internal_os_RuntimeInit方法，接下来就继续以此为例来说明</p><pre><code>int register_com_android_internal_os_RuntimeInit(JNIEnv* env) {    return jniRegisterNativeMethods(env, &quot;com/android/internal/os/RuntimeInit&quot;,        gMethods, NELEM(gMethods));}//gMethods：java层方法名与jni层的方法的一一映射关系static JNINativeMethod gMethods[] = {    { &quot;nativeFinishInit&quot;, &quot;()V&quot;,        (void*) com_android_internal_os_RuntimeInit_nativeFinishInit },    { &quot;nativeZygoteInit&quot;, &quot;()V&quot;,        (void*) com_android_internal_os_RuntimeInit_nativeZygoteInit },    { &quot;nativeSetExitWithoutCleanup&quot;, &quot;(Z)V&quot;,        (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup },};</code></pre><h2 id="ZygoteInit-main-执行"><a href="#ZygoteInit-main-执行" class="headerlink" title="ZygoteInit.main()执行"></a>ZygoteInit.main()执行</h2><p>AndroidRuntime最终调用CallStaticVoidMethod()，通过jni反射调用到ZygoteInit.java的main方法,首次进入Java世界，如下图：</p><img src="/FuckCode/2018/06/06/源码分析之Zygote启动流程/zygote_fenxi.png" title="zygote_fenxi.png"><pre><code>--&gt; framework/base/core/java/com/android/internal/os/ZygoteInit.java    public static void main(String argv[]) {        try {            ...            // 为Zygote注册socket            registerZygoteSocket(socketName);            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,                SystemClock.uptimeMillis());            // 预加载类和资源            preload();            gcAndFinalize(); //GC操作            Trace.setTracingEnabled(false);            // 启动system_server            if (startSystemServer) {                startSystemServer(abiList, socketName);            }            // 进入循环模式，等待AMS请求创建新应用进程            runSelectLoop(abiList);            closeServerSocket();        } catch (MethodAndArgsCaller caller) {            caller.run();   //启动system_server        } catch (RuntimeException ex) {            Log.e(TAG, &quot;Zygote died with exception&quot;, ex);            closeServerSocket();            throw ex;        }    }</code></pre><p>ZygoteInit的main方法主要有以下几个重要方法：</p><ol><li>为zygote注册socket</li><li>预加载类和资源</li><li>启动system_server服务</li><li>进入循环，等待AMS请求创建新的应用进程</li></ol><h3 id="registerZygoteSocket"><a href="#registerZygoteSocket" class="headerlink" title="registerZygoteSocket"></a>registerZygoteSocket</h3><p>注册socket，负责其他进程与其进行通信</p><pre><code>// 注册zygote端socketprivate static void registerZygoteSocket(String socketName) {    if (sServerSocket == null) {        int fileDesc;        // socket文件名        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;        // 安全性检查        try {            String env = System.getenv(fullSocketName);            fileDesc = Integer.parseInt(env);        } catch (RuntimeException ex) {            throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex);        }        try {            // 创建文件描述符            FileDescriptor fd = new FileDescriptor();            // 设置文件描述符            fd.setInt$(fileDesc);            // 创建Socket的本地服务端，静态保存            sServerSocket = new LocalServerSocket(fd);        } catch (IOException ex) {            throw new RuntimeException(                    &quot;Error binding to local socket &apos;&quot; + fileDesc + &quot;&apos;&quot;, ex);        }    }}</code></pre><h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h3><p>Zygote进程中，预先加载一些必要的资源和共享库，后续创建进程直接fork，效率非常高。</p><pre><code>static void preload() {    // 预加载位于/system/etc/preloaded-classes文件中的类    preloadClasses();    // 预加载资源，包含drawable和color资源    preloadResources();    // 预加载OpenGL    preloadOpenGL();    // 通过System.loadLibrary()方法    // 预加载&quot;android&quot;,&quot;compiler_rt&quot;,&quot;jnigraphics&quot;这3个共享库    preloadSharedLibraries();    // MStar Android Patch Begin    // preloadTextResources();  //  预加载文本连接符资源    // MStar Android Patch End    // 仅用于zygote进程，用于内存共享的进程    WebViewFactory.prepareWebViewInZygote();    Log.d(TAG, &quot;end preload&quot;);}</code></pre><h3 id="startSystemServer"><a href="#startSystemServer" class="headerlink" title="startSystemServer"></a>startSystemServer</h3><p>Zygote通过fork子进程，启动system_server服务</p><pre><code>private static boolean startSystemServer(String abiList, String socketName)        throws MethodAndArgsCaller, RuntimeException {    long capabilities = posixCapabilitiesAsBits(        OsConstants.CAP_BLOCK_SUSPEND,        OsConstants.CAP_KILL,        OsConstants.CAP_NET_ADMIN,        OsConstants.CAP_NET_BIND_SERVICE,        OsConstants.CAP_NET_BROADCAST,        OsConstants.CAP_NET_RAW,        OsConstants.CAP_SYS_MODULE,        OsConstants.CAP_SYS_NICE,        OsConstants.CAP_SYS_RESOURCE,        OsConstants.CAP_SYS_TIME,        OsConstants.CAP_SYS_TTY_CONFIG    );    /* Hardcoded command line to start the system server */    // 参数准备    String args[] = {        &quot;--setuid=1000&quot;,        &quot;--setgid=1000&quot;,        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007&quot;,        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,        &quot;--nice-name=system_server&quot;,        &quot;--runtime-args&quot;,        &quot;com.android.server.SystemServer&quot;,    };    ZygoteConnection.Arguments parsedArgs = null;    int pid;    try {        // 用于解析参数，用于运行system_server        parsedArgs = new ZygoteConnection.Arguments(args);        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);        /* Request to fork the system server process */        // 直接在zygote基础上fork子进程，用于运行system_server        pid = Zygote.forkSystemServer(                parsedArgs.uid, parsedArgs.gid,                parsedArgs.gids,                parsedArgs.debugFlags,                null,                parsedArgs.permittedCapabilities,                parsedArgs.effectiveCapabilities);    } catch (IllegalArgumentException ex) {        throw new RuntimeException(ex);    }    /* For child process */    // 子线程system_server返回0，进入子线程    if (pid == 0) {        if (hasSecondZygote(abiList)) {            waitForSecondaryZygote(socketName);        }        // 完成system_server进程剩余工作，启动System进程        handleSystemServerProcess(parsedArgs);    }    return true;}</code></pre><h3 id="runSelectLoop"><a href="#runSelectLoop" class="headerlink" title="runSelectLoop"></a>runSelectLoop</h3><p>Zygote进入循环模式，等待AMS请求创建新应用进程</p><pre><code>private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();    // sServerSocket是socket通信中的服务端，即zygote进程server，保存到fds[0]    fds.add(sServerSocket.getFileDescriptor());    peers.add(null);    // 不断循环等待AMS的请求    while (true) {        // 同步刷新socket文件描述符的链接事件驱动进行重新监听（I/O多路复用机制）        StructPollfd[] pollFds = new StructPollfd[fds.size()];        for (int i = 0; i &lt; pollFds.length; ++i) {            pollFds[i] = new StructPollfd();            pollFds[i].fd = fds.get(i);            pollFds[i].events = (short) POLLIN;        }        try {            // 采用poll机制，处理轮询状态，当pollFds有事件到来，则往下执行，否则会阻塞在这里            Os.poll(pollFds, -1);        } catch (ErrnoException ex) {            throw new RuntimeException(&quot;poll failed&quot;, ex);        }        for (int i = pollFds.length - 1; i &gt;= 0; --i) {            // 采用I/O多路复用机制，当收到客户端发出的连接请求或者数据处理请求，则往下执行            // 否则跳出本次循环            if ((pollFds[i].revents &amp; POLLIN) == 0) {                continue;            }            if (i == 0) {                // fds[0]，代表的是sServerSocket，则意味着客户端链接请求                // 创建ZygoteConnection对象，添加到链接列表peers，并添加fds                ZygoteConnection newPeer = acceptCommandPeer(abiList);                peers.add(newPeer);                fds.add(newPeer.getFileDesciptor());                // 解释开头刷新监听文件描述符的原因            } else {                //i &gt; 0,则代表通过socket接受来自对客户端的数据请求，并执行相应操作，创建新的应用进程                boolean done = peers.get(i).runOnce();                if (done) {                    // 处理完成，移除监听文件描述符集                    peers.remove(i);                    fds.remove(i); //处理完则从fds中移除该文件描述符                }            }        }    }}</code></pre><p>Zygote采用高效的I/O多路复用机制，保证在没有客户端连接请求或数据处理时休眠，否则响应客户端的请求，此处采用的poll机制，具体原理可以参考以下链接<br><a href="https://891904833.gitee.io/fuckingcode/2019/01/23/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/#more">戳我</a></p><ol><li>客户端通过openZygoteSocketIfNeeded()来跟zygote进程建立连接</li><li>zygote接收到客户端连接请求后执行accept()</li><li>然后创建ZygoteConnection对象，并添加fds数组列表</li><li>建立连接后，可以跟客户端进行通信，进入runOnce()方法来接收客户端数据，并执行进程创建工作</li></ol><h3 id="runOnce"><a href="#runOnce" class="headerlink" title="runOnce"></a>runOnce</h3><p>Zygote处理客户端链接创建进程的处理</p><p>–&gt; frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</p><pre><code>boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {    ...    try {        //读取socket客户端发送过来的参数列表        args = readArgumentList();        descriptors = mSocket.getAncillaryFileDescriptors();    } catch (IOException ex) {        ...        return true;    }    ...    try {        // 将binder客户端传递过来的参数，解析成Arguments对象格式        parsedArgs = new Arguments(args);        ...    // 通过fork创建进程       pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,                parsedArgs.appDataDir);    } catch (Exception e) {        ...    }    try {        if (pid == 0) {            //子进程执行，首先关闭fork继承下来父进程的文件描述符            IoUtils.closeQuietly(serverPipeFd);            serverPipeFd = null;            //进入子进程处理流程            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);            return true;        } else {            //父进程执行，关闭子进程的文件描述符            IoUtils.closeQuietly(childPipeFd);            childPipeFd = null;            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);        }    } finally {        IoUtils.closeQuietly(childPipeFd);        IoUtils.closeQuietly(serverPipeFd);    }}</code></pre><p>关于zygote如何fork并启动应用，完成进程间通信，留待后续分析，这里不做过多介绍，可以用如下图来说明其具体流程。</p><img src="/FuckCode/2018/06/06/源码分析之Zygote启动流程/zygote_ctreate.png" title="zygote_ctreate.png"><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上述的介绍，基本将Zygote执行流程过了一遍，大概的框架梳理出来，后续在对其中具体的通信细节进行介绍，这里总结一下其流程：</p><ol><li>init.cpp解析init.zygote.rc中的参数，启动app_process,创建AppRuntime并调用AppRuntime.start()方法</li><li>AndroidRuntime调用startVM()方法创建虚拟机，调用startReg()注册JNI函数</li><li>app_main中，通过JNI方式反射调用ZygoteInit.main()，第一次进入Java世界</li><li>registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求</li><li>ZygoteInit.main中，preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率</li><li>zygote完成大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体</li><li>zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作</li></ol><hr><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><blockquote><p> 参考链接： <a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">戳我</a></p></blockquote><blockquote><p> 罗升阳 Android系统源代码情景分析</p></blockquote><p><a href="http://gityuan.com/archive/" target="_blank" rel="noopener">博客推荐-Gityuan</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zygote </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析之SystemServer流程分析1</title>
      <link href="/FuckCode/2018/06/06/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BSystemServer%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%901/"/>
      <url>/FuckCode/2018/06/06/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BSystemServer%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%901/</url>
      
        <content type="html"><![CDATA[<h3 id="System-Server启动分析"><a href="#System-Server启动分析" class="headerlink" title="System_Server启动分析"></a>System_Server启动分析</h3><ul><li><p>前言</p><p>  Zygote进程启动过程中，其关联启动了系统重要的服务SystemServer，下面具体分析SystemServer是如何启动的。</p><p>  Zygote启动过程一览：</p>  <img src="/FuckCode/2018/06/06/源码分析之SystemServer流程分析1/system_server1.png" title="system_server1.png"><p>  –&gt; caller.run();</p><pre><code>public static void main(String argv[]) {    try {        ...        // 为Zygote注册socket        registerZygoteSocket(socketName);        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,            SystemClock.uptimeMillis());        // 预加载类和资源        preload();        ...        // 启动system_server        if (startSystemServer) {            startSystemServer(abiList, socketName);        }        Log.i(TAG, &quot;Accepting command socket connections&quot;);        // 进入循环模式，等待AMS请求创建新应用进程        runSelectLoop(abiList);        closeServerSocket();    } catch (MethodAndArgsCaller caller) {        caller.run();   //启动system_server    } catch (RuntimeException ex) {        Log.e(TAG, &quot;Zygote died with exception&quot;, ex);        closeServerSocket();        throw ex;    }}</code></pre><p>  注意代码中try-catch语句，在 catch (MethodAndArgsCaller caller) 中捕获异常后，调用<br>caller.run()来启动system_server服务。</p></li><li><p>启动startSystemServer()</p><p>  SystemServer启动一览</p>  <img src="/FuckCode/2018/06/06/源码分析之SystemServer流程分析1/system_server2.png" title="system_server2.png"><p>  –&gt; frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p><pre><code>private static boolean startSystemServer(String abiList, String socketName)        throws MethodAndArgsCaller, RuntimeException {    long capabilities = posixCapabilitiesAsBits(        OsConstants.CAP_BLOCK_SUSPEND,        OsConstants.CAP_KILL,        OsConstants.CAP_NET_ADMIN,        OsConstants.CAP_NET_BIND_SERVICE,        OsConstants.CAP_NET_BROADCAST,        OsConstants.CAP_NET_RAW,        OsConstants.CAP_SYS_MODULE,        OsConstants.CAP_SYS_NICE,        OsConstants.CAP_SYS_RESOURCE,        OsConstants.CAP_SYS_TIME,        OsConstants.CAP_SYS_TTY_CONFIG    );    /* Hardcoded command line to start the system server */    // 参数准备    String args[] = {        &quot;--setuid=1000&quot;,        &quot;--setgid=1000&quot;,        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007&quot;,        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,        &quot;--nice-name=system_server&quot;,        &quot;--runtime-args&quot;,        &quot;com.android.server.SystemServer&quot;,    };    ZygoteConnection.Arguments parsedArgs = null;    int pid;    try {        // 用于解析参数，用于运行system_server        parsedArgs = new ZygoteConnection.Arguments(args);        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);        /* Request to fork the system server process */        // fork子进程，用于运行system_server        pid = Zygote.forkSystemServer(                parsedArgs.uid, parsedArgs.gid,                parsedArgs.gids,                parsedArgs.debugFlags,                null,                parsedArgs.permittedCapabilities,                parsedArgs.effectiveCapabilities);    } catch (IllegalArgumentException ex) {        throw new RuntimeException(ex);    }    /* For child process */    // 返回0，进入子线程system_server    if (pid == 0) {        if (hasSecondZygote(abiList)) {            waitForSecondaryZygote(socketName);        }        // 完成system_server进程剩余工作，启动System进程        handleSystemServerProcess(parsedArgs);    }    return true;}</code></pre><p>  通过若干参数的设定，使用Zygote.forkSystemServer（）来fork出子进程，返回的pid为0表示在子进程中返回，根据配置判断是否有其他zygote启动项，最终调用handleSystemServerProcess()完成system_server的启动。</p></li><li><p>Zygote.forkSystemServer()</p><p>  –&gt; frameworks/base/core/java/com/android/internal/os/Zygote.java</p><pre><code>public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {    VM_HOOKS.preFork();    int pid = nativeForkSystemServer(            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);    // Enable tracing as soon as we enter the system_server.    if (pid == 0) {        Trace.setTracingEnabled(true);    }    VM_HOOKS.postForkCommon();    return pid;}</code></pre><p>  ZygoteInit通过调用Zygote.forkSystemServer使用Zygote间接fork子进程，Zygote内部通过JNI方法nativeForkSystemServer实现fork最终操作。</p></li><li><p>JNI层方法实现</p><p>  –&gt; frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</p><pre><code>static JNINativeMethod gMethods[] = {    { &quot;nativeForkAndSpecialize&quot;,      &quot;(II[II[[IILjava/lang/String;Ljava/lang/String;[ILjava/lang/String;Ljava/lang/String;)I&quot;,      (void *) com_android_internal_os_Zygote_nativeForkAndSpecialize },    { &quot;nativeForkSystemServer&quot;, &quot;(II[II[[IJJ)I&quot;,      (void *) com_android_internal_os_Zygote_nativeForkSystemServer }};</code></pre></li></ul><pre><code>    static jint com_android_internal_os_Zygote_nativeForkSystemServer(            JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,            jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,            jlong effectiveCapabilities) {      pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids,                                          debug_flags, rlimits,                                          permittedCapabilities, effectiveCapabilities,                                          MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL,                                          NULL, NULL);      if (pid &gt; 0) {          // The zygote process checks whether the child process has died or not.          ALOGI(&quot;System server process %d has been created&quot;, pid);          gSystemServerPid = pid;          // There is a slight window that the system server process has crashed          // but it went unnoticed because we haven&apos;t published its pid yet. So          // we recheck here just to make sure that all is well.          int status;          if (waitpid(pid, &amp;status, WNOHANG) == pid) {              ALOGE(&quot;System server process %d has died. Restarting Zygote!&quot;, pid);              RuntimeAbort(env);          }      }      return pid;    }    由上注视可知，在fork子进程中，jni层对进程是否存在和死亡进行了判断，通过一系列操作，最终返回进程的pid。</code></pre><ul><li><p>handleSystemServerProcess，启动System进程</p><pre><code>private static void handleSystemServerProcess(        ZygoteConnection.Arguments parsedArgs)        throws ZygoteInit.MethodAndArgsCaller {    closeServerSocket();// 关闭父进程zygote复制而来的socket    // set umask to 0077 so new files and directories will default to owner-only permissions.    Os.umask(S_IRWXG | S_IRWXO);    if (parsedArgs.niceName != null) {        Process.setArgV0(parsedArgs.niceName);// 设置当前进程名&quot;system_server&quot;    }    // 对指定路径下的jar包进行dex优化    final String systemServerClasspath = Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);    if (systemServerClasspath != null) {        // 执行dex优化操作        performSystemServerDexOpt(systemServerClasspath);    }    if (parsedArgs.invokeWith != null) {        String[] args = parsedArgs.remainingArgs;        // If we have a non-null system server class path, we&apos;ll have to duplicate the        // existing arguments and append the classpath to it. ART will handle the classpath        // correctly when we exec a new process.        if (systemServerClasspath != null) {            String[] amendedArgs = new String[args.length + 2];            amendedArgs[0] = &quot;-cp&quot;;            amendedArgs[1] = systemServerClasspath;            System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);        }        // 启动应用进程        WrapperInit.execApplication(parsedArgs.invokeWith,                parsedArgs.niceName, parsedArgs.targetSdkVersion,                VMRuntime.getCurrentInstructionSet(), null, args);    } else {        ClassLoader cl = null;        if (systemServerClasspath != null) {            // 创建应用加载器，并赋予当前线程            cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());            Thread.currentThread().setContextClassLoader(cl);        }        /*         * Pass the remaining arguments to SystemServer.         */        // SystemServer进入次分支        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);    }    /* should never reach here */}</code></pre><p>  通过一系列流程，进入到RuntimeInit.zygoteInit()完成启动</p></li><li><p>RuntimeInit.zygoteInit</p><p>  –&gt; frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p><pre><code>public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)        throws ZygoteInit.MethodAndArgsCaller {    if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);    redirectLogStreams();// 重定向log输出    commonInit();// 通用的一些初始化    nativeZygoteInit();// zygote初始化    applicationInit(targetSdkVersion, argv, classLoader);// 应用初始化}</code></pre></li><li><p>commonInit()通用设置</p><pre><code>// 通用初始化，设置时区，键盘private static final void commonInit() {    if (DEBUG) Slog.d(TAG, &quot;Entered RuntimeInit!&quot;);    /* set default handler; this applies to all threads in the VM */    //设置默认为捕捉异常处理方法    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());    /*     * Install a TimezoneGetter subclass for ZoneInfo.db     */    //设置时区，中国时区“Asia/Shanghai”    TimezoneGetter.setInstance(new TimezoneGetter() {        @Override        public String getId() {            return SystemProperties.get(&quot;persist.sys.timezone&quot;);        }    });    TimeZone.setDefault(null);    //重置log配置    LogManager.getLogManager().reset();    new AndroidConfig();    // 设置默认的HTTP User-agent格式，用于HttpURLConnection    String userAgent = getDefaultUserAgent();    System.setProperty(&quot;http.agent&quot;, userAgent);    // 设置socket的tag，用于网络流量统计    NetworkManagementSocketTagger.install();    String trace = SystemProperties.get(&quot;ro.kernel.android.tracing&quot;);    if (trace.equals(&quot;1&quot;)) {        Slog.i(TAG, &quot;NOTE: emulator trace profiling enabled&quot;);        Debug.enableEmulatorTraceOutput();    }    initialized = true;}</code></pre></li><li><p>nativeZygoteInit调用JNI层初始化</p><p>  –&gt; frameworks/base/core/jni/AndroidRuntime.cpp</p><pre><code>static JNINativeMethod gMethods[] = {    { &quot;nativeFinishInit&quot;, &quot;()V&quot;,        (void*) com_android_internal_os_RuntimeInit_nativeFinishInit },    { &quot;nativeZygoteInit&quot;, &quot;()V&quot;,        (void*) com_android_internal_os_RuntimeInit_nativeZygoteInit },    { &quot;nativeSetExitWithoutCleanup&quot;, &quot;(Z)V&quot;,        (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup },};static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz){    //此处的gCurRuntime为AppRuntime，是在AndroidRuntime.cpp中定义的    gCurRuntime-&gt;onZygoteInit();}</code></pre><p>  通过JNI最终调用到AndroidRuntime类的实现子类app_main中的onZygoteInit方法。</p><p>  –&gt; frameworks/base/cmds/app_process/app_main.cpp</p><pre><code>virtual void onZygoteInit(){    sp&lt;ProcessState&gt; proc = ProcessState::self();    ALOGV(&quot;App process: starting thread pool.\n&quot;);    proc-&gt;startThreadPool();// 启动新binder线程}</code></pre></li><li><p>applicationInit启动应用初始化</p><pre><code>private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)        throws ZygoteInit.MethodAndArgsCaller {    ...    // true代表应用程序退出时不调用AppRuntime.onExit()，否则会在推出前调用    nativeSetExitWithoutCleanup(true);    // 设置虚拟机的内存利用率参数值为0.75    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);    final Arguments args;    try {        args = new Arguments(argv);// 解析参数    } catch (IllegalArgumentException ex) {        Slog.e(TAG, ex.getMessage());        // let the process exit        return;    }    ...    // 调用startClass的static方法main()。args.startClass为&quot;android.app.ActivityThread&quot;    // 内部通过反射调用相应类的main方法，如SystemServer.main()    invokeStaticMain(args.startClass, args.startArgs, classLoader);}</code></pre><p>  代码最终调用invokeStaticMain方法，根据传入的参数反射调用启动system_server</p></li><li><p>invokeStaticMain反射启动</p><pre><code>private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)        throws ZygoteInit.MethodAndArgsCaller {    Class&lt;?&gt; cl;    try {        cl = Class.forName(className, true, classLoader);    } catch (ClassNotFoundException ex) {        // 通过抛出异常，回到ZygoteInit.main().这样的好处是能清空栈帧，提高栈帧利用率。        throw new RuntimeException(                &quot;Missing class when invoking static main &quot; + className,                ex);    }    Method m;    try {        // 获取反射实例对象对应的方法         m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class });    } catch (NoSuchMethodException ex) {        throw new RuntimeException(                &quot;Missing static main on &quot; + className, ex);    } catch (SecurityException ex) {        throw new RuntimeException(                &quot;Problem getting static main on &quot; + className, ex);    }    int modifiers = m.getModifiers();    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) {        throw new RuntimeException(                &quot;Main method is not public and static on &quot; + className);    }    // 通抛出异常 ZygoteInit.MethodAndArgsCaller 返回 ZygoteInit 的main方法中调用 caller.run()启动 system_server    // m = main, argv =     throw new ZygoteInit.MethodAndArgsCaller(m, argv);}</code></pre></li><li><p>MethodAndArgsCaller调用</p><pre><code>public static class MethodAndArgsCaller extends Exception        implements Runnable {    /** method to call */    private final Method mMethod;    /** argument array */    private final String[] mArgs;    public MethodAndArgsCaller(Method method, String[] args) {        mMethod = method;        mArgs = args;    }    public void run() {        try {            //根据传递过来的参数，此处反射调用SystemServer.main()方法            mMethod.invoke(null, new Object[] { mArgs });        } catch (IllegalAccessException ex) {            throw new RuntimeException(ex);        } catch (InvocationTargetException ex) {            Throwable cause = ex.getCause();            if (cause instanceof RuntimeException) {                throw (RuntimeException) cause;            } else if (cause instanceof Error) {                throw (Error) cause;            }            throw new RuntimeException(ex);        }    }}</code></pre><p>  通过传递的参数，反射调用SystemServer.main()启动system_server</p></li><li><p>SystemServer启动main</p><p>  –&gt; frameworks/base/services/java/com/android/server/SystemServer.java</p><pre><code>public static void main(String[] args) {    // 先初始化SystemServer对象，在调用器run()方法    new SystemServer().run();    }</code></pre></li><li><p>Zygote fork子进程，启动SystemServer流程一览图</p>  <img src="/FuckCode/2018/06/06/源码分析之SystemServer流程分析1/system_server2.png" title="system_server2.png"></li></ul><hr><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><ul><li><p>由于本人能力有限，对于细节内容不能一一道明原理机制，这里强烈推荐Gityuan大神的博客</p><p>  <a href="http://gityuan.com/2016/02/14/android-system-server/" target="_blank" rel="noopener">Gityuan博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析之init进程</title>
      <link href="/FuckCode/2018/06/04/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Binit%E8%BF%9B%E7%A8%8B/"/>
      <url>/FuckCode/2018/06/04/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Binit%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>init为安卓系统开启后，由kernel引导的第一个进程，其通过解析代码中不同的init.rc脚本，不断的将系统服务启动起来，具体的脚本文件已在之前博文中进行了介绍。本章节主要介绍init进程的启动流程。</strong></p><!--moew--><h1 id="init流程分析"><a href="#init流程分析" class="headerlink" title="init流程分析"></a>init流程分析</h1><ul><li><p>主要任务</p><ol><li>第一个应用程序</li><li>创建目录，挂在分区</li><li>解析应用脚本</li><li>启动服务</li><li>守护服务</li></ol></li><li><p>主要过程</p><ol><li>创建目录</li><li>klog_init()    将log重定向到/proc/kmsg中</li><li>property_init()    初始化属性服务</li><li>signal_handler_init()    初始化子进程退出的信号处理过程</li><li>property_load_boot_defaults()    初始化环境变量</li><li>init_parse_config_file(“/init.rc”)    解析init.rc</li><li>action_for_each_trigger(…)    执行rc脚本文件中对应的触发器</li><li>queue_builtin_action(…)    构建自定义事件，加入队列</li><li>execute_one_command()    死循环，执行脚本命令（启动进程）</li><li>restart_processes()        重启服务进程（守护进程）</li><li>epoll_wait()        监听管道，等待事件</li></ol></li></ul><ul><li>在分析init.cpp的具体流程，先来回顾下init.rc脚本的主要组成部分</li></ul><p><a href="https://github.com/Huoxubeiyin/Android_Soucecode/issues/19" target="_blank" rel="noopener">安卓源码分析之init.rc脚本</a></p><h2 id="rc脚本文件可以用以下几张图片概括"><a href="#rc脚本文件可以用以下几张图片概括" class="headerlink" title="rc脚本文件可以用以下几张图片概括"></a>rc脚本文件可以用以下几张图片概括</h2><ul><li>文件结构</li></ul><img src="/FuckCode/2018/06/04/源码分析之init进程/init.png" title="init.png"><pre><code>init.rc文件路径在/system/core/rootdir/init.rc下存在，根据不同的平台又有自己的rc脚本，通过import导入</code></pre><ul><li>导包内容</li></ul><img src="/FuckCode/2018/06/04/源码分析之init进程/init.rc.png" title="init.rc.png"><pre><code>其中 ${ ro.hardware } 的值可以通过 getprop ro.harware 命令获取，其对应于特定平台的rc文件，例如 getprop ro.hardware = mooney , 那么导包对应的rc脚本文件为init.mooney.rc</code></pre><ul><li>触发器</li></ul><img src="/FuckCode/2018/06/04/源码分析之init进程/init.rc_on.png" title="init.rc_on.png"><pre><code>脚本中声明多个 on ... 触发器，可以通过代码action_for_each_trigger(...)触发实现</code></pre><ul><li>service服务</li></ul><img src="/FuckCode/2018/06/04/源码分析之init进程/init.rc_services.png" title="init.rc_services.png"><pre><code>service服务脚本声明：指定脚本文件名称，路径，启动参数，类属以及其他属性值</code></pre><h3 id="init进程具体流程分析"><a href="#init进程具体流程分析" class="headerlink" title="init进程具体流程分析"></a>init进程具体流程分析</h3><p>init 主要的执行流程如下图所示</p><img src="/FuckCode/2018/06/04/源码分析之init进程/init.png" title="init.png"><h4 id="初始化-kernel-log-，位于设备节点-dev-kmsg"><a href="#初始化-kernel-log-，位于设备节点-dev-kmsg" class="headerlink" title="初始化 kernel log ，位于设备节点/dev/kmsg"></a>初始化 kernel log ，位于设备节点/dev/kmsg</h4><p>–&gt; klog.c</p><pre><code>void klog_init(void) {    if (klog_fd &gt;= 0) return; /* Already initialized */    // 打开指定设备    klog_fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC);    if (klog_fd &gt;= 0) {        return;    }    static const char* name = &quot;/dev/__kmsg__&quot;;    // 创建节点    if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 11) == 0) {        // 尝试打开        klog_fd = open(name, O_WRONLY | O_CLOEXEC);        unlink(name);    }}</code></pre><h4 id="初始化子进程退出的信号处理过程signal-handler-init"><a href="#初始化子进程退出的信号处理过程signal-handler-init" class="headerlink" title="初始化子进程退出的信号处理过程signal_handler_init()"></a>初始化子进程退出的信号处理过程signal_handler_init()</h4><p>–&gt; signal_handler.cpp</p><pre><code>void signal_handler_init() {    // Create a signalling mechanism for SIGCHLD.    int s[2];    // 创建socket pair套接字    if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, s) == -1) {        ERROR(&quot;socketpair failed: %s\n&quot;, strerror(errno));        exit(1);    }    // 赋值    signal_write_fd = s[0];    signal_read_fd = s[1];    // Write to signal_write_fd if we catch SIGCHLD.    // 当捕获SIGCHLD信号，则写入signal_write_fd    struct sigaction act;    memset(&amp;act, 0, sizeof(act));    act.sa_handler = SIGCHLD_handler;    act.sa_flags = SA_NOCLDSTOP;    sigaction(SIGCHLD, &amp;act, 0);    reap_any_outstanding_children();    // 注册监听处理    register_epoll_handler(signal_read_fd, handle_signal);}static void reap_any_outstanding_children() {    while (wait_for_one_process()) {    }}static bool wait_for_one_process() {    int status;    //等待任意子进程，如果子进程没有退出则返回0，否则返回盖子进程的pid    pid_t pid = TEMP_FAILURE_RETRY(waitpid(-1, &amp;status, WNOHANG));    if (pid == 0) {        return false;    } else if (pid == -1) {        ERROR(&quot;waitpid failed: %s\n&quot;, strerror(errno));        return false;    }    //根据pid查找相应的service    service* svc = service_find_by_pid(pid);    std::string name;    if (svc) {        name = android::base::StringPrintf(&quot;Service &apos;%s&apos; (pid %d)&quot;, svc-&gt;name, pid);    } else {        name = android::base::StringPrintf(&quot;Untracked pid %d&quot;, pid);    }    NOTICE(&quot;%s %s\n&quot;, name.c_str(), DescribeStatus(status).c_str());    if (!svc) {        return true;    }    // TODO: all the code from here down should be a member function on service.    // 当flag为RESTART，且不是ONESHOT时，先kill进程组内的所有的子进程或子线程    if (!(svc-&gt;flags &amp; SVC_ONESHOT) || (svc-&gt;flags &amp; SVC_RESTART)) {        NOTICE(&quot;Service &apos;%s&apos; (pid %d) killing any children in process group\n&quot;, svc-&gt;name, pid);        kill(-pid, SIGKILL);    }    // Remove any sockets we may have created.    // 移除当前服务中所有创建过的socket    for (socketinfo* si = svc-&gt;sockets; si; si = si-&gt;next) {        char tmp[128];        snprintf(tmp, sizeof(tmp), ANDROID_SOCKET_DIR&quot;/%s&quot;, si-&gt;name);        unlink(tmp);    }    // 当flag为EXEC时，释放相应的服务    if (svc-&gt;flags &amp; SVC_EXEC) {        INFO(&quot;SVC_EXEC pid %d finished...\n&quot;, svc-&gt;pid);        waiting_for_exec = false;        list_remove(&amp;svc-&gt;slist);        free(svc-&gt;name);        free(svc);        return true;    }    svc-&gt;pid = 0;    svc-&gt;flags &amp;= (~SVC_RUNNING);    // Oneshot processes go into the disabled state on exit,    // except when manually restarted.    // 对于ONESHOT服务，使其进入disabled状态    if ((svc-&gt;flags &amp; SVC_ONESHOT) &amp;&amp; !(svc-&gt;flags &amp; SVC_RESTART)) {        svc-&gt;flags |= SVC_DISABLED;    }    // Disabled and reset processes do not get restarted automatically.    // 禁用和重置的服务，都不在自动重启    if (svc-&gt;flags &amp; (SVC_DISABLED | SVC_RESET))  {        svc-&gt;NotifyStateChange(&quot;stopped&quot;);        return true;    }    time_t now = gettime();    // 服务在4分钟内重启次数超过4次，则重启进入recovery模式    if ((svc-&gt;flags &amp; SVC_CRITICAL) &amp;&amp; !(svc-&gt;flags &amp; SVC_RESTART)) {        if (svc-&gt;time_crashed + CRITICAL_CRASH_WINDOW &gt;= now) {            if (++svc-&gt;nr_crashed &gt; CRITICAL_CRASH_THRESHOLD) {                ERROR(&quot;critical process &apos;%s&apos; exited %d times in %d minutes; &quot;                      &quot;rebooting into recovery mode\n&quot;, svc-&gt;name,                      CRITICAL_CRASH_THRESHOLD, CRITICAL_CRASH_WINDOW / 60);                android_reboot(ANDROID_RB_RESTART2, 0, &quot;recovery&quot;);                return true;            }        } else {            svc-&gt;time_crashed = now;            svc-&gt;nr_crashed = 1;        }    }    svc-&gt;flags &amp;= (~SVC_RESTART);    svc-&gt;flags |= SVC_RESTARTING;    // Execute all onrestart commands for this service.    // 执行当前service中的所有onstart命令    struct listnode* node;    list_for_each(node, &amp;svc-&gt;onrestart.commands) {        command* cmd = node_to_item(node, struct command, clist);        cmd-&gt;func(cmd-&gt;nargs, cmd-&gt;args);    }    svc-&gt;NotifyStateChange(&quot;restarting&quot;);    return true;}</code></pre><h4 id="加载-prop-属性文件"><a href="#加载-prop-属性文件" class="headerlink" title="加载 *.prop 属性文件"></a>加载 *.prop 属性文件</h4><p>–&gt; property_service.cpp</p><pre><code>void property_load_boot_defaults() {    //加载指定文件路径下的 *.prop 文件    load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT, NULL);}static void load_properties_from_file(const char* filename, const char* filter) {    Timer t;    std::string data;    if (read_file(filename, &amp;data)) {        data.push_back(&apos;\n&apos;);        load_properties(&amp;data[0], filter);    }    NOTICE(&quot;(Loading properties from %s took %.2fs.)\n&quot;, filename, t.duration());}//解析文件到指定数据data结构中static void load_properties(char *data, const char *filter){    char *key, *value, *eol, *sol, *tmp, *fn;    size_t flen = 0;    if (filter) {        flen = strlen(filter);    }    sol = data;    while ((eol = strchr(sol, &apos;\n&apos;))) {        key = sol;        *eol++ = 0;        sol = eol;        while (isspace(*key)) key++;        if (*key == &apos;#&apos;) continue;        tmp = eol - 2;        while ((tmp &gt; key) &amp;&amp; isspace(*tmp)) *tmp-- = 0;        // import节点        if (!strncmp(key, &quot;import &quot;, 7) &amp;&amp; flen == 0) {            fn = key + 7;            while (isspace(*fn)) fn++;            key = strchr(fn, &apos; &apos;);            if (key) {                *key++ = 0;                while (isspace(*key)) key++;            }            // 导入import节点文件，再次解析            load_properties_from_file(fn, key);        } else {            value = strchr(key, &apos;=&apos;);            if (!value) continue;            *value++ = 0;            tmp = value - 2;            while ((tmp &gt; key) &amp;&amp; isspace(*tmp)) *tmp-- = 0;            while (isspace(*value)) value++;            if (flen &gt; 0) {                if (filter[flen - 1] == &apos;*&apos;) {                    if (strncmp(key, filter, flen - 1)) continue;                } else {                    if (strcmp(key, filter)) continue;                }            }            // 设置属性            property_set(key, value);        }    }}</code></pre><h4 id="启动属性服务器（通过sockert通信）"><a href="#启动属性服务器（通过sockert通信）" class="headerlink" title="启动属性服务器（通过sockert通信）"></a>启动属性服务器（通过sockert通信）</h4><p>–&gt; property_service.cpp</p><pre><code>// 开启属性服务void start_property_service() {    // 创建seocker套接字    property_set_fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,                                    0666, 0, 0, NULL);    if (property_set_fd == -1) {        ERROR(&quot;start_property_service socket creation failed: %s\n&quot;, strerror(errno));        exit(1);    }    // 加入监听    listen(property_set_fd, 8);    // 注册监听    register_epoll_handler(property_set_fd, handle_property_set_fd);}</code></pre><p>用户可以通过串口开启、结束指定服务，通过命令setprop更改系统属性值，三方app也可以通过指定的api更改系统属性（权限限制），其到底层都是通过socket机制，通过init中的handle_property_***()方法实现。其流程模型如下：</p><img src="/FuckCode/2018/06/04/源码分析之init进程/init_prop.png" title="init_prop.png"><h4 id="解析-rc-脚本文件"><a href="#解析-rc-脚本文件" class="headerlink" title="解析 *.rc 脚本文件"></a>解析 *.rc 脚本文件</h4><img src="/FuckCode/2018/06/04/源码分析之init进程/init.rc_parse_config_file.png" title="init.rc_parse_config_file.png"><p>–&gt; init_parser.cpp</p><pre><code>// 解析指定路径下文件int init_parse_config_file(const char* path) {    INFO(&quot;Parsing %s...\n&quot;, path);    Timer t;    std::string data;    // 读取文件信息到data中    if (!read_file(path, &amp;data)) {        return -1;    }    data.push_back(&apos;\n&apos;); // TODO: fix parse_config.    parse_config(path, data);    dump_parser_state();    // MStar Android Patch Begin    INFO(&quot;(Parsing %s took %.2fs.)\n&quot;, path, t.duration());    // MStar Android Patch End    return 0;}// 解析脚本文件信息static void parse_config(const char *fn, const std::string&amp; data){    struct listnode import_list;    struct listnode *node;    char *args[INIT_PARSER_MAXARGS];    int nargs = 0;    parse_state state;    state.filename = fn;    state.line = 0;    state.ptr = strdup(data.c_str());  // TODO: fix this code!    state.nexttoken = 0;    state.parse_line = parse_line_no_op;    list_init(&amp;import_list);    state.priv = &amp;import_list;    for (;;) {        switch (next_token(&amp;state)) {        case T_EOF:    // 导入行            state.parse_line(&amp;state, 0, 0);            goto parser_done;        case T_NEWLINE:    // 命令行            state.line++;            if (nargs) {                int kw = lookup_keyword(args[0]);                if (kw_is(kw, SECTION)) {                    state.parse_line(&amp;state, 0, 0);                    parse_new_section(&amp;state, kw, nargs, args);                } else {                    state.parse_line(&amp;state, nargs, args);                }                nargs = 0;            }            break;        case T_TEXT:            if (nargs &lt; INIT_PARSER_MAXARGS) {                args[nargs++] = state.text;            }            break;        }    }parser_done:    list_for_each(node, &amp;import_list) {         struct import *import = node_to_item(node, struct import, list);         int ret;         // 解析导入文件         ret = init_parse_config_file(import-&gt;filename);         if (ret)             ERROR(&quot;could not import file &apos;%s&apos; from &apos;%s&apos;\n&quot;,                   import-&gt;filename, fn);    }}int next_token(struct parse_state *state){    char *x = state-&gt;ptr;    char *s;    if (state-&gt;nexttoken) {        int t = state-&gt;nexttoken;        state-&gt;nexttoken = 0;        return t;    }    for (;;) {        switch (*x) {        case 0:            state-&gt;ptr = x;            return T_EOF;        case &apos;\n&apos;:            x++;            state-&gt;ptr = x;            return T_NEWLINE;        case &apos; &apos;:        case &apos;\t&apos;:        case &apos;\r&apos;:            x++;            continue;        case &apos;#&apos;:            while (*x &amp;&amp; (*x != &apos;\n&apos;)) x++;            if (*x == &apos;\n&apos;) {                state-&gt;ptr = x+1;                return T_NEWLINE;            } else {                state-&gt;ptr = x;                return T_EOF;            }        default:            goto text;        }    }textdone:    state-&gt;ptr = x;    *s = 0;    return T_TEXT;text:    state-&gt;text = s = x;textresume:    for (;;) {        switch (*x) {        case 0:            goto textdone;        case &apos; &apos;:        case &apos;\t&apos;:        case &apos;\r&apos;:            x++;            goto textdone;        case &apos;\n&apos;:            state-&gt;nexttoken = T_NEWLINE;            x++;            goto textdone;        case &apos;&quot;&apos;:            x++;            for (;;) {                switch (*x) {                case 0:                        /* unterminated quoted thing */                    state-&gt;ptr = x;                    return T_EOF;                case &apos;&quot;&apos;:                    x++;                    goto textresume;                default:                    *s++ = *x++;                }            }            break;        case &apos;\\&apos;:            x++;            switch (*x) {            case 0:                goto textdone;            case &apos;n&apos;:                *s++ = &apos;\n&apos;;                break;            case &apos;r&apos;:                *s++ = &apos;\r&apos;;                break;            case &apos;t&apos;:                *s++ = &apos;\t&apos;;                break;            case &apos;\\&apos;:                *s++ = &apos;\\&apos;;                break;            case &apos;\r&apos;:                    /* \ &lt;cr&gt; &lt;lf&gt; -&gt; line continuation */                if (x[1] != &apos;\n&apos;) {                    x++;                    continue;                }            case &apos;\n&apos;:                    /* \ &lt;lf&gt; -&gt; line continuation */                state-&gt;line++;                x++;                    /* eat any extra whitespace */                while((*x == &apos; &apos;) || (*x == &apos;\t&apos;)) x++;                continue;            default:                    /* unknown escape -- just copy */                *s++ = *x++;            }            continue;        default:            *s++ = *x++;        }    }    return T_EOF;}// 根据命令匹配相应的操作// 通过宏定义匹配相应的操作指令static int lookup_keyword(const char *s){    switch (*s++) {    case &apos;b&apos;:        if (!strcmp(s, &quot;ootchart_init&quot;)) return K_bootchart_init;        break;    case &apos;c&apos;:        if (!strcmp(s, &quot;opy&quot;)) return K_copy;        if (!strcmp(s, &quot;lass&quot;)) return K_class;        if (!strcmp(s, &quot;lass_start&quot;)) return K_class_start;        if (!strcmp(s, &quot;lass_stop&quot;)) return K_class_stop;        if (!strcmp(s, &quot;lass_reset&quot;)) return K_class_reset;        if (!strcmp(s, &quot;onsole&quot;)) return K_console;        if (!strcmp(s, &quot;hown&quot;)) return K_chown;        if (!strcmp(s, &quot;hmod&quot;)) return K_chmod;        if (!strcmp(s, &quot;ritical&quot;)) return K_critical;        break;    case &apos;d&apos;:        if (!strcmp(s, &quot;isabled&quot;)) return K_disabled;        if (!strcmp(s, &quot;omainname&quot;)) return K_domainname;        break;    case &apos;e&apos;:        if (!strcmp(s, &quot;nable&quot;)) return K_enable;        if (!strcmp(s, &quot;xec&quot;)) return K_exec;        if (!strcmp(s, &quot;xport&quot;)) return K_export;        break;    case &apos;g&apos;:        if (!strcmp(s, &quot;roup&quot;)) return K_group;        break;    case &apos;h&apos;:        if (!strcmp(s, &quot;ostname&quot;)) return K_hostname;        break;    case &apos;i&apos;:        if (!strcmp(s, &quot;oprio&quot;)) return K_ioprio;        if (!strcmp(s, &quot;fup&quot;)) return K_ifup;        if (!strcmp(s, &quot;nsmod&quot;)) return K_insmod;        if (!strcmp(s, &quot;mport&quot;)) return K_import;        if (!strcmp(s, &quot;nstallkey&quot;)) return K_installkey;        break;    case &apos;k&apos;:        if (!strcmp(s, &quot;eycodes&quot;)) return K_keycodes;        break;    case &apos;l&apos;:        if (!strcmp(s, &quot;oglevel&quot;)) return K_loglevel;        if (!strcmp(s, &quot;oad_persist_props&quot;)) return K_load_persist_props;        if (!strcmp(s, &quot;oad_all_props&quot;)) return K_load_all_props;        break;    case &apos;m&apos;:        if (!strcmp(s, &quot;kdir&quot;)) return K_mkdir;        if (!strcmp(s, &quot;ount_all&quot;)) return K_mount_all;        if (!strcmp(s, &quot;ount&quot;)) return K_mount;        break;    case &apos;o&apos;:        if (!strcmp(s, &quot;n&quot;)) return K_on;        if (!strcmp(s, &quot;neshot&quot;)) return K_oneshot;        if (!strcmp(s, &quot;nrestart&quot;)) return K_onrestart;        break;    case &apos;p&apos;:        if (!strcmp(s, &quot;owerctl&quot;)) return K_powerctl;        break;    case &apos;r&apos;:        if (!strcmp(s, &quot;estart&quot;)) return K_restart;        if (!strcmp(s, &quot;estorecon&quot;)) return K_restorecon;        if (!strcmp(s, &quot;estorecon_recursive&quot;)) return K_restorecon_recursive;        if (!strcmp(s, &quot;mdir&quot;)) return K_rmdir;        if (!strcmp(s, &quot;m&quot;)) return K_rm;        break;    case &apos;s&apos;:        if (!strcmp(s, &quot;eclabel&quot;)) return K_seclabel;        if (!strcmp(s, &quot;ervice&quot;)) return K_service;        if (!strcmp(s, &quot;etenv&quot;)) return K_setenv;        if (!strcmp(s, &quot;etprop&quot;)) return K_setprop;        if (!strcmp(s, &quot;etrlimit&quot;)) return K_setrlimit;        if (!strcmp(s, &quot;ocket&quot;)) return K_socket;        if (!strcmp(s, &quot;tart&quot;)) return K_start;        if (!strcmp(s, &quot;top&quot;)) return K_stop;        if (!strcmp(s, &quot;wapon_all&quot;)) return K_swapon_all;        if (!strcmp(s, &quot;ymlink&quot;)) return K_symlink;        if (!strcmp(s, &quot;ysclktz&quot;)) return K_sysclktz;        break;    case &apos;t&apos;:        if (!strcmp(s, &quot;rigger&quot;)) return K_trigger;        break;    case &apos;u&apos;:        if (!strcmp(s, &quot;ser&quot;)) return K_user;        break;    case &apos;v&apos;:        if (!strcmp(s, &quot;erity_load_state&quot;)) return K_verity_load_state;        if (!strcmp(s, &quot;erity_update_state&quot;)) return K_verity_update_state;        break;    case &apos;w&apos;:        if (!strcmp(s, &quot;rite&quot;)) return K_write;        if (!strcmp(s, &quot;ritepid&quot;)) return K_writepid;        if (!strcmp(s, &quot;ait&quot;)) return K_wait;        break;    }    return K_UNKNOWN;}</code></pre><h4 id="根据脚本文件不同的标签分类解析"><a href="#根据脚本文件不同的标签分类解析" class="headerlink" title="根据脚本文件不同的标签分类解析"></a>根据脚本文件不同的标签分类解析</h4><img src="/FuckCode/2018/06/04/源码分析之init进程/init_shijianjiegou.png" title="init_shijianjiegou.png"><pre><code>static void parse_new_section(struct parse_state *state, int kw,                       int nargs, char **args){    printf(&quot;[ %s %s ]\n&quot;, args[0],           nargs &gt; 1 ? args[1] : &quot;&quot;);    switch(kw) {    // service 标签    case K_service:        state-&gt;context = parse_service(state, nargs, args);        if (state-&gt;context) {            state-&gt;parse_line = parse_line_service;            return;        }        break;    // on 标签    case K_on:        state-&gt;context = parse_action(state, nargs, args);        if (state-&gt;context) {            state-&gt;parse_line = parse_line_action;            return;        }        break;    // import 标签    case K_import:        parse_import(state, nargs, args);        break;    }    state-&gt;parse_line = parse_line_no_op;}</code></pre><h4 id="通过不同标签分类解析并加入对应的链表"><a href="#通过不同标签分类解析并加入对应的链表" class="headerlink" title="通过不同标签分类解析并加入对应的链表"></a>通过不同标签分类解析并加入对应的链表</h4><img src="/FuckCode/2018/06/04/源码分析之init进程/init_shijianliebiao.png" title="init_shijianliebiao.png"><pre><code>    // 解析脚本中的service节点加入链表    static void *parse_service(struct parse_state *state, int nargs, char **args)    {        if (nargs &lt; 3) {            parse_error(state, &quot;services must have a name and a program\n&quot;);            return 0;        }        if (!valid_name(args[1])) {            parse_error(state, &quot;invalid service name &apos;%s&apos;\n&quot;, args[1]);            return 0;        }        service* svc = (service*) service_find_by_name(args[1]);        if (svc) {            parse_error(state, &quot;ignored duplicate definition of service &apos;%s&apos;\n&quot;, args[1]);            return 0;        }        nargs -= 2;        svc = (service*) calloc(1, sizeof(*svc) + sizeof(char*) * nargs);        if (!svc) {            parse_error(state, &quot;out of memory\n&quot;);            return 0;        }        svc-&gt;name = strdup(args[1]);        svc-&gt;classname = &quot;default&quot;;        memcpy(svc-&gt;args, args + 2, sizeof(char*) * nargs);        trigger* cur_trigger = (trigger*) calloc(1, sizeof(*cur_trigger));        svc-&gt;args[nargs] = 0;        svc-&gt;nargs = nargs;        list_init(&amp;svc-&gt;onrestart.triggers);        cur_trigger-&gt;name = &quot;onrestart&quot;;        list_add_tail(&amp;svc-&gt;onrestart.triggers, &amp;cur_trigger-&gt;nlist);        list_init(&amp;svc-&gt;onrestart.commands);        list_add_tail(&amp;service_list, &amp;svc-&gt;slist);        return svc;    }        // 解析service的具体信息并加入链表        static void parse_line_service(struct parse_state *state, int nargs, char **args)        {            struct service *svc = (service*) state-&gt;context;            struct command *cmd;            int i, kw, kw_nargs;            if (nargs == 0) {                return;            }            svc-&gt;ioprio_class = IoSchedClass_NONE;            kw = lookup_keyword(args[0]);            switch (kw) {            case K_class:                if (nargs != 2) {                    parse_error(state, &quot;class option requires a classname\n&quot;);                } else {                    svc-&gt;classname = args[1];                }                break;            case K_console:                svc-&gt;flags |= SVC_CONSOLE;                break;            case K_disabled:                svc-&gt;flags |= SVC_DISABLED;                svc-&gt;flags |= SVC_RC_DISABLED;                break;            case K_ioprio:                if (nargs != 3) {                    parse_error(state, &quot;ioprio optin usage: ioprio &lt;rt|be|idle&gt; &lt;ioprio 0-7&gt;\n&quot;);                } else {                    svc-&gt;ioprio_pri = strtoul(args[2], 0, 8);                    if (svc-&gt;ioprio_pri &lt; 0 || svc-&gt;ioprio_pri &gt; 7) {                        parse_error(state, &quot;priority value must be range 0 - 7\n&quot;);                        break;                    }                    if (!strcmp(args[1], &quot;rt&quot;)) {                        svc-&gt;ioprio_class = IoSchedClass_RT;                    } else if (!strcmp(args[1], &quot;be&quot;)) {                        svc-&gt;ioprio_class = IoSchedClass_BE;                    } else if (!strcmp(args[1], &quot;idle&quot;)) {                        svc-&gt;ioprio_class = IoSchedClass_IDLE;                    } else {                        parse_error(state, &quot;ioprio option usage: ioprio &lt;rt|be|idle&gt; &lt;0-7&gt;\n&quot;);                    }                }                break;            case K_group:                if (nargs &lt; 2) {                    parse_error(state, &quot;group option requires a group id\n&quot;);                } else if (nargs &gt; NR_SVC_SUPP_GIDS + 2) {                    parse_error(state, &quot;group option accepts at most %d supp. groups\n&quot;,                                NR_SVC_SUPP_GIDS);                } else {                    int n;                    svc-&gt;gid = decode_uid(args[1]);                    for (n = 2; n &lt; nargs; n++) {                        svc-&gt;supp_gids[n-2] = decode_uid(args[n]);                    }                    svc-&gt;nr_supp_gids = n - 2;                }                break;            case K_keycodes:                if (nargs &lt; 2) {                    parse_error(state, &quot;keycodes option requires atleast one keycode\n&quot;);                } else {                    svc-&gt;keycodes = (int*) malloc((nargs - 1) * sizeof(svc-&gt;keycodes[0]));                    if (!svc-&gt;keycodes) {                        parse_error(state, &quot;could not allocate keycodes\n&quot;);                    } else {                        svc-&gt;nkeycodes = nargs - 1;                        for (i = 1; i &lt; nargs; i++) {                            svc-&gt;keycodes[i - 1] = atoi(args[i]);                        }                    }                }                break;            case K_oneshot:                svc-&gt;flags |= SVC_ONESHOT;                break;            case K_onrestart:                nargs--;                args++;                kw = lookup_keyword(args[0]);                if (!kw_is(kw, COMMAND)) {                    parse_error(state, &quot;invalid command &apos;%s&apos;\n&quot;, args[0]);                    break;                }                kw_nargs = kw_nargs(kw);                if (nargs &lt; kw_nargs) {                    parse_error(state, &quot;%s requires %d %s\n&quot;, args[0], kw_nargs - 1,                        kw_nargs &gt; 2 ? &quot;arguments&quot; : &quot;argument&quot;);                    break;                }                cmd = (command*) malloc(sizeof(*cmd) + sizeof(char*) * nargs);                cmd-&gt;func = kw_func(kw);                cmd-&gt;nargs = nargs;                memcpy(cmd-&gt;args, args, sizeof(char*) * nargs);                list_add_tail(&amp;svc-&gt;onrestart.commands, &amp;cmd-&gt;clist);                break;            case K_critical:                svc-&gt;flags |= SVC_CRITICAL;                break;            case K_setenv: { /* name value */                if (nargs &lt; 3) {                    parse_error(state, &quot;setenv option requires name and value arguments\n&quot;);                    break;                }                svcenvinfo* ei = (svcenvinfo*) calloc(1, sizeof(*ei));                if (!ei) {                    parse_error(state, &quot;out of memory\n&quot;);                    break;                }                ei-&gt;name = args[1];                ei-&gt;value = args[2];                ei-&gt;next = svc-&gt;envvars;                svc-&gt;envvars = ei;                break;            }            case K_socket: {/* name type perm [ uid gid context ] */                if (nargs &lt; 4) {                    parse_error(state, &quot;socket option requires name, type, perm arguments\n&quot;);                    break;                }                if (strcmp(args[2],&quot;dgram&quot;) &amp;&amp; strcmp(args[2],&quot;stream&quot;)                        &amp;&amp; strcmp(args[2],&quot;seqpacket&quot;)) {                    parse_error(state, &quot;socket type must be &apos;dgram&apos;, &apos;stream&apos; or &apos;seqpacket&apos;\n&quot;);                    break;                }                socketinfo* si = (socketinfo*) calloc(1, sizeof(*si));                if (!si) {                    parse_error(state, &quot;out of memory\n&quot;);                    break;                }                si-&gt;name = args[1];                si-&gt;type = args[2];                si-&gt;perm = strtoul(args[3], 0, 8);                if (nargs &gt; 4)                    si-&gt;uid = decode_uid(args[4]);                if (nargs &gt; 5)                    si-&gt;gid = decode_uid(args[5]);                if (nargs &gt; 6)                    si-&gt;socketcon = args[6];                si-&gt;next = svc-&gt;sockets;                svc-&gt;sockets = si;                break;            }            case K_user:                if (nargs != 2) {                    parse_error(state, &quot;user option requires a user id\n&quot;);                } else {                    svc-&gt;uid = decode_uid(args[1]);                }                break;            case K_seclabel:                if (nargs != 2) {                    parse_error(state, &quot;seclabel option requires a label string\n&quot;);                } else {                    svc-&gt;seclabel = args[1];                }                break;            case K_writepid:                if (nargs &lt; 2) {                    parse_error(state, &quot;writepid option requires at least one filename\n&quot;);                    break;                }                svc-&gt;writepid_files_ = new std::vector&lt;std::string&gt;;                for (int i = 1; i &lt; nargs; ++i) {                    svc-&gt;writepid_files_-&gt;push_back(args[i]);                }                break;            default:                parse_error(state, &quot;invalid option &apos;%s&apos;\n&quot;, args[0]);            }        }        // 解析脚本中的action节点并加入链表中        static void *parse_action(struct parse_state *state, int nargs, char **args)        {            struct trigger *cur_trigger;            int i;            if (nargs &lt; 2) {                parse_error(state, &quot;actions must have a trigger\n&quot;);                return 0;            }            action* act = (action*) calloc(1, sizeof(*act));            list_init(&amp;act-&gt;triggers);            for (i = 1; i &lt; nargs; i++) {                if (!(i % 2)) {                    if (strcmp(args[i], &quot;&amp;&amp;&quot;)) {                        struct listnode *node;                        struct listnode *node2;                        parse_error(state, &quot;&amp; is the only symbol allowed to concatenate actions\n&quot;);                        list_for_each_safe(node, node2, &amp;act-&gt;triggers) {                            struct trigger *trigger = node_to_item(node, struct trigger, nlist);                            free(trigger);                        }                        free(act);                        return 0;                    } else                        continue;                }                cur_trigger = (trigger*) calloc(1, sizeof(*cur_trigger));                cur_trigger-&gt;name = args[i];                list_add_tail(&amp;act-&gt;triggers, &amp;cur_trigger-&gt;nlist);            }            list_init(&amp;act-&gt;commands);            list_init(&amp;act-&gt;qlist);            list_add_tail(&amp;action_list, &amp;act-&gt;alist);                /* XXX add to hash */            return act;        }    // 解析脚本中action的具体信息，加入action链表中    static void parse_line_action(struct parse_state* state, int nargs, char **args)    {        struct action *act = (action*) state-&gt;context;        int kw, n;        if (nargs == 0) {            return;        }        kw = lookup_keyword(args[0]);        if (!kw_is(kw, COMMAND)) {            parse_error(state, &quot;invalid command &apos;%s&apos;\n&quot;, args[0]);            return;        }        n = kw_nargs(kw);        if (nargs &lt; n) {            parse_error(state, &quot;%s requires %d %s\n&quot;, args[0], n - 1,                n &gt; 2 ? &quot;arguments&quot; : &quot;argument&quot;);            return;        }        command* cmd = (command*) malloc(sizeof(*cmd) + sizeof(char*) * nargs);        cmd-&gt;func = kw_func(kw);        cmd-&gt;line = state-&gt;line;        cmd-&gt;filename = state-&gt;filename;        cmd-&gt;nargs = nargs;        memcpy(cmd-&gt;args, args, sizeof(char*) * nargs);        list_add_tail(&amp;act-&gt;commands, &amp;cmd-&gt;clist);    }    static void parse_import(struct parse_state *state, int nargs, char **args)    {        struct listnode *import_list = (listnode*) state-&gt;priv;        char conf_file[PATH_MAX];        int ret;        if (nargs != 2) {            ERROR(&quot;single argument needed for import\n&quot;);            return;        }        ret = expand_props(conf_file, args[1], sizeof(conf_file));        if (ret) {            ERROR(&quot;error while handling import on line &apos;%d&apos; in &apos;%s&apos;\n&quot;,                  state-&gt;line, state-&gt;filename);            return;        }        struct import* import = (struct import*) calloc(1, sizeof(struct import));        import-&gt;filename = strdup(conf_file);        list_add_tail(import_list, &amp;import-&gt;list);        INFO(&quot;Added &apos;%s&apos; to import list\n&quot;, import-&gt;filename);    }{% asset_img jiaobenfenxijieguo.png jiaobenfenxijieguo.png %}</code></pre><h4 id="执行脚本中指定触发器的操作"><a href="#执行脚本中指定触发器的操作" class="headerlink" title="执行脚本中指定触发器的操作"></a>执行脚本中指定触发器的操作</h4><p>–&gt; init.cpp</p><pre><code>// 找到解析列表的action并运行void action_for_each_trigger(const char *trigger,                             void (*func)(struct action *act)){    struct listnode *node, *node2;    struct action *act;    struct trigger *cur_trigger;    // 找到脚本文件中指定的node节点    list_for_each(node, &amp;action_list) {        // 获取指定节点的action        act = node_to_item(node, struct action, alist);        // 执行节点下fun()        list_for_each(node2, &amp;act-&gt;triggers) {            cur_trigger = node_to_item(node2, struct trigger, nlist);            if (!strcmp(cur_trigger-&gt;name, trigger)) {                func(act);            }        }    }}</code></pre><p>通过指定的触发器，遍历解析的rc脚本文件相应command，执行具体的操作，流程图如下：</p><img src="/FuckCode/2018/06/04/源码分析之init进程/zhenglishijianliebiao.png" title="zhenglishijianliebiao.png"><h4 id="构建事件，并加入队列中"><a href="#构建事件，并加入队列中" class="headerlink" title="构建事件，并加入队列中"></a>构建事件，并加入队列中</h4><p>–&gt; init.cpp</p><pre><code>// 构建事件，并加入队列中void queue_builtin_action(int (*func)(int nargs, char **args), const char *name){    action* act = (action*) calloc(1, sizeof(*act));    trigger* cur_trigger = (trigger*) calloc(1, sizeof(*cur_trigger));    cur_trigger-&gt;name = name;    list_init(&amp;act-&gt;triggers);    list_add_tail(&amp;act-&gt;triggers, &amp;cur_trigger-&gt;nlist);    list_init(&amp;act-&gt;commands);    list_init(&amp;act-&gt;qlist);    command* cmd = (command*) calloc(1, sizeof(*cmd));    cmd-&gt;func = func;    cmd-&gt;args[0] = const_cast&lt;char*&gt;(name);    cmd-&gt;nargs = 1;    list_add_tail(&amp;act-&gt;commands, &amp;cmd-&gt;clist);    list_add_tail(&amp;action_list, &amp;act-&gt;alist);    action_add_queue_tail(act);}</code></pre><p>根据构建自定事件，并加入对列中，通指定触发器来触发操作，增加灵活性，如下图所示流程：</p><img src="/FuckCode/2018/06/04/源码分析之init进程/init_goujianshijian.png" title="init_goujianshijian.png"><h4 id="开启服务（死循环）"><a href="#开启服务（死循环）" class="headerlink" title="开启服务（死循环）"></a>开启服务（死循环）</h4><p>–&gt; init.cpp</p><pre><code>// 执行命令void execute_one_command() {    Timer t;    char cmd_str[256] = &quot;&quot;;    char name_str[256] = &quot;&quot;;    if (!cur_action || !cur_command || is_last_command(cur_action, cur_command)) {        //    获取链表的第一个action        cur_action = action_remove_queue_head();        cur_command = NULL;        if (!cur_action) {            return;        }        build_triggers_string(name_str, sizeof(name_str), cur_action);        INFO(&quot;processing action %p (%s)\n&quot;, cur_action, name_str);        // 获取第一条command命令        cur_command = get_first_command(cur_action);    } else {        // 下一跳command命令        cur_command = get_next_command(cur_action, cur_command);    }    if (!cur_command) {        return;    }    // 调用相应command的fun() 方法    int result = cur_command-&gt;func(cur_command-&gt;nargs, cur_command-&gt;args);    if (klog_get_level() &gt;= KLOG_INFO_LEVEL) {        for (int i = 0; i &lt; cur_command-&gt;nargs; i++) {            strlcat(cmd_str, cur_command-&gt;args[i], sizeof(cmd_str));            if (i &lt; cur_command-&gt;nargs - 1) {                strlcat(cmd_str, &quot; &quot;, sizeof(cmd_str));            }        }        char source[256];        if (cur_command-&gt;filename) {            snprintf(source, sizeof(source), &quot; (%s:%d)&quot;, cur_command-&gt;filename, cur_command-&gt;line);        } else {            *source = &apos;\0&apos;;        }        INFO(&quot;Command &apos;%s&apos; action=%s%s returned %d took %.2fs\n&quot;,             cmd_str, cur_action ? name_str : &quot;&quot;, source, result, t.duration());    }}// 返回头部action并移除队列struct action *action_remove_queue_head(void){    if (list_empty(&amp;action_queue)) {        return 0;    } else {        struct listnode *node = list_head(&amp;action_queue);        struct action *act = node_to_item(node, struct action, qlist);        list_remove(node);        list_init(node);        return act;    }}</code></pre><p>如下所示，是init进程执行开启服务的具体流程：</p><ol><li>首先从action_queue中查找到cmd</li><li>根据cmd对应的宏定义KEYWORD</li><li>执行对应的func方法</li><li>例如service，遍历解析的services列表，找到指定的service</li><li>启动指定的service服务</li></ol><img src="/FuckCode/2018/06/04/源码分析之init进程/init_start.png" title="init_start.png"><h4 id="守护进程，重启服务"><a href="#守护进程，重启服务" class="headerlink" title="守护进程，重启服务"></a>守护进程，重启服务</h4><p>–&gt; init.cpp</p><pre><code>// 重启服务static void restart_processes(){    process_needs_restart = 0;    // 根据flag=SVC_RESTARTING，有选择的重启    service_for_each_flags(SVC_RESTARTING,                           restart_service_if_needed);}// 根据服务名称找到解析列表中对应的服务并启动起来void service_for_each_class(const char *classname,                            void (*func)(struct service *svc)){    struct listnode *node;    struct service *svc;    // 找到列表中对应服务的节点    list_for_each(node, &amp;service_list) {        svc = node_to_item(node, struct service, slist);        if (!strcmp(svc-&gt;classname, classname)) {            // 启动服务            func(svc);        }    }}</code></pre><img src="/FuckCode/2018/06/04/源码分析之init进程/init_shouhujincheng1.png" title="init_shouhujincheng1.png"><ol><li>内核通过fork产生父子两个进程，之间通过socket产生通信</li><li>init进程死循环等待socket内的消息</li><li>如果出现服务死掉，根据进程pid，找到脚本解析文件中对应的service</li><li>启动找到的service服务（是否起启动取决service中具体的约束内容）</li></ol><p>具体的消息传递流程如下：</p><img src="/FuckCode/2018/06/04/源码分析之init进程/init_shouhujincheng2.png" title="init_shouhujincheng2.png"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>init 脚本中将服务统一归纳起来，由 init.cpp 统一解析，开启服务并守护，实现了两者之间的解耦</li><li>通过import导入相关脚本文件，初始化属性服务，开启socket通信处理，解析脚本文件，开启守护进程服务，死循环等待socket通信</li><li>一旦有服务异常死掉，便会通过socket通信机制，依据pid找到之前解析的脚本内容，重启服务</li><li>可以适当在脚本中添加代码实现自定义开机启动服务</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>屏参修改</title>
      <link href="/FuckCode/2018/05/31/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8B55%E5%AF%B8%E5%8F%8C%E5%B1%8F%E9%95%9C%E5%83%8F%E4%BF%AE%E6%94%B9%E5%8D%95%E5%B1%8F/"/>
      <url>/FuckCode/2018/05/31/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8B55%E5%AF%B8%E5%8F%8C%E5%B1%8F%E9%95%9C%E5%83%8F%E4%BF%AE%E6%94%B9%E5%8D%95%E5%B1%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="55寸双屏修改单屏"><a href="#55寸双屏修改单屏" class="headerlink" title="55寸双屏修改单屏"></a>55寸双屏修改单屏</h3><ul><li><p>管理员模式下,重挂载,修改文件读写权限</p><pre><code>mount -o remount,rw /tvconfig</code></pre></li><li><p>进入指定目录下,打开指定文件修改</p><ol><li><p>cd tvconfig/config/panel/</p></li><li><p>busybox vi UD_VB1_8LANE.ini</p></li><li><p>将参数m_bPanelDualPort=0改为1</p><pre><code>[panel]m_pPanelName            =   UD_VB1_8LANE;############################       Panel output      ############################m_bPanelDither          =   0;m_ePanelLinkType        =   10;#LINK_LVDS;m_ePanelLinkExtType     =   51;#apiPNL.h -&gt; APIPNL_LINK_EXT_TYPEm_bPanelDualPort        =   1;m_bPanelSwapPort        =   0;...</code></pre></li><li><p>保存退出</p><pre><code>:wq</code></pre></li></ol></li></ul><ul><li><p>重启进入mboot修改环境参数并重启</p><ol><li><p>reboot</p></li><li><p>setenv db_table 0</p></li><li><p>saveenv</p></li><li><p>reset</p></li></ol></li><li><p>源码对应位置</p><pre><code>vendor/mstar/supernova/projects/board/mooney/serials/MST117B_10AWT_16323_TVOS_DTMB/model</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
            <tag> 屏参 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码分析之init.rc脚本</title>
      <link href="/FuckCode/2018/05/22/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Binit-rc%E8%84%9A%E6%9C%AC/"/>
      <url>/FuckCode/2018/05/22/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Binit-rc%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p><strong>安卓系统的开机，是由kernel内核引导系统的第一个init进程开始的，而控制init进程的执行则是由脚本文件inti.rc来控制的，为什么还要对init进程进行控制了，下面我们来具体了解一下</strong></p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>init.rc文件是安卓系统内核kernel启动后，进入第一个程序init（进程id始终为1）需要解析的文件。</p><ul><li><p>此文件由语句组成，主要包括了四种类型的语句:</p><pre><code>Action,Commands,Services,Options.</code></pre></li><li><p>rc文件语法是以行尾单位，以空格间隔的语法，以#开始代表注释行</p></li></ul><h2 id="1-Action"><a href="#1-Action" class="headerlink" title="1.Action"></a>1.Action</h2><p>动作表示了一组命令(commands)组成。动作包括一个触发器，决定了何时运行这个动作。<br>当触发器的条件满足时，这个动作会被增加到已被运行的队列尾。<br>假设此动作在队列中已经存在，那么它将不会运行。<br>通过trigger，即以 on 开头的语句，决定何时执行相应的service。</p><ul><li>on early-init; 在初始化早期阶段触发；</li><li>on init; 在初始化阶段触发；</li><li>on late-init; 在初始化晚期阶段触发；</li><li>on boot/charger： 当系统启动/充电时触发，还包含其他情况；</li><li><p>on property:<key>=<value>: 当属性值满足条件时触发；</value></key></p></li><li><p>示例：</p><pre><code>on early-init    # Set init and its forked children&apos;s oom_adj.    write /proc/1/oom_score_adj -1000    # Set the security context of /adb_keys if present.    restorecon /adb_keys    start ueventd</code></pre></li></ul><p>触发器(trigger)：用来描写叙述一个触发条件，当这个触发条件满足时能够运行动作。</p><ul><li>boot     当init程序运行，并加载/init.conf文件时触发.</li><li><name>=<value>     当属性名相应的值设置为指定值时触发.</value></name></li><li>device-added-<path>     当加入设备时触发.</path></li><li>device-removed-<path>     当设备移除时触发.</path></li><li>service-exited-<name>     当指定的服务退出时触发.</name></li></ul><p>系统是如何调用这个触发器的呢？<br>在/system/core/init/init.cpp文件的main方法中有如下语句：</p><pre><code>...//解析init.rcinit_parse_config_file(&quot;/init.rc&quot;);//执行rc文件中触发器为 on early-init 的语句执行action_for_each_trigger(&quot;early-init&quot;, action_add_queue_tail);...</code></pre><h2 id="2-Command"><a href="#2-Command" class="headerlink" title="2.Command"></a>2.Command</h2><p>常用命令如下：</p><ul><li>class_start &lt;service_class_name&gt;： 启动属于同一个class的所有服务；</li><li>start &lt;service_name&gt;： 启动指定的服务，若已启动则跳过；</li><li>stop &lt;service_name&gt;： 停止正在运行的服务</li><li>setprop <name> <value>：设置属性值</value></name></li><li>mkdir <path>：创建指定目录</path></li><li>symlink <target> &lt;sym_link&gt;： 创建连接到<target>的&lt;sym_link&gt;符号链接；</target></target></li><li>write <path> <string>： 向文件path中写入字符串；</string></path></li><li>exec： fork并执行，会阻塞init进程直到程序完毕；</li><li>exprot <name> <name>：设定环境变量；</name></name></li><li>loglevel <level>：设置log级别；</level></li><li>ifup <interface>：使指定的网络接口”上线”,相当激活指定的网络接口；</interface></li><li>hostname <name>：设置主机名；</name></li><li>insmod <path>：安装模块到指定路径；</path></li><li>trigger <event>：触发事件或服务</event></li></ul><p>示例：</p><pre><code>on boot    # basic network init    ifup lo    hostname localhost    domainname localdomain    # set RLIMIT_NICE to allow priorities from 19 to -20    setrlimit 13 40 40    ...    write /proc/sys/vm/overcommit_memory 1    write /proc/sys/vm/min_free_order_shift 4    chown root system /sys/module/lowmemorykiller/parameters/adj    ...    # Tweak background writeout    write /proc/sys/vm/dirty_expire_centisecs 200    write /proc/sys/vm/dirty_background_ratio  5    # Permissions for System Server and daemons.    chown radio system /sys/android_power/state    ...    chown root radio /proc/cmdline    # Define default initial receive window size in segments.    setprop net.tcp.default_init_rwnd 60    class_start core    //启动core class</code></pre><h2 id="3-Service"><a href="#3-Service" class="headerlink" title="3.Service"></a>3.Service</h2><p>服务Service，以 service 开头，由init进程启动，一般运行于另外一个init的子进程，所以启动service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service，在启动时会通过fork方式生成子进程</p><p>示例如下：</p><pre><code>service bootanim /system/bin/bootanimationclass coreuser graphicsgroup graphics audiodisabledoneshot</code></pre><p>service bootanim /system/bin/bootanimation代表的是服务名为bootanim，服务的路径，也就是服务执行操作时运行/system/bin/bootanim</p><h2 id="4-Option"><a href="#4-Option" class="headerlink" title="4.Option"></a>4.Option</h2><p>Options是Services的可选项，与service配合使用，是用来改动服务的。它们影响怎样及何时执行这个服务</p><ul><li>disabled: 不随class自动启动，只有根据service名才启动；</li><li>oneshot: service退出后不再重启；</li><li>user/group： 设置执行服务的用户/用户组，默认都是root；</li><li>class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default；</li><li>onrestart:当服务重启时执行相应命令；</li><li>socket: 创建名为/dev/socket/<name>的socket</name></li><li>critical: 在规定时间内该service不断重启，则系统会重启并进入恢复模式</li></ul><p>default: 意味着disabled=false，oneshot=false，critical=false</p><p>示例：</p><pre><code>service servicemanager /system/bin/servicemanager    class core    user system    group system    critical    onrestart restart healthd    onrestart restart zygote    onrestart restart media    onrestart restart surfaceflinger    onrestart restart drm</code></pre><ol><li>所属类 core核心类</li><li>user，group 都为system</li><li>规定时间内不断重启（系统崩溃）进入recovery恢复模式</li><li>servicemanager重启可触发healthd,zygote,media,surfaceflinger,drm重启</li></ol><hr><p>以上我们了解了init.rc文件的基本构成。其思路就是配置相关核心服务和方法，用于在内核启动后系统的核心服务的初始化过程。既然我们知道了其基本组成，下面我们就看看能不能在这里面做点文章。</p><h2 id="案例1："><a href="#案例1：" class="headerlink" title="案例1："></a>案例1：</h2><p>我们需要在系统开机时候启动一个我们自定义的核心服务，就可以在init.rc文件中配置它！</p><ol><li><p>新建测试文件loop.cpp到device/*/test下</p><p> 新建cpp文件，控制打印输出5句“I am a process”</p><pre><code>#include&lt;stdio.h&gt;int main(){      int i=0;      for(i;i&lt;5;i++)      {        printf(&quot;I am a process\n&quot;);      }      return 0;  }</code></pre></li><li><p>编写文件的Android.mk</p><p> 控制编译生成二进制程序loop，默认路径在/system/bin下</p><pre><code>LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES := loop.cppLOCAL_MODULE := loopinclude $(BUILD_EXECUTABLE)</code></pre></li><li><p>修改init.rc文件</p><p> 声明service loop，属类main，即main类服务运行时，统一属类main的service都会启动。console控制台显示，oneshot只启动一次。</p><pre><code># new code by allies for testingservice loop /system/bin/loop   class main   console   oneshot</code></pre></li><li><p>添加对应二进制程序的.te文件</p><p> 对应的具体内容可以参考如下，主要是移植external/sepolicy/uncrypt.te文件，其中缺失的内容是编译过程报错的选项，这里直接删除，可以通过。</p><pre><code># looptype loop, domain, mlstrustedsubject;type loop_exec, exec_type, file_type;init_daemon_domain(loop)# Read /cache/recovery/command# Read /cache/recovery/loop_file# Write to pipe file /cache/recovery/loop_statusallow loop cache_file:dir rw_dir_perms;allow loop cache_file:file create_file_perms;allow loop cache_file:fifo_file w_file_perms;# Set a property to reboot the device.set_prop(loop, powerctl_prop)</code></pre></li><li><p>make系统，刷机查看控制台输出结果</p><p> 重新编译系统，制作升级包，刷机后开机查看log是否有输出。</p></li></ol><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2:"></a>案例2:</h3><p>开机进行检查工作或者拷贝工作，通过向init.rc文件添加属性值监测代码调用自己的脚本实现。<br>例如开机进行apk文件的检查，不存在便进行安装并启动。</p><ol><li><p>init.rc文件添加开机启动属性监测</p><p> 声明服务，并添加判断，开机完成后启动此脚本。如果不加此判断，会导致机器还没完全起来，属类main运行时，pm和am命令用不了，以至于APK未能安装。</p><pre><code>service Test-setup /system/bin/sh /system/etc/init.test.sh    class main    user root    group root    disabled    oneshot1. 属类 main2. user，group均为root3. 不随class自动启动，只有根据service名才启动4. 只启动一次on property:dev.bootcomplete=1    start Test-setup系统启动完成，属性改变开启Test-setup服务</code></pre></li><li><p>编写对应的启动脚本init.Test.sh</p><pre><code>if [ ! -e /data/app/com.android.test-1.apk ]then    pm install /system/test/test.apk    am startservice -n com.android.test/com.android.test.TestServicefi1. 检测文件夹下文件是否存在（存在即有安装）2. 不存在，调用pm命令安装指定路径下apk3. 使用am命令启动制定apk</code></pre></li><li><p>拷贝文件和脚本到相关文件夹下，编译系统刷机</p><ol><li>根据如上脚本，test.apk放置源码的/out/system/test/test.apk</li><li><p>init.Test.sh脚本放置于/system/bin/下</p><p> 对应拷贝的Android.mk文件可以这样编写</p><pre><code>PRODUCT_COPY_FILES += $(LOCAL_PATH)/test.apk:$(TARGET_OUT)/system/test/test.apkPRODUCT_COPY_FILES += $(LOCAL_PATH)/init.Test.sh:$(TARGET_OUT)/system/bin/init.Test.sh</code></pre></li><li><p>make,全局编译生成imsge,刷机测试</p></li></ol></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章节主要介绍了init.rc脚本的基础语法和两个小案例，到这里我们不禁就会想联想到了代码结构中的高内聚低耦合规则，init进程通过遍历不同的rc脚本可以控制系统开机的程序，代码上无需做过多的改动，只需要在配置文件rc脚本中进行相应的修改即可，到这里不禁感叹谷歌工程师们的高超智慧了。</p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之策略模式</title>
      <link href="/FuckCode/2018/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/FuckCode/2018/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式：将若干算法和策略模式抽象出来，提供统一接口，不同的算法和策略有不同的实现类，这样在客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换，这种模式的可扩展性、可维护性更高。</p><ul><li><p>定义</p><p>  定义一系列方法，将这些算法封装起来，提供统一接口，彼此可以互相替换。策略模式让算法独立于使用它的客户而独立变化</p></li><li><p>使用场景</p><ol><li>针对同一类型问题有多种处理方式，仅仅是具体行为有差别</li><li>需要安全地封装多种同一类型的操作时</li><li>出现同一抽象类有多个子类，而又需要使用if-else等选择具体的子类时</li></ol></li><li><p>UML</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/15/1636357b045e275c?w=1300&amp;h=658&amp;f=jpeg&amp;s=110148" alt></p><pre><code>1. Context：用来操作策略的上下文环境2. Stragety：策略的统一抽象接口3. ConcreteStragetyA、ConcreteStargetyB：具体的策略实现类</code></pre><p>在Stragety中抽象出算法或者策略的统一接口；对具体的实现算法进行封装，实现统一接口；环境上下文中根据具体情况，实例特定算法并注入实现对象以完成具体功能。</p><h4 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h4><p>以交通里程金额为背景，公交车10km内1元，超过每1元可乘坐5km；地铁6公里内3元，6-12内4元，12-22内5元，其余6元；以代码实现具体逻辑：坐公交24km和地铁18km所需金额。</p><h5 id="示例代码1"><a href="#示例代码1" class="headerlink" title="示例代码1"></a>示例代码1</h5><pre><code>public class PriceCalculator {    // 交通类型    private final static int BUS = 1;    private final static int SUBWAY = 2;    public static void main(String args[]) {        PriceCalculator priceCalculator = new PriceCalculator();        // 计算交通里程金额，传入交通类型，里程数        int busPrice = priceCalculator.calculatePrice(BUS, 24);        int subwayPrice = priceCalculator.calculatePrice(SUBWAY, 18);        // 测试打印输出        System.out.println(&quot;BUS(24km): &quot; + busPrice + &quot;\n&quot; + &quot;SUBWAY(18km): &quot; + subwayPrice);    }    /**     * 公交10公里1元，超过每一元可坐5公里     *     * @param km     * @return     */    private int busPrice(int km) {        if (km &lt;= 10)            return 1;        else {            return ((km - 10) / 5 * 1 + 2);        }    }    /**     * 地铁6公里内3元，6-12内4元，12-22内5元，其余6元     *     * @param km     * @return     */    private int subwayPrice(int km) {        if (km &lt; 6) {            return 3;        } else if (km &gt;= 6 &amp;&amp; km &lt; 12) {            return 4;        } else if (km &gt;= 12 &amp;&amp; km &lt; 22) {            return 5;        } else {            return 6;        }    }    // 根据交通类型，选择合适算法求解    private int calculatePrice(int type, int km) {        switch (type) {            case BUS:                return busPrice(km);            case SUBWAY:                return subwayPrice(km);        }        return 0;    }}</code></pre><ol><li><p>上面可以看出的问题：不是单一职责。其承担了计算公交和地铁乘坐里程计算逻辑，内部通过switch判断使用哪种方式算法来求解。如果这个时候我们需要新增的士的情况，那么就需要增加的士的具体算法，同时还要在选择交通类型求解中添加判断条件，修改难度增加。</p></li><li><p>其次，如果政策更改，交通定价有变动，那么我们必须在这个类中统一修改，如此以来肯定会影响其他类，增加修改难度和可控性。</p></li><li><p>对于以上耦合度太高的情况，可以使用策略模式来应对处理。首先抽象出共有算法接口，完成算法具体实现类；环境类中根据策划给你做方式具体实例对应算法并注入实现获取结果打印。</p></li></ol><h4 id="完善代码"><a href="#完善代码" class="headerlink" title="完善代码"></a>完善代码</h4><ol><li><p>抽象共有算法接口CalculateStategy</p><pre><code>public interface CalculateStategy {    /**     * 公用接口，根据里程返回价格     * @param km     * @return     */    int calculatePrice(int km);}</code></pre></li><li><p>具体算法实现类</p><pre><code>// 公交算法实现类public class BusStragety implements CalculateStategy {    /**     * 公交10公里1元，超过每一元可坐5公里     *     * @param km     * @return     */    @Override    public int calculatePrice(int km) {        int extraTotal = km - 10;        int extraFactor = extraTotal / 5;        int fraction = extraTotal % 5;        int price = 1 + extraFactor * 1;        return fraction &gt; 0 ? ++price : price;    }}// 地铁算法实现类public class SubwayStagety implements CalculateStategy {    /**     * 地铁6公里内3元，6-12内4元，12-22内5元，其余6元     *     * @param km     * @return     */    @Override    public int calculatePrice(int km) {        if (km &lt; 6) {            return 3;        } else if (km &gt;= 6 &amp;&amp; km &lt; 12) {            return 4;        } else if (km &gt;= 12 &amp;&amp; km &lt; 22) {            return 5;        } else {            return 6;        }    }}</code></pre></li><li><p>环境类中根据情况实例算法并注入获取金额打印输出</p><pre><code>public class TranficCalculator {    public static void main(String args[]) {        // 实例环境类        TranficCalculator tranficCalculator = new TranficCalculator();        // 注入对应算法实例（交通）        tranficCalculator.setStagety(new BusStragety());        // 传入里程获取金额        int busPrice = tranficCalculator.calculatePrice(24);        // 注入算法实例（地铁）并求解        tranficCalculator.setStagety(new SubwayStagety());        int subwayPrice = tranficCalculator.calculatePrice(18);        System.out.println(&quot;BUS(24km): &quot; + busPrice + &quot;\n&quot;                + &quot;SUBWAY(18): &quot; + subwayPrice);    }    // 共有接口成员变量    private CalculateStategy calculateStategy;    // 注入具体算法实例    private void setStagety(CalculateStategy calculateStategy) {        this.calculateStategy = calculateStategy;    }    // 通过接口，实现算法动态调用    private int calculatePrice(int km) {        return calculateStategy.calculatePrice(km);    }}</code></pre></li></ol><ul><li>上面可以看出，通过共有的接口，将具体的算法封装在各自具体实现类的内部，解耦算法之间的逻辑。同时，环境类中通过具体情况实例对应的算法实例直接求解，免去了if-else等调教判断。逻辑更加清晰，维护性更好</li><li><p>同时，如果此时政策改动，价格波动，我们只需要需改对应具体算法实现类即可。即使增加的士<br>的交通方式，也十分简单，如下：</p><pre><code>public class TaxiStargety implements CalculateStategy {    /**     * 3公里5元；超过3公里，每公里1元;     *     * @param km     * @return     */    @Override    public int calculatePrice(int km) {        if (km &lt;= 3) {            return 5;        } else {            int extarTotal = km - 3;            return (5 + extarTotal * 1);        }    }}</code></pre></li><li><p>在环境类中新建的士实例注入并求解14公里的金额</p><pre><code>// 实例环境类TranficCalculator tranficCalculator = new TranficCalculator();// 注入实例算法对象tranficCalculator.setStagety(new TaxiStargety());// 打印输出System.out.println(&quot;Taxi(14): &quot;+ tranficCalculator.calculatePrice(14));</code></pre></li><li><p>打印输出</p><pre><code>BUS(24km): 4SUBWAY(18): 5Taxi(14): 16</code></pre></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过示例我们可以看出二者区别：</p><ol><li><p>前者通过if-else解决交通算法选择问题，实现简单，类型层级单一，但暴露的问题非常明显，即代码臃肿，逻辑复杂，难以升级和维护，没有结构性可言</p></li><li><p>后者通过建立抽象，将不同的策略构成一个具体的策略实现，通过不同的策略实现算法替换，简化逻辑、结构的同时，增强系统的可读性、稳定性、可扩展性，这对于复杂的业务逻辑更为直观，扩展也更为方便。</p></li></ol><h4 id="策略模式和状态模式的区别与联系"><a href="#策略模式和状态模式的区别与联系" class="headerlink" title="策略模式和状态模式的区别与联系"></a>策略模式和状态模式的区别与联系</h4><p>区别</p><ul><li><p>策略模式：</p><ol><li>策略模式一般用于单个算法的替换</li><li>客户端事先必须知道所有的可替换策略，由客户端去指定环境类需要哪个策略，注意通常都只有一个最恰当的策略（算法）被选择</li><li>策略之间是同级的，可互相动态的在运行中替换原有策略</li></ol></li><li><p>状态模式：</p><ol><li>而状态模式的每个状态子类中需要包含环境类（Context）中的所有方法的具体实现——条件语句</li><li>通过把行为和行为对应的逻辑包装到状态类里，在环境类里消除大量的逻辑判断</li><li>不同状态的切换由继承（实现）State的状态子类去实现，当发现修改的当前对象的状态不是自己这个状态所对应的参数，则各个状态子类自己给Context类切换状态（有职责链模式思想）</li><li>且客户端不直接和状态类交互，客户端不需要了解状态！（和策略不一样），策略模式是直接依赖注入到Context类的参数进行选择策略，不存在切换状态的操作，客户端需要了解策略</li></ol></li></ul><p>联系</p><ol><li>UML类图一样，都有抽象接口</li><li>状态模式和策略模式都是为具有多种可能情形设计的模式，把不同的处理情形抽象为一个相同的接口（抽象类），符合对开闭原则，且策略模式更具有一般性</li><li>在实践中，可以用策略模式来封装几乎任何类型的规则，只要在分析过程中听到需要在不同实践应用不同的业务规则，就可以考虑使用策略模式处理，在这点上策略模式是包含状态模式的功能的</li></ol><hr><h4 id="深度拓展"><a href="#深度拓展" class="headerlink" title="深度拓展"></a>深度拓展</h4><blockquote><p>参考文献: Android源码设计模式解析与实战</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之责任链模式</title>
      <link href="/FuckCode/2018/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/FuckCode/2018/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>因为链式结构具有很好的灵活性，将其应用于编程领域：将每个节点当作一个对象，没个对象有不同的处理逻辑，将一个从请求从链式的首端发出，沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>是很多对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有对象处理它为之。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li>多个对象可以处理同一个请求，但具体由哪个对象处理则在运行时动态决定</li><li>在请求处理者不明确的情况下，向多个对象中的一个提交一个请求</li><li>需要动态指定一组对象处理请求</li></ol><h4 id="通用模版"><a href="#通用模版" class="headerlink" title="通用模版"></a>通用模版</h4><ul><li><p>抽象处理者Handler</p><pre><code>public abstract class Handler {    //下一个节点的处理者    protected Handler successor;    //请求处理    public abstract void handleRequest(String condition);}</code></pre><p>抽象处理者需要子类继承实现其具体处理的逻辑，可以借由父类的successor赋值当前节点下一个节点处理者</p></li><li><p>具体处理者1</p><pre><code>public class ConcreteHandler1 extends Handler {    @Override    public void handleRequest(String condition) {        if (condition.equals(&quot;ConcreteHandler1&quot;)){            System.out.println(&quot;ConcreteHandler1 handled&quot;);            return;        }else {            if (successor!=null)                successor.handleRequest(condition);        }    }}</code></pre><p>具体处理者继承父类处理者，实现具体处理的逻辑。如果不是自己能处理的则转交下一个节点继续处理，对于下一节点的设置需要在Client中指明。</p></li><li><p>具体处理者2</p><pre><code>public class ConcreteHandler2 extends Handler {    @Override    public void handleRequest(String condition) {        if (condition.equals(&quot;ConcreteHandler2&quot;)){            System.out.println(&quot;ConcreteHandler2 handled&quot;);            return;        }else {            if (successor!=null){                successor.handleRequest(condition);            }        }    }}</code></pre><p>具体处理者2得到节点1发来消息继续处理（节点一指明节点2为ConcreteHandler2），如果符合自己处理的情况直接处理，否则继续向下一个节点传递。</p></li><li><p>Client客户端</p><pre><code>public class Client {    public static void main(String args[]){        //    实例两个具体处理者        ConcreteHandler1 concreteHandler1 = new ConcreteHandler1();        ConcreteHandler2 concreteHandler2 = new ConcreteHandler2();        // 指明调用者下一个节点        concreteHandler1.successor = concreteHandler2;        concreteHandler2.successor = concreteHandler1;        // 链首开始调用        concreteHandler1.handleRequest(&quot;ConcreteHandler2&quot;);    }}</code></pre><p>客户端内首先实例两个具体的处理者，对处理者之间指明下一个节点，方便调用时可以向下传递。这里可以看出两者互为下一个节点。最后从链首开始调用“ConcreteHandler2”。</p></li><li><p>LOG如下</p><pre><code>ConcreteHandler2 handled</code></pre></li></ul><p>ConcreteHandler1直接调用参数名“ConcreteHandler2”，内部逻辑判断不能直接处理，转交下一节点ConcreteHandler2来调用，ConcreteHandler2能够处理此逻辑，直接打印完成本次链式调用。</p><h4 id="升级模版"><a href="#升级模版" class="headerlink" title="升级模版"></a>升级模版</h4><p>由于责任链中的请求和对应的处理规则是不尽相同的，在这种情况下封装请求，同时对请求的处理规则也进行封装，代码如下：</p><ul><li><p>抽象出处理者</p><p>  public abstract class AbstractHandler {</p><pre><code>//下一节点的处理者对象protected AbstractHandler nextHandler;//请求处理public final void handleRequest(AbstractRequest request){    if (request.getRequestLevel() == getHandleLevel()){        handle(request);    }else {        if (nextHandler!=null){            nextHandler.handleRequest(request);        }else            System.out.println(&quot;All of handler can not handle the request!&quot;);    }}//由子类实现，具体处理方式public abstract void handle(AbstractRequest request);//由子类实现，获取处理者对象级别public abstract int getHandleLevel();</code></pre><p>  }<br>同上抽象处理者相似，除了成员变量下一节点，对处理的逻辑进行一定的的封装。首先检测当前处理级别是否对应，对应直接由虚拟方法子类具体实现处理，否则判断节点并交予下一节点处理，不能处理便直接打印处理。<br>同时处理中使用了封装的AbstractRequest请求，下面介绍。</p></li><li><p>具体处理者1，2，3</p><pre><code>public class Handler1 extends AbstractHandler {    @Override    public void handle(AbstractRequest request) {        System.out.println(&quot;Handler1 handle the request: &quot;+ request.getRequestLevel());    }    @Override    public int getHandleLevel() {        return 1;    }}</code></pre><p>具体处理者直接处理哭啼逻辑，父类已经进行了相关的等级判断，这是共有的逻辑可以封装在父类中，同时需要返回当前处理的等级，以满足父类判断的需要。</p></li><li><p>抽象请求者</p><pre><code>public abstract class AbstractRequest {    //处理对象    private Object obj;    public AbstractRequest(Object obj) {        this.obj = obj;    }    public Object getContext(){        return obj;    }    public abstract int getRequestLevel();}</code></pre><p>抽象请求者封装抽象处理者需要的等级判断条件，需要子类实现具体请求的等级。</p></li><li><p>具体请求者1，2，3</p><pre><code>public class Request1 extends AbstractRequest {    public Request1(Object obj) {        super(obj);    }    @Override    public int getRequestLevel() {        return 1;    }}</code></pre><p>方法相对简单，直接返回当前对象对应的请求等级。</p></li><li><p>Client端实现</p><pre><code>public class Main {    public static void main(String args[]) {        //构造三个处理者对象        Handler1 handler1 = new Handler1();        Handler2 handler2 = new Handler2();        Handler3 handler3 = new Handler3();</code></pre></li></ul><pre><code>        //设置当前处理者对象的下一个处理者        handler1.nextHandler = handler2;        handler2.nextHandler = handler3;        //构造3个请求者        Request1 request1 = new Request1(&quot;Request1&quot;);        Request2 request2 = new Request2(&quot;Request2&quot;);        Request3 request3 = new Request3(&quot;Request3&quot;);        //从链式的首端发起请求        handler1.handleRequest(request1);        handler1.handleRequest(request2);        handler1.handleRequest(request3);    }}</code></pre><p>Client端首先构建三个处理者，并设置对应的节点关系。之后实例三个具体的请求者。链式调用从链首开始，调用Handlelr1处理请求，让其依次处理请求1，2，3，对于请求1，自己可以直接处理，对于请求2，3，处理者1不能直接处理，只能向下节点传递，有下面节点处理。</p><ul><li><p>LOG分析</p><pre><code>Handler1 handle the request: 1Handler2 handle the requset: 2Handler3 handle the request: 3</code></pre></li></ul><p>从log我们可以看出：</p><ol><li>具体处理者1可以直接处理请求1；</li><li>对于请求2，虽然使用处理者1来调用，但是可以通过链式传递到达节点2，由处理者2处理；</li><li>对于请求3，处理者1不满足处理条件，通过链转下一节点到处理者2，处理者2仍然不满足处理条件，再通过链转交节点3，处理者3满足条件直接处理。</li></ol><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>责任链模式与状态者模式有相似之处，但也有区别：</p><ol><li><p>职责链模式中的各个对象并不指定其下一个处理的对象到底是谁，只有在客户端才设定某个类型的链条，请求发出后穿越链条，直到被某个职责类处理或者链条结束。设计思路是把各个业务逻辑判断封装到不同职责类，且携带下一个职责的对应引用，但不像状态模式那样需要明确知道这个引用指向谁，而是在环境类设置链接方式或者过程。使用时，向链的第一个子类的执行方法传递参数就可以。客户端去通过环境类调用责任链，全自动运转起来。</p></li><li><p>状态模式是让各个状态对象自己知道其下一个处理的对象是谁，即在编译时便设定。设计思路是把逻辑判断转移到各个State类的内部实现(相当于If，else If)，执行时客户端通过调用环境—Context类的方法来间接执行状态类的行为，客户端不直接和状态交互。</p></li></ol></li><li><p>优缺点</p><ol><li>优点显而易见，可以对请求者和处理者关系解耦，提高代码灵活性。</li><li>最大的缺点是对链中请求处理者的遍历，处理处理者太多，遍历必然会影响性能，特别是在一些递归调用中。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 责任链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实战StateMachine状态机</title>
      <link href="/FuckCode/2018/05/07/%E5%AE%9E%E6%88%98%E4%B9%8BStateMachine%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
      <url>/FuckCode/2018/05/07/%E5%AE%9E%E6%88%98%E4%B9%8BStateMachine%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="实战StateMachine状态机"><a href="#实战StateMachine状态机" class="headerlink" title="实战StateMachine状态机"></a>实战StateMachine状态机</h3><p>前面我们讲解了设计模式中的<a href="https://juejin.im/post/59eae215f265da43085d2b49" target="_blank" rel="noopener">状态模式</a>，以及分析了安卓源码中的<a href="https://juejin.im/post/5aed34376fb9a07aa54230fc" target="_blank" rel="noopener">StateMachine状态机的内部实现原理</a>。<strong><em>其原理简而言之：就是通过状态树维持各种状态实例，各个状态实例相邻之间可以互相转换，不相邻的便通过内部状态树遍历查找。通过消息传递机制，发送消息并转换状态实例，从而实现对应状态下响应对应状态下应有的逻辑。</em></strong></p><h4 id="状态机的实现步骤"><a href="#状态机的实现步骤" class="headerlink" title="状态机的实现步骤"></a>状态机的实现步骤</h4><ol><li>自定义StateMachine类继承StateMachine</li><li>自定义状态State继承State：重写enter、processMsg、exit  </li><li>设置更新状态常量,用于状态更新</li><li>addState加入父状态、子状态，setInitialState初始化状态</li><li>start启动状态机stateMachine</li><li>使用状态机，发送持有更新状态常量的Msg，处理对应的pressageMessage</li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><ul><li>我们以电梯运行为例实现状态机的实现过程</li></ul><ol><li><p>状态分析：</p><pre><code>待机    停机等待选择（上楼or下楼）运行中到站</code></pre></li><li><p>自定义LiftStateMachine继承StateMachine</p><pre><code>public class LiftStateMachine extends StateMachine {    private static LiftStateMachine liftStateMachine;    public static final int MSG_ON = 1;    public static final int MSG_BUSY_UP = 2;    public static final int MSG_BUSY_DOWN = 3;    public static final int MSG_OVER = 4;    public static final int MSG_OFF = 5;    public static final int MSG_WAIT = 6;    protected LiftStateMachine(String name) {        super(name);        initLiftStateMachine();    }    protected LiftStateMachine(String name, Looper looper) {        super(name, looper);        initLiftStateMachine();    }    protected LiftStateMachine(String name, Handler handler) {        super(name, handler);        initLiftStateMachine();    }    private State liftOnState = new LiftOnState();    private State liftWaitState = new LiftWaitForUpOrDownState();    private State liftBusyState = new LiftBusyState();    private State liftOverState = new LiftOverState();    private State liftOffState = new LiftOffState();    private void initLiftStateMachine() {        //添加状态        addState(liftOnState);        addState(liftWaitState);        addState(liftBusyState);        addState(liftOverState);        addState(liftOffState);        //调用父类方法设置初始状态        setInitialState(liftOnState);        //开启状态机        start();    }    //创建状态机    public static StateMachine makeLiftStateMachine(){        liftStateMachine = new LiftStateMachine(&quot;LiftStateMachine&quot;);        return liftStateMachine;    }   }</code></pre><p>上述代码中首先定义几种状态响应的常量，用于在各种State中分辨并响应对应的handleMessage消息。其次是实例出电梯的几种状态实例，并在初始化中加入状态树，之后设置原始状态，最后开启状态机进行工作。</p></li><li><p>电梯中各种状态的具体</p><pre><code>2.1 待机状态    static class LiftOnState extends State {        @Override        public void enter() {            super.enter();            Log.d(TAG, &quot;LiftOnState --&gt; enter&quot;);            Message message = liftStateMachine.obtainMessage();            message.what = MSG_WAIT;            liftStateMachine.sendMessage(message);        }        @Override        public boolean processMessage(Message msg) {            if (msg.what == MSG_WAIT){                liftStateMachine.deferMessage(msg);                liftStateMachine.transitionTo(liftStateMachine.liftWaitState);            }            return super.processMessage(msg);        }        @Override        public void exit() {            super.exit();            Log.d(TAG, &quot;LiftOnState --&gt; exit&quot;);        }    }</code></pre><p> 待机状态中，在进入状态中便发送一个MSG_WAIT消息，由于当前没有切换状态实例，只有在自己的processMessage方法中处理，之后在自己的消息处理逻辑中转移消息，并切换状态实例到等待状态，此时对应电梯门前有人按下电梯按钮，需要等待电梯到达当前楼层。</p><pre><code>2.2 等待状态    static class LiftWaitForUpOrDownState extends State {        @Override        public void enter() {            super.enter();            Log.d(TAG, &quot;LiftWaitForUpOrDownState --&gt; enter&quot;);        }        @Override        public boolean processMessage(Message msg) {            switch (msg.what){                case MSG_WAIT:                    Log.d(TAG, &quot;LiftWaitForUpOrDownState --&gt; processMessage&quot;);                    Message msg1 = liftStateMachine.obtainMessage();                    msg1.what = MSG_BUSY_UP;                    liftStateMachine.sendMessage(msg1);                    //延迟下楼消息                    Message message = liftStateMachine.obtainMessage();                    message.what = MSG_BUSY_DOWN;                    liftStateMachine.sendMessage(message);                    liftStateMachine.transitionTo(liftStateMachine.liftBusyState);                    break;            }</code></pre></li></ol><pre><code>            return super.processMessage(msg);        }        @Override        public void exit() {            super.exit();            Log.d(TAG, &quot;LiftWaitForUpOrDownState --&gt; exit&quot;);        }    } 等待状态逻辑也很简单，主要接收处理MSG_WAIT消息。通过切换状态，进入等待状态的enter方法，之后响应发来的MSG_WAIT消息。此时电梯到达目标楼层，开门等待人员进入并关闭，通过代码可以看出，电梯先向上运行，再向下运行，这时候电梯就要转换状态进入运行状态，此时不能再进行开门和关门等操作。 2.3 电梯运行状态    static class LiftBusyState extends State {        @Override        public void enter() {            super.enter();            Log.d(TAG, &quot;LiftBusyState --&gt; enter&quot;);        }        @Override        public boolean processMessage(Message msg) {            switch (msg.what){                case MSG_BUSY_UP:                    Log.d(TAG, &quot;LiftBusyState --&gt; MSG_BUSY_UP&quot;);                    break;                case MSG_BUSY_DOWN:                    Log.d(TAG, &quot;LiftBusyState --&gt; MSG_BUSY_DOWN&quot;);                    Message m = liftStateMachine.obtainMessage();                    m.what = MSG_OVER;                    liftStateMachine.sendMessage(m);                    liftStateMachine.transitionTo(liftStateMachine.liftOverState);            }            return super.processMessage(msg);        }        @Override        public void exit() {            super.exit();            Log.d(TAG, &quot;LiftBusyState --&gt; exit&quot;);        }    }人员进入电梯，电梯便运行到达指定楼层，代码中电梯先是到达高楼层，紧接着到达低楼层后，进入到达状态，这是需要请求开门后，人员才可以出入。2.4 到达状态    static class LiftOverState extends State {        @Override        public void enter() {            super.enter();            Log.d(TAG, &quot;LiftOverState --&gt; enter&quot;);        }        @Override        public boolean processMessage(Message msg) {            switch (msg.what){                case MSG_OVER:                    Log.d(TAG, &quot;LiftOverState --&gt; MSG_OVER&quot;);                    Message message = liftStateMachine.obtainMessage();                    message.what = MSG_OFF;                    liftStateMachine.sendMessage(message);                    break;                case MSG_OFF:                    Log.d(TAG, &quot;LiftOverState --&gt; MSG_OFF&quot;);                    Log.d(TAG, &quot;transitionTo(liftOffState), sendMessage(MSG_OFF)&quot;);                    Message newMsg = liftStateMachine.obtainMessage();                    newMsg.what = MSG_OFF;                    liftStateMachine.sendMessage(newMsg);                    liftStateMachine.transitionTo(liftStateMachine.liftOffState);                    break;            }            return super.processMessage(msg);        }          Override        public void exit() {            super.exit();            Log.d(TAG, &quot;LiftOverState --&gt; exit&quot;);        }    } 此时电梯到达指定楼层，电梯开门，人员可以安全的出入。代码中，此种状态下响应MSG_OVER消息。但是代码中再响应MSG_OVER没有切换状态，而是在自己响应自己发出的MSG_OFF的消息。稍后我们可以查看log得出此时的MSG_OFF消息是到达状态响应还是已经跳转到停机状态，由停机状态响应。 2.5 停机状态    static class LiftOffState extends State {        @Override        public void enter() {            super.enter();            Log.d(TAG, &quot;LiftOffState --&gt; enter&quot;);        }        @Override        public boolean processMessage(Message msg) {            switch (msg.what){                case MSG_OFF:                    Log.d(TAG, &quot;LiftOffState --&gt; MSG_OFF&quot;);                break;                default:                    break;            }            return super.processMessage(msg);        }        @Override        public void exit() {            super.exit();            Log.d(TAG, &quot;LiftOffState --&gt; exit&quot;);        }    }电梯停机状态逻辑更是简单，对传来的MSG_OFF关机消息，简单的打印了一个log。当然可以在这里响应其他楼层的电梯等待行为，需要接收MSG_WAIT消息，并将当前状态切换为等待状态，之后电梯才能知道自己要进入运行状态到达指定楼层去接人。</code></pre><ol start="3"><li><p>log分析总结</p><p> 通过控制台打印的log进行总结</p><pre><code>//电梯开机，便发送消息进入WAIT状态LiftState: LiftOnState --&gt; enterLiftState: LiftOnState --&gt; exit//WAIT状态下等待人员进入，之后电梯关门进入运行状态LiftWaitForUpOrDownState --&gt; enterLiftWaitForUpOrDownState --&gt; processMessageLiftWaitForUpOrDownState --&gt; exit//电梯运行状态，先上后下，最后到达指定楼层，进入到达状态LiftBusyState --&gt; enterLiftBusyState --&gt; MSG_BUSY_UPLiftBusyState --&gt; MSG_BUSY_DOWNLiftBusyState --&gt; exit//到达指定楼层，开门等待人员出入LiftOverState --&gt; enterLiftOverState --&gt; MSG_OVER／／这里可以看出，状态没有改变，MSG_OFF仍然在到达状态下响应的，需要切换到停机状态才能真正实现电梯停机LiftOverState --&gt; MSG_OFFtransitionTo(liftOffState), sendMessage(MSG_OFF)LiftOverState --&gt; exit//电梯真正停机，没法响应其他的操作，此时逻辑上只能响应开即进入待机状态，无法进入等待，运行，达到等其他状态LiftOffState --&gt; enterLiftOffState --&gt; MSG_OFF</code></pre></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>通过安卓源码的状态机机制，我们可以方便快捷的设计自己的状态模式模型</li><li>状态模式的精髓就是各个状态下，各自响应自己能够操作的逻辑。对于越界操作，需要转移状态交予正确的状态来处理。</li><li>维护状态的状态树原型也是一种跨越性的思维，其约束了各种状态间之间莫名的转换关系</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 实战 </tag>
            
            <tag> 状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码分析之状态机原型</title>
      <link href="/FuckCode/2018/05/05/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8E%9F%E5%9E%8B/"/>
      <url>/FuckCode/2018/05/05/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="源码分析之状态机原型"><a href="#源码分析之状态机原型" class="headerlink" title="源码分析之状态机原型"></a>源码分析之状态机原型</h3><p>许久没更新设计模式部分内容了，之前介绍了设计模式中的<a href="https://juejin.im/post/59eae215f265da43085d2b49" target="_blank" rel="noopener">状态设计模式</a>，期间一直忙于工作上的事，对安卓源码进行了相关的学习。翻回来看时候，发现更新到这里的时候，就顺便对源码部分的状态机StateMachine研究一下，其内部的设计思路就是状态者模式的最佳体现，后续会这个基础上详细分说wifiStateMachine的工作方式，是状态机的具体实现方式，基本上到这里，状态模式基本就讲清楚了。</p><ul><li><p>重要类：StateMachine</p></li><li><p>代码位置：frameworks/base/core/java/com/android/internal/util/StateMachine.java</p></li><li><p>状态机，顾名思义，就是维持状态的机器。面对日常生活，我们经常面临很多种状态情况，比如财务就是负责财务收支，工资核对发放；保安就负责日常安保等等。每个职业对应自己的工作职责和状态。一个工作内容到了财务和保安都不一样，各自对应自己的职责和状态。虽说这样比喻不大恰当，但确实是这么回事，这便是状态的初始原型。状态机内部维持一个状态树，状态树保存了每个状态下各自实例。每个状态都继承同一个基类Status，实现接口IState，有四个方法enter（），exit（），processMessage（），getName（）。状态机中每一个子类都要实现这几个方法，对应到各自实例就会调用自己对应的方法，这便是状态模式的作用：将请求的处理封装到状态类中，在不同状态下对同一个请求进行不同的处理。</p></li><li><p>状态树：状态类的层级结构。状态机中的每个状态不能随便转换。</p><pre><code>        A        B    C        D    E        F上面展示的状态树中，A状态可以直接转成B状态，相邻状态可以直接转换（注意是相邻，直接转换）。如果从状态E准换成B，那么要经历一下状态：E -&gt; C, C -&gt; A, A -&gt; B;为什么要这么做呢？不妨可以这样理解，坐电梯时候，你在门外可以进入电梯和不进去；一旦进入电梯并且电梯运行中，你就不能随意进出了，完成出电梯需要有一个过程。你需要让电梯到达指定楼层，电梯停止运动，电梯开门后，你才能出电梯。将这种逻辑抽象出来遍生成了状态树，状态树中每个状态都有两个相邻状态，先前状态，后继状态，当然这不是必需元素。</code></pre></li></ul><ul><li><p>状态机范例</p><pre><code>class HelloWorld extends StateMachine {    HelloWorld(String name) {        super(name);        addState(mState1);        setInitialState(mState1);    }    public static HelloWorld makeHelloWorld() {        HelloWorld hw = new HelloWorld(&quot;hw&quot;);        hw.start();        return hw;    }    class State1 extends State {        &amp;#64;Override public boolean processMessage(Message message) {            log(&quot;Hello World&quot;);            return HANDLED;        }    }    State1 mState1 = new State1();}void testHelloWorld() {    HelloWorld hw = makeHelloWorld();    hw.sendMessage(hw.obtainMessage());}1. State1继承基类State，实现processMessage处理对应自己的逻辑2. HelloWorld继承基类StateMachine状态机，构造函数中加入状态组成状态树，设置初始状态。3. makeHelloWorld中为状态机的实例过程，其实例化自身对象，对切调用状态机的start开启状态机。4. 测试代码中实例化状态机，状态机发送消息并且处理。</code></pre></li><li><p>State原型</p><pre><code>public class State implements IState {    protected State() {    }    @Override    public void enter() {    }    @Override    public void exit() {    }    @Override    public boolean processMessage(Message msg) {        return false;    }    public String getName() {        String name = getClass().getName();        int lastDollar = name.lastIndexOf(&apos;$&apos;);        return name.substring(lastDollar + 1);    }}</code></pre><p>State原型实现IState接口，需要开发者自建对应具体的状态实现其具体逻辑，由状态树统一管理，再交予状态机调用对应状态下具体方法。</p></li></ul><h4 id="StateMachine具体分析"><a href="#StateMachine具体分析" class="headerlink" title="StateMachine具体分析"></a>StateMachine具体分析</h4><ul><li><p>构造函数</p><pre><code>protected StateMachine(String name) {    mSmThread = new HandlerThread(name);    mSmThread.start();    Looper looper = mSmThread.getLooper();    initStateMachine(name, looper);}protected StateMachine(String name, Looper looper) {    initStateMachine(name, looper);}protected StateMachine(String name, Handler handler) {    initStateMachine(name, handler.getLooper());}</code></pre><p>构造函数中可以看出，StateMachine内部可以自己维持HandlerThread，实现looper对象的消息处理，也可以在构造中传入。之后便进入初始化状态机。</p></li><li><p>初始化状态机</p><pre><code>private void initStateMachine(String name, Looper looper) {    mName = name;    mSmHandler = new SmHandler(looper, this);}</code></pre><p>初始化状态机中，其内部又一个重要的内部类SmHandler，其继承Handler，父类很多方法都一度封装在SmHandler内部中，我们注重介绍一下SmHandler</p></li><li><p>开启状态机</p><pre><code>public void start() {    SmHandler smh = mSmHandler;    if (smh == null) return;    smh.completeConstruction();}</code></pre></li><li><p>完成状态树信息以及初始化状态信息栈</p><pre><code>private final void completeConstruction() {        if (mDbg) mSm.log(&quot;completeConstruction: E&quot;);    /**     * Determine the maximum depth of the state hierarchy     * so we can allocate the state stacks.     */    // 获取状态的最深层级    int maxDepth = 0;    for (StateInfo si : mStateInfo.values()) {        int depth = 0;        for (StateInfo i = si; i != null; depth++) {            i = i.parentStateInfo;        }        if (maxDepth &lt; depth) {            maxDepth = depth;        }    }    if (mDbg) mSm.log(&quot;completeConstruction: maxDepth=&quot; + maxDepth);    // 新建两个状态栈    //1. 顶层到当前状态信息数组    mStateStack = new StateInfo[maxDepth];    //2. 当前状态信息到顶层状态信息数组    mTempStateStack = new StateInfo[maxDepth];    setupInitialStateStack();        // 置前消息，初始化消息SM_INIT_CMD，由自己的handlerMessage处理    sendMessageAtFrontOfQueue(obtainMessage(SM_INIT_CMD, mSmHandlerObj));    if (mDbg) mSm.log(&quot;completeConstruction: X&quot;);}</code></pre></li></ul><h4 id="SmHandler详细说明"><a href="#SmHandler详细说明" class="headerlink" title="SmHandler详细说明"></a>SmHandler详细说明</h4><ol><li><p>几个重要的内部成员</p><pre><code>HashMap&lt;State, StateInfo&gt; mStateInfo状态树成员，以HashMap形式存放，键State，值StateInfoState mInitialState初始化状态信息State mDestState带转换的目的状态ArrayList&lt;Message&gt; mDeferredMessages延迟消息列表HaltingState mHaltingState特殊状态：状态机停止状态（内部自建）QuittingState mQuittingState特殊状态：状态机正在停止中状态（状态机内部自建）StateInfo mStateStack[];状态树中从顶层到初始状态信息的信息栈StateInfo mTempStateStack[];状态树中初始状态到顶层状态信息的信息栈</code></pre></li><li><p>handlerMessage方法分析</p><p> 该方法的主要划分三部分，第一部分分配到对应的状态，由对应的状态进行处理；第二部分是状态的初始化，执行初始化状态路径上每个状态的enter方法；第三部分是执行状态转移，即更新状态树。</p><pre><code>public final void handleMessage(Message msg) {        ...    if (mIsConstructionCompleted) {        // 分配到对应的状态,由对应的状态进行处理，返回执行消息的状态信息        msgProcessedState = processMsg(msg);    } else if (!mIsConstructionCompleted &amp;&amp; (mMsg.what == SM_INIT_CMD)            &amp;&amp; (mMsg.obj == mSmHandlerObj)) {        // start方法后，直接执行，执行状态初始化（执行状态树上的enter方法）        mIsConstructionCompleted = true;        invokeEnterMethods(0);    } else {        throw new RuntimeException(&quot;StateMachine.handleMessage: &quot;                + &quot;The start method not called, received msg: &quot; + msg);    }    // 状态转移，更新状态树    performTransitions(msgProcessedState, msg);        ...}</code></pre></li><li><p>状态处理</p><pre><code> // 对应状态（底层）处理当前消息    private final State processMsg(Message msg) {        StateInfo curStateInfo = mStateStack[mStateStackTopIndex];        if (mDbg) {            mSm.log(&quot;processMsg: &quot; + curStateInfo.state.getName());        }    if (isQuit(msg)) {        transitionTo(mQuittingState);    } else {        // 递归调用处理消息        while (!curStateInfo.state.processMessage(msg)) {            /**             * Not processed             */            // 底层没有处理，移交父级节点处理            curStateInfo = curStateInfo.parentStateInfo;            // 始终没处理            if (curStateInfo == null) {                /**                 * No parents left so it&apos;s not handled                 */                mSm.unhandledMessage(msg);                break;            }            if (mDbg) {                mSm.log(&quot;processMsg: &quot; + curStateInfo.state.getName());            }        }    }    return (curStateInfo != null) ? curStateInfo.state : null;}</code></pre></li><li><p>遍历状态树，各自调用enter方法</p><pre><code>private final void invokeEnterMethods(int stateStackEnteringIndex) {    // 从顶层状态树遍历到当前状态下多有的enter方法，置位active为true（对应enter方法以调用）    for (int i = stateStackEnteringIndex; i &lt;= mStateStackTopIndex; i++) {        if (mDbg) mSm.log(&quot;invokeEnterMethods: &quot; + mStateStack[i].state.getName());        mStateStack[i].state.enter();        mStateStack[i].active = true;    }}</code></pre></li><li><p>转移状态，更新状态树</p><pre><code>private void performTransitions(State msgProcessedState, Message msg) {    // 原来的状态信息（即mStateStack数组的顶层状态信息）    State orgState = mStateStack[mStateStackTopIndex].state;    ...    State destState = mDestState;     // 目标状态不为空    if (destState != null) {        while (true) {            if (mDbg) mSm.log(&quot;handleMessage: new destination call exit/enter&quot;);            // 查找目标状态下对应的状态树（排除共有的状态树部分）            StateInfo commonStateInfo = setupTempStateStackWithStatesToEnter(destState);            // 根据当前状态树顶层状态，依次调用其enter，置位active            invokeExitMethods(commonStateInfo);            // 逆序整理两个状态栈信息            int stateStackEnteringIndex = moveTempStateStackToStateStack();            // 依次调用enter方法            invokeEnterMethods(stateStackEnteringIndex);            // 将延迟的消息放入到队列前面，直接处理            moveDeferredMessageAtFrontOfQueue();            if (destState != mDestState) {                // A new mDestState so continue looping                destState = mDestState;            } else {                // No change in mDestState so we&apos;re done                break;            }        }        mDestState = null;    }    // 特殊状态处理    if (destState != null) {        if (destState == mQuittingState) {            mSm.onQuitting();            cleanupAfterQuitting();        } else if (destState == mHaltingState) {          haltedProcessMessage(msg);             */            mSm.onHalting();        }    }}</code></pre></li><li><p>查找目标状态下对应的状态树（排除共有的状态树部分）</p><pre><code>private final StateInfo setupTempStateStackWithStatesToEnter(State destState) {    mTempStateStackCount = 0;    // 获取目标状态    StateInfo curStateInfo = mStateInfo.get(destState);    do {        /* 遍历状态树，从目标状态依次放入         * 排除不可调用enter方法的状态（activit=false）         * temp数组存放的顺序是有底层到顶层，调用时候应该逆序调用         * 返回当前数组的末端数据（目标状态树下顶层状态信息）         */        mTempStateStack[mTempStateStackCount++] = curStateInfo;        curStateInfo = curStateInfo.parentStateInfo;    } while ((curStateInfo != null) &amp;&amp; !curStateInfo.active);    if (mDbg) {        mSm.log(&quot;setupTempStateStackWithStatesToEnter: X mTempStateStackCount=&quot;                + mTempStateStackCount + &quot;,curStateInfo: &quot; + curStateInfo);    }    return curStateInfo;}</code></pre></li><li><p>根据当前状态树顶层状态，依次调用其enter，置位active</p><pre><code>private final void invokeExitMethods(StateInfo commonStateInfo) {    while ((mStateStackTopIndex &gt;= 0)            &amp;&amp; (mStateStack[mStateStackTopIndex] != commonStateInfo)) {        // mStateStackTopIndex存放的顶层到底层的状态树信息，依次调用        State curState = mStateStack[mStateStackTopIndex].state;        if (mDbg) mSm.log(&quot;invokeExitMethods: &quot; + curState.getName());        curState.exit();        mStateStack[mStateStackTopIndex].active = false;        mStateStackTopIndex -= 1;    }}</code></pre></li><li><p>逆序整理两个状态栈信息</p><pre><code>private final int moveTempStateStackToStateStack() {    // 将mTempStateStack数组元素逆序保存到mStateStack中    int startingIndex = mStateStackTopIndex + 1;    int i = mTempStateStackCount - 1;    int j = startingIndex;    while (i &gt;= 0) {        if (mDbg) mSm.log(&quot;moveTempStackToStateStack: i=&quot; + i + &quot;,j=&quot; + j);        mStateStack[j] = mTempStateStack[i];        j += 1;        i -= 1;    }    mStateStackTopIndex = j - 1;    if (mDbg) {        mSm.log(&quot;moveTempStackToStateStack: X mStateStackTop=&quot; + mStateStackTopIndex                + &quot;,startingIndex=&quot; + startingIndex + &quot;,Top=&quot;                + mStateStack[mStateStackTopIndex].state.getName());    }    return startingIndex;}</code></pre></li><li><p>依次调用enter方法</p><pre><code>private final void invokeEnterMethods(int stateStackEnteringIndex) {...}详见前4部分</code></pre></li><li><p>更改状态，直接设置中间变量mDestState，handlerMessage轮训中不断调用performTransitions实现状态更改</p><pre><code>private final void transitionTo(IState destState) {    mDestState = (State) destState;    if (mDbg) mSm.log(&quot;transitionTo: destState=&quot; + mDestState.getName());}消息轮训处理不断调用，更改状态public final void handleMessage(Message msg) {    if (!mHasQuit) {        if (mDbg) mSm.log(&quot;handleMessage: E msg.what=&quot; + msg.what);            ...        // 状态转移，更新状态树        performTransitions(msgProcessedState, msg);        ...    }}</code></pre></li></ol><hr><ul><li><p>具体实现方式：</p><ol><li>新建自己的状态机继承于系统的StateMachine状态机，实现其相应的方法</li><li>完成自己需求中各种状态的具体逻辑实现，其必须继承自系统的State，具体逻辑实现在其自身的pressageMessage方法中。</li><li>依据示例代码，首先构建状态机，添加对应的状态层级组成状态树，由状态机维持，初始化状态机，开启状态机即可</li></ol></li><li><p>总结：以上基本分析了StateMachine状态机原型的工作方式和原理，其内部维持一个状态树，当达到当前状态时，由维持当前状态的实例对象处理对应的逻辑，这便对应了不同状态下对同一个请求有不同的处理方式，当前状态不处理遍向上传递父类调用，有点类似安卓中触摸事件的向上传递机制。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码编译之系统代码资源Overlay机制</title>
      <link href="/FuckCode/2018/04/28/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E8%B5%84%E6%BA%90Overlay%E6%9C%BA%E5%88%B6/"/>
      <url>/FuckCode/2018/04/28/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8B%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E8%B5%84%E6%BA%90Overlay%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>代码overlay机制意思是，将我们在Android原生代码上修改过的文件，单独放在一个目录下，而在编译代码的时候就会去检测这个目录下的文件，如果这个目录下的文件与原生有相同的文件，那么就将这个文件放入编译的源文件中，而将原生相同文件名的文件从编译的源文件中去除。</strong></p><a id="more"></a><h1 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h1><p>Overlay机制及编译时覆盖，可以解决系统定制时候，代码杂乱冗余结构不清晰的问题。其从机制上无非是对编译脚本Android.mk进行了相关设定，主要设计到源代码的Overlay以及资源文件的Overlay。</p><h2 id="代码overlay"><a href="#代码overlay" class="headerlink" title="代码overlay"></a>代码overlay</h2><p>代码上的Overlay机制相对繁杂，不仅需要修改对应的编译文件，还需要将Overlay的代码放于指定的目录下。具体示例操作，我们以PowerManagerService为例进行说明：</p><h3 id="建立相应overlay文件夹"><a href="#建立相应overlay文件夹" class="headerlink" title="建立相应overlay文件夹"></a>建立相应overlay文件夹</h3><p>安卓源码root路径下建立源文件对应的目录层级，顶层文件以overlay命名</p><pre><code>原文件目录层级：frameworks/base/services/core/java/com/android/server/power/新建overlay目录层级：/overlay/frameworks/base/services/core/java/com/android/server/power/</code></pre><h3 id="拷贝对应源代码到overlay文件夹下进行定制修改"><a href="#拷贝对应源代码到overlay文件夹下进行定制修改" class="headerlink" title="拷贝对应源代码到overlay文件夹下进行定制修改"></a>拷贝对应源代码到overlay文件夹下进行定制修改</h3><p>拷贝PowerManagerService.java文件到新建overlay底层目录下，修改其相应逻辑，例如打开logcat打印开关</p><pre><code>private static final String TAG = &quot;PowerManagerService&quot;;private static final boolean DEBUG = true;</code></pre><h3 id="修改原文件夹下对应的Android-mk文件"><a href="#修改原文件夹下对应的Android-mk文件" class="headerlink" title="修改原文件夹下对应的Android.mk文件"></a>修改原文件夹下对应的Android.mk文件</h3><p>代码添加完成，接下来就需要对其编译脚本进行修改。</p><ol><li><p>添加原文件到编译系统中</p><pre><code># 为当前目录层级添加overlay顶层目录services_ext_subdirs := $(addprefix ../../../../overlay/, $(LOCAL_PATH)/)$(warning $(services_ext_subdirs))# 获取新建层级目录下的java文件services_ext_files := $(call all-java-files-under, $(services_ext_subdirs))$(warning $(services_ext_files))# 添加到编译系统中去LOCAL_SRC_FILES += $(services_ext_files)</code></pre></li><li><p>删除编译系统重复的原文件</p><pre><code># 定义空变量用来字串替换empty :=# 用空字串替换掉services_ext_files中存在的services_ext_subdirs，即得到重复的文件名services_ext_overlay_files := $(subst $(services_ext_subdirs), $(empty), $(services_ext_files))$(warning $(services_ext_overlay_files))# 过滤编译系统中存在的重复文件LOCAL_SRC_FILES := $(filter-out $(services_ext_overlay_files), $(LOCAL_SRC_FILES))</code></pre><p> 注：</p><pre><code>$(warning $(...))用于打印log调试，addprefix等文件名操作函数见下链接</code></pre></li><li><p>编译验证 </p><pre><code>初始编译环境跳转到当前文件下mm -B 拷贝生成的services.jar,替换文件system/framework/services.jar提权，重启查看logcat</code></pre></li><li><p>参考及扩展链接</p><p> <a href="https://blog.csdn.net/kc58236582/article/details/50351813" target="_blank" rel="noopener">代码overlay机制</a></p><p> <a href="https://www.cnblogs.com/bclshuai/p/8072877.html" target="_blank" rel="noopener">Linux文件名操作函数相关</a></p></li></ol><h2 id="资源文件overlay"><a href="#资源文件overlay" class="headerlink" title="资源文件overlay"></a>资源文件overlay</h2><p>资源文件的Overlay相比代码Overlay相对简单，一般的定制系统都会建立相应的层级结构，其具体步骤总结如下</p><h3 id="为产品添加Overlay目录"><a href="#为产品添加Overlay目录" class="headerlink" title="为产品添加Overlay目录"></a>为产品添加Overlay目录</h3><p>资源文件的Overlay方式有两种</p><pre><code>Product Overlay PRODUCT_PACKAGE_OVERLAYSDevice Overlay  DEVICE_PACKAGE_OVERLAYSProduct Overlay 的优先级高于 Device Overlay即同一资源下，PRODUCT_PACKAGE_OVERLAYS将覆盖DEVICE_PACKAGE_OVERLAYS</code></pre><h3 id="改变Makefile来添加overlay的编译项"><a href="#改变Makefile来添加overlay的编译项" class="headerlink" title="改变Makefile来添加overlay的编译项"></a>改变Makefile来添加overlay的编译项</h3><p>为了添加一个overlay目录，需要修改产品的makefile</p><pre><code>例如：device／vendor/vendor-name/device-name/product-name.mk在其中添加以下编译项：    LOCAL_PATH := device／vendor/vendor-name/device-name    $(PRODUCT_PACKAGE_OVERLAYS) := $(LOCAL_PATH)/overlayOR    $(DEVICE_PACKAGE_OVERLAYS) := $(LOCAL_PATH)/overlay</code></pre><h3 id="在对应的overlay目录下创建相对应的资源文件"><a href="#在对应的overlay目录下创建相对应的资源文件" class="headerlink" title="在对应的overlay目录下创建相对应的资源文件"></a>在对应的overlay目录下创建相对应的资源文件</h3><p>想覆盖Android系统自带package中的资源文件，那么在overlay目录下必须包含喝替换package相同的路径，该路径是Android源码路径的相对路径</p><p>例如我们需要更改一下目录的资源文件：</p><pre><code>frameworks/base/core/res/res/values/dimens.xml那么就需要在overlay路径下创建相同的层级目录及文件：...／overlay/frameworks/base/core/res/res/values/dimens.xml修改overlay目录下dimens内容即可在打包时将对应数据替换到原来的资源文件中</code></pre><h3 id="使用aapt或者apktool查看对应文件apk中的res是否改变"><a href="#使用aapt或者apktool查看对应文件apk中的res是否改变" class="headerlink" title="使用aapt或者apktool查看对应文件apk中的res是否改变"></a>使用aapt或者apktool查看对应文件apk中的res是否改变</h3><pre><code>apktool d. *.apk</code></pre><h3 id="下面具体分析一下MSTAR平台下资源文件overlay的层级结构"><a href="#下面具体分析一下MSTAR平台下资源文件overlay的层级结构" class="headerlink" title="下面具体分析一下MSTAR平台下资源文件overlay的层级结构"></a>下面具体分析一下MSTAR平台下资源文件overlay的层级结构</h3><ol><li><p>目录层级如下：</p><pre><code>Overlay层级如下：device/mstar/avocado/overlay/frameworks／base/core/res/res/*原文件目录层级：frameworks/base/core/res/res／*</code></pre></li><li><p>overlay层级下mk文件编译说明</p><p> overlay文件下的device-common.mk文件又如下编译项：</p><pre><code>DEVICE_SOURCES := device/mstar/avocadoLOCAL_KERNEL := $(DEVICE_SOURCES)/kernelPRODUCT_PACKAGE_OVERLAYS := $(DEVICE_SOURCES)/overlay</code></pre><p> 这里可以看出：MSTAR使用的Overlay选项为PRODUCT_PACKAGE_OVERLAYS，其优先级比DEVICE_PACKAGE_OVERLAYS高</p></li><li><p>验证Overlay是否有效</p><pre><code>1. 修改overlay资源下文件下任意资源文件中的配置参数2. mm局部编译framework下res资源文件3. 拷贝出framework-res.apk查看其中配置文件是否改变</code></pre></li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过以上两种方式的Overlay机制，我们可以方便的移植定制我们的系统，一方面保持源码的干净完整，另一方面达到我们定制系统UI功能。</p><p>无论是代码overlay还是资源文件overlay，都免不了我们修改编译脚本的过程，其原理也就是使用控制脚本，动态的将原来的编译文件从新用新的文件进行替换，以达到无需修改源码和结构酒客轻松定制出自己的系统。</p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统音量相关总结</title>
      <link href="/FuckCode/2018/04/27/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8B%E9%9F%B3%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
      <url>/FuckCode/2018/04/27/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8B%E9%9F%B3%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="修改系统默认音量值"><a href="#修改系统默认音量值" class="headerlink" title="修改系统默认音量值"></a>修改系统默认音量值</h3><ul><li><p>路径：framework/base/media/java/android/media/AudioSystem.java</p><pre><code>public static int[] DEFAULT_STREAM_VOLUME = new int[] {      4,  // STREAM_VOICE_CALL      7,  // STREAM_SYSTEM      5,  // STREAM_RING     // MStar Android Patch Begin     //  this setting is subject to MAX_STREAM_VOLUME[STREAM_MUSIC] = 100 (in AudioService.java)      35, // STREAM_MUSIC     // MStar Android Patch End      6,  // STREAM_ALARM      5,  // STREAM_NOTIFICATION      7,  // STREAM_BLUETOOTH_SCO      7,  // STREAM_SYSTEM_ENFORCED      11, // STREAM_DTMF      11,  // STREAM_TTS      15   //STREAM_MUSIC_SUB  };</code></pre><p>由上可以看出，系统的各个通道的默认音量值会在这里定义，但是需要修改默认的音量值，仅仅在这里修改无法改变的，因为系统在其他地方默认的音量值进行了补充修改。具体可以看下面的代码：</p></li><li><p>路径：framework/base/services/core/java/com/android/server/audio/AudioService</p><pre><code>/** @hide */ public AudioService(Context context) {     //省略部分代码     int maxVolume = SystemProperties.getInt(&quot;ro.config.vc_call_vol_steps&quot;,             MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);     if (maxVolume != MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]) {         MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL] = maxVolume;         AudioSystem.DEFAULT_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL] = (maxVolume * 3) / 4;     }     maxVolume = SystemProperties.getInt(&quot;ro.config.media_vol_steps&quot;,             MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC]);     if (maxVolume != MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC]) {         MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC] = maxVolume;         AudioSystem.DEFAULT_STREAM_VOLUME[AudioSystem.STREAM_MUSIC] = (maxVolume * 3) / 4;     } }</code></pre><p>上面可以看出，在获取到系统的最大音量值的地方，系统队默认的音量值进行了重新定义。因此，如果需要对音量进行自定义修改，需要在这里进行适当的控制。</p></li></ul><h3 id="修改系统音量极值"><a href="#修改系统音量极值" class="headerlink" title="修改系统音量极值"></a>修改系统音量极值</h3><ul><li>路径：framework/base/services/core/java/com/android/server/audio/AudioService</li></ul><ol><li><p>最大值定义代码</p><pre><code>/** Maximum volume index values for audio streams */    private static int[] MAX_STREAM_VOLUME = new int[] {        // MStar Android Patch Begin        100,  // STREAM_VOICE_CALL        100,  // STREAM_SYSTEM        100,  // STREAM_RING        100,  // STREAM_MUSIC        100,  // STREAM_ALARM        100,  // STREAM_NOTIFICATION        100,  // STREAM_BLUETOOTH_SCO        100,  // STREAM_SYSTEM_ENFORCED        100,  // STREAM_DTMF        100,  // STREAM_TTS        100   // STREAM_MUSIC_SUB        // MStar Android Patch End    };</code></pre></li><li><p>最小值定义代码</p><pre><code>/** Minimum volume index values for audio streams */    private static int[] MIN_STREAM_VOLUME = new int[] {        // MStar Android Patch Begin        0,  // STREAM_VOICE_CALL        // MStar Android Patch End        0,  // STREAM_SYSTEM        0,  // STREAM_RING        0,  // STREAM_MUSIC        0,  // STREAM_ALARM        0,  // STREAM_NOTIFICATION        // MStar Android Patch Begin        0,  // STREAM_BLUETOOTH_SCO        // MStar Android Patch End        0,  // STREAM_SYSTEM_ENFORCED        0,  // STREAM_DTMF        0,   // STREAM_TTS        0   //STREAM_MUSIC_SUB    };</code></pre><p>上面定义了系统的各个通道的最大音量值和最小音量值。注意这里的最大最小只是划分的等级，如果划分等级变大了，单位调节音量时候，用户的感知就变小了，反之亦然。同时经过编译测试发现音量条会同步极值发生变化。</p></li></ol><p><strong><em>修改系统音量的两个方法说明</em></strong></p><ul><li>路径：framework/base/services/core/java/com/android/server/audio/AudioService</li></ul><ol><li><p>渐进式：adjustStreamVolume<br> 根据音量键进行声音的递增和递减</p></li><li><p>跳跃式：setStreamVolume<br> 根据音量值，直接可以设置音量的大小</p></li></ol><h3 id="功放音量约束实现"><a href="#功放音量约束实现" class="headerlink" title="功放音量约束实现"></a>功放音量约束实现</h3><p>根据公司的需求，在设置电视外放的功放时候，要求音量极值100情况下65为最大，否则电视外放会出现破音、失真情况。这种情况下，我们需要监控所有的音量控制接口，使得其音量控制均系统程序控制内。第三方app也要受到约束。为此，我们需要找到音量控制相对应的aidl文件，根据aidl文件找到其映射的c++文件,直接在底层c++修改约束条件。</p><ul><li>在设置音量值，我们会首先回去到AudioManager服务，这个服务在安卓系统启动的时候，已经通过system_server注册过。在AudioManager中的控制音量方法代码如下：</li></ul><ol><li><p>渐进式：</p><p> public void adjustStreamVolume(int streamType, int direction, int flags) {</p><pre><code>IAudioService service = getService();try {    service.adjustStreamVolume(streamType, direction, flags,            getContext().getOpPackageName());} catch (RemoteException e) {    Log.e(TAG, &quot;Dead object in adjustStreamVolume&quot;, e);}</code></pre><p> }</p></li><li><p>跳跃式：</p><p> public void setStreamVolume(int streamType, int index, int flags) {</p><pre><code>IAudioService service = getService();try {    service.setStreamVolume(streamType, index, flags, getContext().getOpPackageName());} catch (RemoteException e) {    Log.e(TAG, &quot;Dead object in setStreamVolume&quot;, e);}</code></pre><p> }</p></li></ol><p>由上面可以看出，其最终是通过从Server端获取到的IAudioService（service）对象，调用其声的aidl接口方法。</p><ul><li><p>IAudioService的aidl接口文件</p><pre><code>interface IAudioService {    oneway void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags,            String callingPackage, String caller);    void adjustStreamVolume(int streamType, int direction, int flags, String callingPackage);    void setStreamVolume(int streamType, int index, int flags, String callingPackage);    //省略部分}</code></pre><p>Client端根据定义好的aidl文件，对应Server端的c++文件，通过binder机制远程调用，jni实现底层音量的控制。<br>在查找过程中发现有些文件方法没有写全，是因为在IAudioService.aidl文件中，import了其他的aidl文件，因此这里的aidl文件是总文件，所以我们根据这个aidl文件，找到对应的c++文件即可。<br>根据其定义native方法的包名、类名，可以对应拼出其jni的实现文件名为android_media_AudioSystem.cpp</p></li><li><p>音量控制jni文件android_media_AudioSystem.cpp，在gMethods中，定义了方法的一一映射关系</p><pre><code>static JNINativeMethod gMethods[] = {    //省略部分    {&quot;setParameters&quot;,        &quot;(Ljava/lang/String;)I&quot;, (void *)android_media_AudioSystem_setParameters},    {&quot;initStreamVolume&quot;,    &quot;(III)I&quot;,   (void *)android_media_AudioSystem_initStreamVolume},    {&quot;setStreamVolumeIndex&quot;,&quot;(III)I&quot;,   (void *)android_media_AudioSystem_setStreamVolumeIndex},    //省略部分}</code></pre></li><li><p>修改C++层其最终调用的方法</p><pre><code>static jintandroid_media_AudioSystem_setStreamVolumeIndex(JNIEnv *env,                                               jobject thiz,                                               jint stream,                                               jint index,                                               jint device){    //new code for restraining volume    index = jint(index * 65 / 100);    return (jint) check_AudioSystem_Command(            AudioSystem::setStreamVolumeIndex(static_cast &lt;audio_stream_type_t&gt;(stream),                                              index,                                              (audio_devices_t)device));}</code></pre><p>在这里我们增加约束条件即可实现从最底层修改声音的控制，无论是系统还是第三方应用均会受到制约</p></li></ul><h3 id="修改音量条"><a href="#修改音量条" class="headerlink" title="修改音量条"></a>修改音量条</h3><ul><li><p>路径：framework/base/packages/SystemUI/src/com/android/systemui/volume/VolumeDialog.java</p></li><li><p>减少音量通道</p><pre><code>addRow(AudioManager.STREAM_RING,            R.drawable.ic_volume_ringer, R.drawable.ic_volume_ringer_mute, true);addRow(AudioManager.STREAM_MUSIC,        R.drawable.ic_volume_hint, R.drawable.ic_volume_hint, true);addRow(AudioManager.STREAM_ALARM,        R.drawable.ic_volume_alarm, R.drawable.ic_volume_alarm_mute, false);addRow(AudioManager.STREAM_VOICE_CALL,        R.drawable.ic_volume_voice, R.drawable.ic_volume_voice, false);addRow(AudioManager.STREAM_BLUETOOTH_SCO,        R.drawable.ic_volume_bt_sco, R.drawable.ic_volume_bt_sco, false);addRow(AudioManager.STREAM_SYSTEM,        R.drawable.ic_volume_system, R.drawable.ic_volume_system_mute, false);</code></pre></li></ul><p>addRow方法实现了音量条下多通道声音控制的加载</p><ul><li><p>音量条样式自定义</p><p>  修改对应文件加下res/layout布局文件，在make之前，先make res一下，将res资源更新，否则会找不到资源，出现编译错误</p></li><li><p>修改音量动画</p><p>  修改其文件夹中的VolumeDialogMotion.java文件即可</p></li><li><p>监测控制音量按键</p><p>  其文件夹下的VolumeDialogController实现了广播的监听，修改这里即可</p></li><li><p>修改音量策略（增加音量跳出静音模式等）</p><p>  修改文件夹下的VolumeDialogComponent文件中的VolumePolicy即可</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码修改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 系统定制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遥控器快捷按键实现</title>
      <link href="/FuckCode/2018/04/27/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8B%E9%81%A5%E6%8E%A7%E5%BF%AB%E6%8D%B7%E9%80%9A%E9%81%93%E6%B7%BB%E5%8A%A0/"/>
      <url>/FuckCode/2018/04/27/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8B%E9%81%A5%E6%8E%A7%E5%BF%AB%E6%8D%B7%E9%80%9A%E9%81%93%E6%B7%BB%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="源码修改之遥控器快捷通道添加"><a href="#源码修改之遥控器快捷通道添加" class="headerlink" title="源码修改之遥控器快捷通道添加"></a>源码修改之遥控器快捷通道添加</h3><ul><li><p>获取遥控快捷通道按键的keycode</p><p>logcat下遥控器按键值和源码keycode值，对应如下：</p><pre><code>public static final int KEYCODE_PROG_RED        = 183;public static final int KEYCODE_PROG_GREEN      = 184;public static final int KEYCODE_PROG_YELLOW     = 185;public static final int KEYCODE_PROG_BLUE       = 186;</code></pre></li><li><p>需求如下：</p><pre><code>KEYCODE_PROG_RED                AV[1,2]KEYCODE_PROG_GREEN              HDMI[1,2,3]KEYCODE_PROG_YELLOW             DTVKEYCODE_PROG_BLUE               ATV</code></pre></li><li><p>查找电视通道切换代码位置及方式</p><p>设备切换到电视界面，不断地切换通道，记录当前activity情况（dumpsys activity）<br>得到信息归纳集中如下：</p></li></ul><ol><li><p>所有电视通道下的主界面activity均为RootActivity.java</p><p>   路径如下：：device/mstar/common/apps/MTvPlayer/src/com/mstar/tv/tvplayer/ui/RootActivity.java</p></li><li><p>各通道信息代码使用int值表示，具体信息如下：</p><pre><code>INPUT_SOURCE_ATV = 1;INPUT_SOURCE_CVBS = 2;INPUT_SOURCE_CVBS2 = 3;INPUT_SOURCE_HDMI = 23;INPUT_SOURCE_HDMI2 = 24;INPUT_SOURCE_HDMI3 = 25;INPUT_SOURCE_DTV = 28;</code></pre></li><li><p>切换电视通道后，直接启动电视的apk软件，即可进入相应的通道</p><pre><code>//初始化intentIntent shortcutIntent = new Intent();shortcutIntent.setComponent(new ComponentName(&quot;com.mstar.tv.tvplayer.ui&quot;,    &quot;com.mstar.tv.tvplayer.ui.RootActivity&quot;));// 此处设置电视通道即可// ...shortcutIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);mContext.startActivity(shortcutIntent);</code></pre></li><li><p>获取及设置电视通道</p><pre><code>// 获取通道信息int currentTvInputSource = TvCommonManager.getInstance().getCurrentTvInputSource();// 设置通道信息TvCommonManager.getInstance().setInputSource(1);</code></pre></li></ol><ul><li>添加代码</li></ul><ol><li><p>我们知道系统按键的分发过程中肯定会走PhoneWindowManager中的interceptKeyBeforeDispatching方法，如果按键没有下层处理，这里会收到两次事件，我们这里添加我们的遥控按键处理流程</p><pre><code>// new code by allies beginelse if (keyCode == KeyEvent.KEYCODE_PROG_RED || keyCode == KeyEvent.KEYCODE_PROG_GREEN ||          keyCode == KeyEvent.KEYCODE_PROG_YELLOW || keyCode == KeyEvent.KEYCODE_PROG_BLUE) {    if (down) {        launchShortcut(keyCode);        // do interceptKeyEvent        return -1;      }}// new code by allies end// new code by allies beginprivate static int av = 2;private static int hdmi = 23;private static int mAntennaType = 0;private void launchShortcut(int keycode) {    final int currentTvInputSource = TvCommonManager.getInstance().getCurrentTvInputSource();    final boolean withinTV = getTopActivity();    if (TvCommonManager.getInstance().getCurrentTvSystem() == TvCommonManager.TV_SYSTEM_ISDB) {        mAntennaType = (keycode == 185 ? 2 : 1);    }    Intent shortcutIntent1 = new Intent(&quot;com.mstar.android.intent.action.START_TV_PLAYER&quot;);    shortcutIntent1.putExtra(&quot;inputAntennaType&quot;, mAntennaType);    shortcutIntent1.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);    shortcutIntent1.addFlags(8192);    Intent shortcutIntent2 = new Intent(&quot;mstar.tvsetting.ui.intent.action.RootActivity&quot;);    switch (keycode) {        case KeyEvent.KEYCODE_PROG_RED:            //keycode(183) AV[CVBS1-8] inputsource(2-9)            if (withinTV &amp;&amp; currentTvInputSource == 2 || currentTvInputSource ==3) {                av++;                if (av &gt;= 4) {                    av = 2;                }            }            TvCommonManager.getInstance().setInputSource(av);            shortcutIntent1.putExtra(&quot;inputSrc&quot;, av);            break;        case KeyEvent.KEYCODE_PROG_GREEN:            //(184) HDMI(23) HDMI1(24) HDMI2(25) HDMI3(26)            if (withinTV  &amp;&amp; currentTvInputSource == 23 || currentTvInputSource == 24 ||                currentTvInputSource == 25) {                hdmi++;                if (hdmi &gt;= 26) {                    hdmi = 23;                }            }            TvCommonManager.getInstance().setInputSource(hdmi);            shortcutIntent1.putExtra(&quot;inputSrc&quot;, hdmi);            break;        case KeyEvent.KEYCODE_PROG_YELLOW:            //(185) ATV(1) inputAntennaType 2            if (withinTV &amp;&amp; currentTvInputSource == 1) {                return;            }            TvCommonManager.getInstance().setInputSource(1);            shortcutIntent1.putExtra(&quot;inputSrc&quot;, 1);            break;        case KeyEvent.KEYCODE_PROG_BLUE:            //(186) DTV(28) inputAntennaType 1            if (withinTV &amp;&amp; currentTvInputSource == 28) {                return;            }            TvCommonManager.getInstance().setInputSource(28);            shortcutIntent1.putExtra(&quot;inputSrc&quot;, 28);          break;      }        mContext.startActivity(shortcutIntent1);        if (withinTV) {            shortcutIntent2.putExtra(&quot;task_tag&quot;, &quot;input_source_changed&quot;);        }else{            shortcutIntent2.putExtra(&quot;no_change_source&quot;, true);        }        shortcutIntent2.putExtra(&quot;inputAntennaType&quot;, mAntennaType);        mContext.startActivity(shortcutIntent2);}// new code by allies end</code></pre></li></ol><ol start="2"><li><p>为了提高用户体验，例如在hdmi通道下，连续点按HDMI快捷键，是在各个HDMI通道下进行切换，如果当前界面不是在电视apk下，用户点击HDMI快捷键，直接进入上次的通道（HDMI通道不做切换）</p><pre><code>处于tv应用内，且当前通道位于HDMI下，HDMI通道自动切换if (withinTV &amp;&amp; currentTvInputSource == 2 || currentTvInputSource ==3){  // ...}</code></pre></li><li><p>实现这个功能，需要获取当前resume的activity进行判断，无奈在安卓6.0中相应获取正在运行的api已经不能正常使用，这里测试一下通过如下代码可以获取到最近的进程名</p><pre><code>private boolean getTopActivity() {     ActivityManager manager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);     List&lt;ActivityManager.RunningAppProcessInfo&gt; runningAppProcesses = manager.getRunningAppProcesses();     Iterator&lt;ActivityManager.RunningAppProcessInfo&gt; iterator = runningAppProcesses.iterator();     //get top-activity     ActivityManager.RunningAppProcessInfo processInfo = iterator.next();     String processName = processInfo.processName;     //within tv-apk     if (processName.equals(&quot;com.mstar.tv.tvplayer.ui&quot;) ||             // processName.equals(&quot;com.jrm.localmm&quot;) ||             processName.equals(&quot;com.mstar.tvsetting&quot;)) {         return true;     }else {         return false;     } }</code></pre><p> 经测试发现，在PhoneWindowManager下调用可以准确获取运行的进程名</p></li></ol><ul><li><p>编译生成测试</p><ol><li><p>mm -B 编译当前代码路径</p></li><li><p>cd .. 后 cproj 跳到当前文件mk路径 mm -B 编译当前文件</p></li><li><p>同步步骤2，编译发现生成service.jar,替换系统中相应文件测试即可</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码修改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 系统定制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile之文件名操作函数</title>
      <link href="/FuckCode/2018/04/26/Makefile%E4%B9%8B%E6%96%87%E4%BB%B6%E5%90%8D%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/"/>
      <url>/FuckCode/2018/04/26/Makefile%E4%B9%8B%E6%96%87%E4%BB%B6%E5%90%8D%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Makefile之文件名操作函数"><a href="#Makefile之文件名操作函数" class="headerlink" title="Makefile之文件名操作函数"></a>Makefile之文件名操作函数</h3><ol><li><p>取目录函数-dir</p><pre><code>$(dir &lt;names...&gt; )名称：取目录函数 dir功能：从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。返回：返回文件名序列&lt;names&gt;的目录部分。示例：@echo $(dir /home/a.c ./bb.c ../c.c d.c)==&gt; /home/ ./ ../ ./</code></pre></li><li><p>取文件名称函数-notdir</p><pre><code>$(nodir &lt;names&gt;)名称：取文件函数 notdir,包括后缀，去除文件夹路径；功能：从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分返回：返回文件名序列&lt;names&gt;的非目录部分示例： @echo $(notdir /home/a.c ./bb.c ../c.c d.c)==&gt; a.c bb.c c.c d.c</code></pre></li><li><p>取后缀函数-suffix</p><pre><code>$(suffix &lt;names...&gt; )名称：取后缀函数 suffix功能：从文件名序列&lt;names&gt;中取出各个文件名的后缀。返回：返回文件名序列&lt;names&gt;的后缀序列，如果文件没有后缀，则返回空字串。示例：@echo $(suffix /home/a.c ./b.o ../c.a d)==&gt; .c .o .a</code></pre></li><li><p>取前缀函数-basename</p><pre><code>$(basename &lt;names...&gt; )名称：取前缀函数——basename。包括路径；功能：从文件名序列&lt;names&gt;中取出各个文件名的前缀部分。返回：返回文件名序列&lt;names&gt;的前缀序列，如果文件没有前缀，则返回空字串。示例：@echo $(basename /home/a.c ./b.o ../c.a /home/.d .e)==&gt; /home/a ./b ../c /home/</code></pre></li><li><p>加后缀函数-addsuffix</p><pre><code>$(addsuffix &lt;suffix&gt;,&lt;names...&gt; )名称：加后缀函数 addsuffix功能：把后缀&lt;suffix&gt;加到&lt;names&gt;中的每个单词后面。返回：返回加过后缀的文件名序列。示例：@echo $(addsuffix .c,/home/a b ./c.o ../d.c)==&gt; /home/a.c b.c ./c.o.c ../d.c.c</code></pre></li><li><p>加前缀函数-addprefix</p><pre><code>$(addprefix &lt;prefix&gt;,&lt;names...&gt; )名称：加前缀函数 addprefix。功能：把前缀&lt;prefix&gt;加到&lt;names&gt;中的每个单词后面。返回：返回加过前缀的文件名序列。示例：@echo $(addprefix test_,/home/a.c b.c ./d.c)==&gt; test_/home/a.c test_b.c test_./d.c</code></pre></li><li><p>连接函数-join</p><pre><code>$(join &lt;list1&gt;,&lt;list2&gt; )名称：连接函数 join功能：把&lt;list2&gt;中的单词对应地加到&lt;list1&gt;的单词后面。如果&lt;list1&gt;的单词个数要比&lt;list2&gt;的多，那么，&lt;list1&gt;中的多出来的单词将保持原样。如果&lt;list2&gt;的单词个数要比&lt;list1&gt;多，那么，&lt;list2&gt;多出来的单词将被复制到&lt;list2&gt;中。对应位置的叠加，多余的原样输出；返回：返回连接过后的字符串。示例：@echo $(join a b c d,1 2 3 4)@echo $(join a b c d,1 2 3 4 5)@echo $(join a b c d e,1 2 3 4)a1 b2 c3 d4a1 b2 c3 d4 5a1 b2 c3 d4 e</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于调用intermediates下中间文件流程分析</title>
      <link href="/FuckCode/2018/04/26/%E5%85%B3%E4%BA%8E%E8%B0%83%E7%94%A8intermediates%E4%B8%8B%E4%B8%AD%E9%97%B4%E6%96%87%E4%BB%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/FuckCode/2018/04/26/%E5%85%B3%E4%BA%8E%E8%B0%83%E7%94%A8intermediates%E4%B8%8B%E4%B8%AD%E9%97%B4%E6%96%87%E4%BB%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="关于调用intermediates下中间文件流程分析"><a href="#关于调用intermediates下中间文件流程分析" class="headerlink" title="关于调用intermediates下中间文件流程分析"></a>关于调用intermediates下中间文件流程分析</h3><p><strong>最近查看安卓源码在分析其Oberlay机制，无意中发现call intermediates-dir-for 方法的调用，其后面跟了好许参数，就在这里深入的分析了解一下，原代码文件基于Mstar定制的android6.0分析</strong></p><ul><li><p>$(call intermediates-dir-for,,,,)/src</p></li><li><p>代码：build/core/definitions.mk</p><pre><code># $(1): target class, like &quot;APPS&quot;# $(2): target name, like &quot;NotePad&quot;# $(3): if non-empty, this is a HOST target.# $(4): if non-empty, force the intermediates to be COMMON# $(5): if non-empty, force the intermedistes to be for the 2nd archdefine intermediates-dir-for$(strip \    $(eval _idfClass := $(strip $(1))) \    $(if $(_idfClass),, \        $(error $(LOCAL_PATH): Class not defined in call to intermediates-dir-for)) \    $(eval _idfName := $(strip $(2))) \    $(if $(_idfName),, \        $(error $(LOCAL_PATH): Name not defined in call to intermediates-dir-for)) \    $(eval _idfPrefix := $(if $(strip $(3)),HOST,TARGET)) \    $(eval _idf2ndArchPrefix := $(if $(strip $(5)),$(TARGET_2ND_ARCH_VAR_PREFIX))) \    $(if $(filter $(_idfPrefix)-$(_idfClass),$(COMMON_MODULE_CLASSES))$(4), \        $(eval _idfIntBase := $($(_idfPrefix)_OUT_COMMON_INTERMEDIATES)) \      ,$(if $(filter $(_idfClass),SHARED_LIBRARIES STATIC_LIBRARIES EXECUTABLES GYP),\          $(eval _idfIntBase := $($(_idf2ndArchPrefix)$(_idfPrefix)_OUT_INTERMEDIATES)) \       ,$(eval _idfIntBase := $($(_idfPrefix)_OUT_INTERMEDIATES)) \       ) \     ) \    $(_idfIntBase)/$(_idfClass)/$(_idfName)_intermediates \)endef代码中接受的几个重要参数如下：参数1: _idfClass参数2: _idfName参数3: _idfPrefix参数4: _idfIntBase参数5：_idf2ndArchPrefix</code></pre></li><li><p>示例：</p><pre><code>framework_GENERATED_SOURCE_DIR := $(call intermediates-dir-for,JAVA_LIBRARIES,framework,,COMMON)/src示例传入参数如下：参数1：JAVA_LIBRARIES参数2: framework参数3: 参数4: COMMON参数5:</code></pre></li></ul><ol><li><p>参数1赋值过程</p><pre><code>$(eval _idfClass := $(strip $(1))) \    $(if $(_idfClass),, \        $(error $(LOCAL_PATH): Class not defined in call to intermediates-dir-for)) \获取第一个参数，直接赋值给_idfClass=JAVA_LIBRARIES;如果为空，直接报错</code></pre></li><li><p>参数2赋值过程</p><pre><code>$(eval _idfName := $(strip $(2))) \    $(if $(_idfName),, \        $(error $(LOCAL_PATH): Name not defined in call to intermediates-dir-for)) \获取传入的第二个参数，赋值到_idfName=framework;如果为空，直接报错</code></pre></li><li><p>参数3赋值过程</p><pre><code>$(eval _idfPrefix := $(if $(strip $(3)),HOST,TARGET)) \获取传入的第三个参数，如果不为空，则为“HOST”，否则是“TARGET”，这里传入的为空，即_idfPrefix=TARGET</code></pre></li><li><p>参数4赋值过程</p><pre><code>$(if $(filter $(_idfPrefix)-$(_idfClass),$(COMMON_MODULE_CLASSES))$(4), \        $(eval _idfIntBase := $($(_idfPrefix)_OUT_COMMON_INTERMEDIATES)) \      ,$(if $(filter $(_idfClass),SHARED_LIBRARIES STATIC_LIBRARIES EXECUTABLES GYP),\          $(eval _idfIntBase := $($(_idf2ndArchPrefix)$(_idfPrefix)_OUT_INTERMEDIATES)) \       ,$(eval _idfIntBase := $($(_idfPrefix)_OUT_INTERMEDIATES)) \       ) \     ) \判断1:     过滤在  $(_idfPrefix)-$(_idfClass) 中存在匹配条件 TARGET-NOTICE_FILES HOST-NOTICE_FILES HOST-JAVA_LIBRARIES中任意项目，如果存在不为空，直接取值$(4)；    否则，_idfIntBase=(_idfPrefix)_OUT_COMMON_INTERMEDIATES判断2:     过滤 _idfClass 中存在 SHARED_LIBRARIES STATIC_LIBRARIES EXECUTABLES GYP 中任意值，如结果不为空，_idfIntBase := $($(_idf2ndArchPrefix)$(_idfPrefix)_OUT_INTERMEDIATES)) ；    否则，_idfIntBase := $($(_idfPrefix)_OUT_INTERMEDIATES))此处由上此处传入的是“COMMMON”，分析得出 _idfIntBase=TARGET_OUT_COMMON_INTERMEDIATES</code></pre></li><li><p>参数5赋值过程</p><pre><code>$(eval _idf2ndArchPrefix := $(if $(strip $(5)),$(TARGET_2ND_ARCH_VAR_PREFIX))) \如果存在参数5不为空，直接取值 _idf2ndArchPrefix ：= $(TARGET_2ND_ARCH_VAR_PREFIX)</code></pre></li><li><p>具体路径查找替换</p><pre><code>$(_idfIntBase)/$(_idfClass)/$(_idfName)_intermediates \)由上分析这里可以替换出具体路径如下：TARGET_OUT_COMMON_INTERMEDIATES/JAVA_LIBRARIES/framework_intermediates下面具体找到TARGET_OUT_COMMON_INTERMEDIATES的具体路径</code></pre></li><li><p>关于TARGET_OUT_COMMON_INTERMEDIATES的具体路径</p><pre><code>相关Makefile路径代码：build/envsetup.mkTARGET_OUT_COMMON_INTERMEDIATES := $(TARGET_COMMON_OUT_ROOT)/objTARGET_COMMON_OUT_ROOT := $(TARGET_OUT_ROOT)/commonTARGET_OUT_ROOT := $(TARGET_OUT_ROOT_$(TARGET_BUILD_TYPE))    ifneq ($(TARGET_BUILD_TYPE),debug)    TARGET_BUILD_TYPE := release    endif此处默认为releaseTARGET_OUT_ROOT_release := $(OUT_DIR)/targetTARGET_OUT_ROOT_debug := $(DEBUG_OUT_DIR)/targetifeq (,$(strip $(OUT_DIR)))ifeq (,$(strip $(OUT_DIR_COMMON_BASE)))OUT_DIR := $(TOPDIR)outelseOUT_DIR := $(OUT_DIR_COMMON_BASE)/$(notdir $(PWD))endifendif此处OUT_DIR为源码的根目录因此，TARGET_OUT_COMMON_INTERMEDIATES=out/target/common/obj</code></pre></li><li><p>综上分析得出最终的路径如下：</p><pre><code>/out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src</code></pre></li></ol><ul><li><p>相关拓展</p><p>  <a href="https://blog.csdn.net/zhoujiaxq/article/details/25972743" target="_blank" rel="noopener">Makefile函数集锦及条件判断</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apktool 使用一览</title>
      <link href="/FuckCode/2018/03/22/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/FuckCode/2018/03/22/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="apktool使用说明"><a href="#apktool使用说明" class="headerlink" title="apktool使用说明"></a>apktool使用说明</h3><ol><li><p>确保电脑当前版本的jdk至少1.7以上</p></li><li><p>下载页面wrapper script右击保存为*.bat脚本文件</p><blockquote><p><a href="https://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">链接</a></p></blockquote></li><li><p>下载apktool到本地</p><blockquote><p><a href="https://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">链接</a></p></blockquote></li><li><p>修改重命名文件名为:apktool</p></li><li><p>将两个文件移动到指定目录下:</p><ul><li><p>windows -&gt; c://Windows (usually)</p></li><li><p>Linux -&gt; /usr/local/bin (root needed)</p></li><li><p>Mac -&gt; /usr/local/bin (root needed)</p><p><strong> 如果是Linux或者Mac,需要修改两个文件的权限 chmod +X </strong></p></li></ul></li><li><p>终端运行apktool d *.apk 即可将apk资源文件提取到当前文件夹下</p><pre><code>示例如下:    $ apktool d test.apk    I: Using Apktool 2.3.1 on test.apk    I: Loading resource table...    I: Decoding AndroidManifest.xml with resources...    I: Loading resource table from file: 1.apk    I: Regular manifest package...    I: Decoding file-resources...    I: Decoding values */* XMLs...    I: Baksmaling classes.dex...    I: Copying assets and libs...    I: Copying unknown files...    I: Copying original files...    $ apktool b test    I: Using Apktool 2.3.1 on test    I: Checking whether sources has changed...    I: Smaling smali folder into classes.dex...    I: Checking whether resources has changed...    I: Building resources...    I: Building apk file...    I: Copying unknown files/dir...</code></pre></li></ol><pre><code>* 使用java -jar apktool.jar获取帮助    &gt; https://ibotpeaches.github.io/Apktool/documentation/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反编译 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包应用到系统</title>
      <link href="/FuckCode/2018/03/17/%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9apk%E5%88%B0%E7%B3%BB%E7%BB%9F/"/>
      <url>/FuckCode/2018/03/17/%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9apk%E5%88%B0%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="源码编译之添加第三方应用到系统"><a href="#源码编译之添加第三方应用到系统" class="headerlink" title="源码编译之添加第三方应用到系统"></a>源码编译之添加第三方应用到系统</h3><h4 id="不加源码-只添加apk到系统"><a href="#不加源码-只添加apk到系统" class="headerlink" title="不加源码,只添加apk到系统"></a>不加源码,只添加apk到系统</h4><ol><li><p>在安卓源码路径/packages/apps下新建自己的app路径</p></li><li><p>新建Android.mk文件,如添加QQyinle.apk到系统,如下代码:</p><pre><code>LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := QQyinleLOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := $(LOCAL_MODULE).apkLOCAL_MODULE_CLASS := APPSLOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)LOCAL_CERTIFICATE := platform# false -&gt; /system/app/# true -&gt; /system/priv-app/LOCAL_PRIVILEGED_MODULE := trueLOCAL_BUILT_MODULE_STEM := package.apkinclude $(BUILD_PREBUILT)</code></pre></li><li><p>添加程序到device.mk文件</p><ol><li>查找到源码中对应的device.mk文件，添加自己的apk到系统（内置），当然也可以删除，例如：</li><li><p>路径：device/mstar/almond/device.mk</p><pre><code># AppsPRODUCT_PACKAGES += \    QQyinle \           &lt;-- 此处添加自己的app    livecap \    MLeanbackTv \    MTvPlayer \    MTvHotkey \    MTvMisc \    MTvFactory \    MTvTest \    MBrowser3 \    MLocalMM2 \    MMCastDemo \    Launcher3 \#    DMP \    DMS</code></pre></li></ol></li><li><p>局部编译代码 mmm -B packages/apps/M_QQyinyue/(M_QQyinyue是自己建立的)</p><p>   生成对应文件在android/out/target/product/almond/system/priv-app/M_QQyinyue/路径下</p></li><li><p>make snod 将生成文件打包到system.img中即可</p></li></ol><h4 id="添加带源码的应用到系统"><a href="#添加带源码的应用到系统" class="headerlink" title="添加带源码的应用到系统"></a>添加带源码的应用到系统</h4><ol><li>未经测试,待续</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac地址批量生成bin包说明</title>
      <link href="/FuckCode/2018/03/07/%E6%89%B9%E9%87%8FMac%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%E8%AF%B4%E6%98%8E/"/>
      <url>/FuckCode/2018/03/07/%E6%89%B9%E9%87%8FMac%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="生成Mac地址-并制作mac-bin用于刷写"><a href="#生成Mac地址-并制作mac-bin用于刷写" class="headerlink" title="生成Mac地址,并制作mac.bin用于刷写"></a>生成Mac地址,并制作mac.bin用于刷写</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h4><p><strong><em>MAC地址由12位16进制的数字组成,同过申请或者购买可以获得一连串的Mac地址字符串,我们需要将这一连串的mac地址按照同意统一要求制作成单一的bin文件刷写,同时在刷写完成便删除此文件</em></strong></p><ol><li><p>通过提供起始mac地址,mac地址的个数以及mac文件命规则,批量生成mac.bin文件</p></li><li><p>采用java的写如流操作,批量生成.bin文件</p></li><li><p>为了便于测试,先采用string字符串写入文件进行查看测试</p></li><li><p>测试无误,在采用string转buye二进制数据进行写如文件</p></li><li><p>写入完成,同时提供测试批量打印输出写ru的bin文件是否符合要求(转码是否有误)</p></li></ol><h4 id="具体代码如下"><a href="#具体代码如下" class="headerlink" title="具体代码如下:"></a>具体代码如下:</h4><pre><code>public class MacToBin {    // 文件路径    public static String filePath = &quot;Mac&quot;;    // 统一起始文件名    public static String fileName = &quot;Mac/mac&quot;;    // Mac地址递增数    public static int macCount = 300;    // 起始Mac地址    public static String macStart = &quot;00:70:A4:00:00:00&quot;;    // 批量制作还是打印标志位    public static boolean makeMac = false;    public static void main(String[] args) {        // 制作        if (makeMac) {            // 文件存在判断            File file = new File(filePath);            if (file.exists()) {                if (file.isDirectory()) {                    File[] files = file.listFiles();                    //  遍历删除文件                    for (int i = 0; i &lt; files.length; i++) {                        files[i].delete();                    }                    file.delete();                }                file.delete();            }            file.mkdir();            // 设定文件起始地址, 以及数量            makingMac();        } else {            //打印            printMac();        }    }    // 批量生成bin文件    private static void makingMac() {        String start = macStart.replaceAll(&quot;:&quot;, &quot;&quot;);        BigInteger num = new BigInteger(start, 16);        BigInteger addNum = new BigInteger(&quot;1&quot;);        String result = &quot;&quot;;        for (int i = 0; i &lt; macCount; i++) {            try {                StringBuilder macName = new StringBuilder(fileName).append(i).append(&quot;.bin&quot;);                // 中间生成文件测试//                FileWriter writer = new FileWriter(new File(macName.toString()), true);                FileOutputStream fos = new FileOutputStream(macName.toString());                result = num.toString(16).toUpperCase();                for (int j = 12 - result.length(); j &gt; 0; j--) {                    result = &quot;0&quot; + result;                }                num = num.add(addNum);                fos.write(hexStringToBytes(getMacAdr(result)));                fos.close();                System.out.println(getMacAdr(result));                // 测试//                writer.write(getMacAdr(result));//                writer.close();            } catch (IOException e) {                e.printStackTrace();            }        }        System.out.println(&quot;finished&quot;);    }    // 批量打印测试代码段    public static void printMac() {        File file = new File(filePath);        if (!file.exists()) {            System.out.println(&quot;No file exist!&quot;);            return;        } else {            if (!file.isDirectory())                System.out.println(&quot;The file is no directory!&quot;);            else {                StringBuffer sb = new StringBuffer();                try {                    // 批量打印                    for (int i = 0; i &lt; macCount; i++) {                        StringBuilder macName = new StringBuilder(fileName).append(i).append(&quot;.bin&quot;);                        File macfile = new File(macName.toString());                        if (macfile.exists()) {                            FileInputStream in = new FileInputStream(macfile);                            byte[] temp = new byte[1];                            while (in.read(temp) != -1) {                                appendHexPair(temp[0], sb);                                sb.append(&quot;:&quot;);                            }                            in.close();                        }                        String tempMac = sb.toString();                        // 清空                        sb.setLength(0);//                        System.out.println(tempMac);                        String macaddr = tempMac.substring(0, tempMac.length() - 1);                        System.out.println(macaddr);                    }                } catch (Exception e) {                    e.printStackTrace();                }                System.out.println(&quot;Print mafFile finished!&quot;);            }        }    }    private static void appendHexPair(byte bt, StringBuffer stringbuffer) {        char[] hexDigits = new char[]{&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;};        char c0 = hexDigits[(bt &amp; 240) &gt;&gt; 4];        char c1 = hexDigits[bt &amp; 15];        stringbuffer.append(c0);        stringbuffer.append(c1);    }    private static String getMacAdr(String str) {        StringBuilder result = new StringBuilder(&quot;&quot;);        for (int i = 1; i &lt;= 12; i++) {            result.append(str.charAt(i - 1));//            if (i % 2 == 0) {//                result.append(&quot;:&quot;);//            }        }//        return result.substring(0, 17);        return result.toString();    }    /**     * 16进制字符串转换为byte[]     *     * @param hexString     * @return     */    public static byte[] hexStringToBytes(String hexString) {        if (hexString == null || hexString.equals(&quot;&quot;)) {            return null;        }        hexString = hexString.toUpperCase().replace(&quot; &quot;, &quot;&quot;);        int length = hexString.length() / 2;        char[] hexChars = hexString.toCharArray();        byte[] d = new byte[length];        for (int i = 0; i &lt; length; i++) {            int pos = i * 2;            d[i] = (byte) (charToByte(hexChars[pos]) &lt;&lt; 4 | charToByte(hexChars[pos + 1]));        }        return d;    }    private static byte charToByte(char c) {        return (byte) &quot;0123456789ABCDEF&quot;.indexOf(c);    }}</code></pre><h4 id="工厂mac地址刷写说明"><a href="#工厂mac地址刷写说明" class="headerlink" title="工厂mac地址刷写说明"></a>工厂mac地址刷写说明</h4><ol><li><p>检查/mnt/usb下是否存在(挂载U盘),是否存在MAC的文件夹</p></li><li><p>存在, 列出当前文件夹下所有文件,判断第一个文件是否存在</p></li><li><p>使用FileInputStream读流,获取字符串保存于tempMac中,同过裁剪获取最终的macaddr地址</p></li><li><p>获取本机存在的mac地址,CtvTvManager.getInstance().getEnvironment(mac_ethAddr),检查刷写和存在是否存在冲突(一样),一样,删除刷写的文件</p></li><li><p>不一样,执行刷写操作,CtvTvManager.getInstance().setEnvironment(mac_ethAddr, macaddr)</p></li><li><p>删除刷写的文件,避免刷写一样的mac地址</p><pre><code>public static final String MAC = &quot;MAC&quot;;private static String mac_ethAddr = &quot;macaddr&quot;;static int UpgradeMAC() {      int ret = 0;      try {          File listMacfile = new File(checkFileIsExist(&quot;/mnt/usb&quot;, Constant.MAC));          if (!listMacfile.exists()) {              return EnumUpgradeStatus.E_UPGRADE_FILE_NOT_FOUND.ordinal();          }          File macfile = listMacfile.listFiles()[0];          StringBuffer sb = new StringBuffer();          try {              if (macfile.exists()) {                  FileInputStream in = new FileInputStream(macfile);                  byte[] temp = new byte[1];                  while (in.read(temp) != -1) {                      appendHexPair(temp[0], sb);                      sb.append(&quot;:&quot;);                  }                  in.close();              } else {                  ret = EnumUpgradeStatus.E_UPGRADE_FILE_NOT_FOUND.ordinal();              }              String tempMac = sb.toString();              Log.d(TAG, &quot;tempMac =&quot; + tempMac);              String macaddr = tempMac.substring(0, tempMac.length() - 1);              Log.d(TAG, &quot;macaddr =&quot; + macaddr);              String existsMac = CtvTvManager.getInstance().getEnvironment(mac_ethAddr);              Log.d(TAG, &quot;existsMac =&quot; + existsMac);              if (existsMac.trim().equals(macaddr) || existsMac.trim() == macaddr) {                  macfile.delete();                  return ret;              }              if (!CtvTvManager.getInstance().setEnvironment(mac_ethAddr, macaddr)) {                  return ret;              }              String successMac = CtvTvManager.getInstance().getEnvironment(mac_ethAddr);              if (!successMac.trim().equals(macaddr) &amp;&amp; successMac.trim() != macaddr) {                  return ret;              }              macfile.delete();              macaddress = successMac;              return EnumUpgradeStatus.E_UPGRADE_SUCCESS.ordinal();          } catch (FileNotFoundException e) {              ret = EnumUpgradeStatus.E_UPGRADE_FILE_NOT_FOUND.ordinal();              e.printStackTrace();              return ret;          } catch (IOException e2) {              ret = EnumUpgradeStatus.E_UPGRADE_FAIL.ordinal();              e2.printStackTrace();              return ret;          }      } catch (Exception e3) {          ret = EnumUpgradeStatus.E_UPGRADE_FAIL.ordinal();          e3.printStackTrace();          return ret;      }  }</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统定制添加属性到 build.prop</title>
      <link href="/FuckCode/2018/03/05/%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E5%88%B0build-prop/"/>
      <url>/FuckCode/2018/03/05/%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E5%88%B0build-prop/</url>
      
        <content type="html"><![CDATA[<h3 id="build-prop新增自定义属性值"><a href="#build-prop新增自定义属性值" class="headerlink" title="build.prop新增自定义属性值"></a>build.prop新增自定义属性值</h3><ol><li>build/core/product.mk中增加自定义属性值</li></ol><pre><code>_product_var_list := \    PRODUCT_NAME \    PRODUCT_MODEL \    PRODUCT_LOCALES \    PRODUCT_AAPT_CONFIG \    ...    # 新增的属性值如下    PRODUCT_TARGET_NUMBER \    PRODUCT_TARGET_VERSION \</code></pre><ol start="2"><li><p>build/core/Makefile下对新增属性值赋值</p><pre><code>...ifneq ($(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_OEM_PROPERTIES),)    $(hide) echo &quot;#&quot; &gt;&gt; $@; \            echo &quot;# PRODUCT_OEM_PROPERTIES&quot; &gt;&gt; $@; \            echo &quot;#&quot; &gt;&gt; $@;    $(hide) $(foreach prop,$(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_OEM_PROPERTIES), \        echo &quot;import /oem/oem.prop $(prop)&quot; &gt;&gt; $@;)endif    $(hide) TARGET_BUILD_TYPE=&quot;$(TARGET_BUILD_VARIANT)&quot; \            TARGET_BUILD_FLAVOR=&quot;$(TARGET_PRODUCT)-$(TARGET_BUILD_VARIANT)&quot; \            TARGET_DEVICE=&quot;$(TARGET_DEVICE)&quot; \            PRODUCT_NAME=&quot;$(TARGET_PRODUCT)&quot; \            PRODUCT_BRAND=&quot;$(PRODUCT_BRAND)&quot; \            ...            # 新增属性赋值如下            PRODUCT_TARGET_VERSION=&quot;$(PRODUCT_TARGET_VERSION)&quot; \            PRODUCT_TARGET_NUMBER=&quot;$(PRODUCT_TARGET_NUMBER)&quot; \            PRIVATE_BUILD_DESC=&quot;$(PRIVATE_BUILD_DESC)&quot; \</code></pre></li></ol><ol start="3"><li><p>在build/tools/buildinfo.sh脚本中添加写入脚本</p><pre><code>...echo &quot;ro.product.model=$PRODUCT_MODEL&quot;echo &quot;ro.product.brand=$PRODUCT_BRAND&quot;echo &quot;ro.product.name=$PRODUCT_NAME&quot;# add new build.prop here by alliesecho &quot;ro.product.number=$PRODUCT_TARGET_NUMBER&quot;echo &quot;ro.product.version=$PRODUCT_TARGET_VERSION&quot;echo &quot;ro.product.device=$TARGET_DEVICE&quot;...</code></pre></li><li><p>BoardConfigCommon.mk中定义属性具体指</p><pre><code>...OTA_WITH_OPTEE = $(BOARD_OPTEEIMAGE)OTA_WITH_ARMFW = $(BOARD_OPTEEIMAGE)# add new item to build.prop by alliesPRODUCT_TARGET_NUMBER := E000000001PRODUCT_TARGET_VERSION := 001</code></pre></li><li><p>make installclean之后make查看设备指定system/build.prop文件内容是否发生改变</p><pre><code>...ro.build.flavor=aosp_makena_dtmb-userdebugro.product.model=MAKENA TVro.product.brand=Makenaro.product.name=aosp_makena_dtmbro.product.number=E000000001ro.product.version=001ro.product.device=makena...</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> Makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OTA升级包制作</title>
      <link href="/FuckCode/2018/02/07/OTA%E5%8D%87%E7%BA%A7%E5%8C%85%E8%AF%B4%E6%98%8E/"/>
      <url>/FuckCode/2018/02/07/OTA%E5%8D%87%E7%BA%A7%E5%8C%85%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="制作OTA全量升级包"><a href="#制作OTA全量升级包" class="headerlink" title="制作OTA全量升级包"></a>制作OTA全量升级包</h3><ol><li><p>导入环境 source build/envsetup.sh</p></li><li><p>lunch 选择版本</p></li><li><p>首先全局 make -j16 一下，保证编译生成文件的完整</p></li><li><p>再次执行 make -j16 otapackage 生成ota全量包</p></li><li><p>两个重要的文件悉知</p><pre><code>1. 全量升级包 -&gt; out/target/product/.../*.zip,2. 差分包中间文件 -&gt; out/target/product/makena/obj/PACKAGING/target_files_intermediates/*.zip</code></pre></li><li><p>拷贝 out/target/product/…/*.zip到优盘，重命名update.zip</p></li><li><p>(可选)adb shell到/cache/recovery/command，添加命令–update_package=root:path以告知Recovery进行升级：</p><pre><code>1. touch cache/recovery/command2. echo –update_package=root:path &gt; cache/recovery/command</code></pre></li><li><p>reboot recovery 进入recovery选择升级包升级</p></li></ol><h4 id="OTA差分包制作"><a href="#OTA差分包制作" class="headerlink" title="OTA差分包制作"></a>OTA差分包制作</h4><ol><li><p>make otapackage过程生成中间文件目录 out/target/product/…obj/PACKAGING/target_files_intermediates/拿到中间文件*.Mooney</p></li><li><p>拷贝文件到根目录下，重命名中间文件1.zip</p></li><li><p>根据修改源代码，重新编译OTA全量升级包，再次重复1步骤到指定文件夹下拿到第二次生成的中间文件</p></li><li><p>拷贝文件到根目录，重命名2.zip</p></li><li><p>命令制作差分包 ./build/tools/releasetools/ota_from_target_files -v -i 1.zip  -p out/host/linux-x86 -k build/target/product/security/testkey 2.zip update_signed.zip</p><pre><code>工具的命令行参数因版本不同有微小的变化，现列举一些常见参数说明：     -b  (--board_config)  &lt;file&gt;     在代码中用pass处理这一参数匹配，不做处理。     -k (--package_key) &lt;key&gt;     指定签名用的密钥。如果缺省，会从指定的源或目标版本包的META/misc_info.txt文件中获取，或使用&quot;build/target/product/security/testkey&quot;。对于制作增量升级包，默认的密钥是基于源版本包文件META/misc_info.txt中的指定的路径下的密钥对，而不是从目标版本包里的文件中获取，这点应该注意到。     -i  (--incremental_from)  &lt;file&gt;     -i参数后指定的zip将作为差分包制作的源版本包处理     -w  (--wipe_user_data)     生成在安装时擦除user date分区的升级包     -n  (--no_prereq)     忽略时间戳检查，用于开发过程中的OTA包的经常升降级     -e  (--extra_script)  &lt;file&gt;     在制作的升级包中的升级脚本中插入外部的脚本。     -a  (--aslr_mode)  &lt;on|off&gt;     指定是否打开升级包的aslr模式，默认为on状态     -p  (--path)  &lt;dir&gt;     指定一个路径，作为工具在运行过程中搜索二进制可执行文件的路径。在升级包制作中，我们一般指定/out/host/linux-x86目录，作为搜索签名工具的路径。     -f  (--fota) &lt;fota&gt;     指定是否使用 fota升级方式，默认为不使用。 </code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio 实现无缝调用系统 API</title>
      <link href="/FuckCode/2018/01/22/AS%E5%AF%BC%E5%85%A5framework-jar%E8%AF%B4%E6%98%8E/"/>
      <url>/FuckCode/2018/01/22/AS%E5%AF%BC%E5%85%A5framework-jar%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="AS无缝调用系统api"><a href="#AS无缝调用系统api" class="headerlink" title="AS无缝调用系统api"></a>AS无缝调用系统api</h3><p><strong>Android studio使用自己的framework.jar,调用系统api</strong></p><ol><li><p>源码路径下找到对应的编译中间文件</p><blockquote><p>out\target\common\obj\JAVA_LIBRARIES\framework_intermediates\classes.jar</p></blockquote></li><li><p>拷贝jar文件添加到AS的lib中,add as library</p></li><li><p>修改app下build.gradle中framework.jar为<strong>compileOnly</strong>模式,优先级提高</p><pre><code>dependencies {    compileOnly files(&apos;libs/framework.jar&apos;)    implementation fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)    ...}</code></pre></li><li><p>修改AS项目app目录下的app.iml文件,将文件结尾 <strong>&lt;orderEntry></strong> 中对应的framework.jar项提取到sdk项之上,不要忘记save一下</p><p> …</p><pre><code>&lt;orderEntry type=&quot;library&quot; name=&quot;__local_aars__:E.\Workspace\AndroidProj\Test\MTvFactoryTest\app\libs\framework.jar:unspecified@jar&quot; level=&quot;project&quot; /&gt;&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 23 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt;...</code></pre><p> gradle实现方式，在app下build.gradle中结尾添加如下代码</p><pre><code>preBuild {doLast {    def imlFile = file(project.name + &quot;.iml&quot;)    println(&apos;Change &apos; + project.name + &apos;.iml order&apos;)    try {        def parsedXml = (new XmlParser()).parse(imlFile)        def jdkNode = parsedXml.component[1].orderEntry.find { it.&apos;@type&apos; == &apos;jdk&apos; }        parsedXml.component[1].remove(jdkNode)        def sdkString = &quot;Android API &quot; + android.compileSdkVersion.substring(&quot;android-&quot;.length()) + &quot; Platform&quot;        new groovy.util.Node(parsedXml.component[1], &apos;orderEntry&apos;, [&apos;type&apos;: &apos;jdk&apos;, &apos;jdkName&apos;: sdkString, &apos;jdkType&apos;: &apos;Android SDK&apos;])        groovy.xml.XmlUtil.serialize(parsedXml, new FileOutputStream(imlFile))    } catch (FileNotFoundException e) {        // nop, iml not found    }}}</code></pre></li><li><p>项目根目录下的build.gradle中,添加如下代码:</p><pre><code>allprojects {    repositories {        ...    }    gradle.projectsEvaluated {        tasks.withType(JavaCompile) {            options.compilerArgs.add(&apos;-Xbootclasspath/p:app\\libs\\framework.jar&apos;)        }    }}</code></pre></li><li><p>执行clern,rebuild操作后,即可发现系统隐藏api不再报错,即可无缝使用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遥控按键互换</title>
      <link href="/FuckCode/2018/01/11/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8B%E9%81%A5%E6%8E%A7%E6%8C%89%E9%94%AE%E4%BA%92%E6%8D%A2/"/>
      <url>/FuckCode/2018/01/11/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8B%E9%81%A5%E6%8E%A7%E6%8C%89%E9%94%AE%E4%BA%92%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="源码修改之系统按键"><a href="#源码修改之系统按键" class="headerlink" title="源码修改之系统按键"></a>源码修改之系统按键</h3><h4 id="查看对应平台按键映射文件"><a href="#查看对应平台按键映射文件" class="headerlink" title="查看对应平台按键映射文件"></a>查看对应平台按键映射文件</h4><ul><li>cat /proc/bus/input/devices</li></ul><p>得到数据如下:</p><pre><code>I: Bus=0018 Vendor=3697 Product=0001 Version=0001N: Name=&quot;MStar Smart TV IR Receiver&quot;...I: Bus=0006 Vendor=3697 Product=0002 Version=0000N: Name=&quot;MStar Smart TV Keypad&quot;...</code></pre><p>上面可以看出有两个devices,详细信息如下:</p><pre><code>1. 设备名称:MStar Smart TV IR Receiver按键映射文件名称:Vendor_3697_Product=0001.kl2. 设备名称:MStar Smart TV Keypad按键映射文件名称:Vendor_3697_Product=0001.kl</code></pre><h4 id="查看对应设备按键映射数据"><a href="#查看对应设备按键映射数据" class="headerlink" title="查看对应设备按键映射数据"></a>查看对应设备按键映射数据</h4><ul><li>cat system/user/keylaout/Vendor_3697_Product=0001.kl</li></ul><p>得到数据如下:</p><pre><code>...## MStar Smart TV IR Receiver.#key 116     POWERkey 11      0key 2       1key 3       2key 4       3key 5       4key 6       5key 7       6key 8       7key 9       8key 10      9...</code></pre><p>其中:</p><pre><code>1. key: 是关键字。固定值，不需要改变2. 116: 该按键在linux驱动中对应的键值具体查看位置:android/external/kernel-headers/original/uapi/linux/input.h.这里是十进制数据，串口看到的是十六进制，需要转换数据3. POWER: 按键映射到Android中的按键，对应“keycodes.h”文件中AKEYCODE_POWER,其对应安卓中的26具体查看路径在:frameworks/native/include/android/keycodes.h</code></pre><h4 id="修改按键映射-不增加按键"><a href="#修改按键映射-不增加按键" class="headerlink" title="修改按键映射(不增加按键)"></a>修改按键映射(不增加按键)</h4><p>比如我们需要将音量加减互换,就可以修改对应的kl文件</p><pre><code>key 402     CHANNEL_UPkey 403     CHANNEL_DOWN</code></pre><p>修改为:</p><pre><code>key 403     CHANNEL_UPkey 402     CHANNEL_DOWN</code></pre><p>替换源文件到源目录下,重启即可发现按键修改成功</p><p><strong>遥控按键键值码和按键板键值码向上抛出的字符可以共用，但是对应的数值不相同，需要在串口中查看一一对应</strong></p><pre><code>串口打印的数据为16进制，字符映射文件默认为10进制，需要转换</code></pre><h4 id="增加遥控器按键-待验证"><a href="#增加遥控器按键-待验证" class="headerlink" title="增加遥控器按键(待验证)"></a>增加遥控器按键(待验证)</h4><ol><li>首先在内核中定义响应的遥控器寄存器值,映射为内核数值</li><li>在kl中增加相应的字符匹配</li><li>在c层定义内核数值到java值的映射</li><li>按照源码说明,在KeyCode.java以及其他文件中增加响应的按键值声明</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Makefile 实现文件拷贝</title>
      <link href="/FuckCode/2018/01/03/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/"/>
      <url>/FuckCode/2018/01/03/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="源码编译之文件拷贝"><a href="#源码编译之文件拷贝" class="headerlink" title="源码编译之文件拷贝"></a>源码编译之文件拷贝</h3><ul><li><p>拷贝文件到指定目录下:<br>*<br>  将当前文件夹下/origin/A.java 拷贝到 目标文件夹/target/A.java</p><p>  PRODUCT_COPY_FILES += $(LOCAL_PATH)/origin/A.java:$(TARGET_OUT)/target/A.java</p></li><li><p>拷贝指定文件夹下所有文件到指定目录下</p><p>  将当前文件夹下/origin/所有文件 拷贝到 目标文件夹/targrt/下</p><p>  PRODUCT_COPY_FILES += $(call find-copy-subdir-files,*,$(LOCAL_PATH)/origin,$(TARGET_OUT)/target)</p><p>  LOCAL_POST_PROCESS_COMMAND := $(shell (cp -rf $(LOCAL_PATH)/origin/* $(TARGET_OUT)/target/) &amp;&amp; (rm $(TARGET_OUT)/origin/Android.mk))</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拷贝文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu16 编译安卓 7.0 步骤</title>
      <link href="/FuckCode/2017/12/26/Ubuntu16%E7%BC%96%E8%AF%91%E5%AE%89%E5%8D%937-0%E6%BA%90%E7%A0%81%E6%AD%A5%E9%AA%A4/"/>
      <url>/FuckCode/2017/12/26/Ubuntu16%E7%BC%96%E8%AF%91%E5%AE%89%E5%8D%937-0%E6%BA%90%E7%A0%81%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Ubuntu16-编译安卓7-0源码步骤"><a href="#Ubuntu16-编译安卓7-0源码步骤" class="headerlink" title="Ubuntu16 编译安卓7.0源码步骤"></a>Ubuntu16 编译安卓7.0源码步骤</h3><ul><li><p>安装Ubuntu16.04 64系统</p></li><li><p>下载安卓7.0源码</p><p>  下载地址 <a href="http://mirrors.ustc.edu.cn/aosp-monthly/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/aosp-monthly/</a></p><p>  请注意对比 checksum。</p><p>  然后根据下文 已有仓库如何改用科大源 的方法更改同步地址。</p><p>  解压后用命令 repo sync 就可以把代码都 checkout 出来。</p><p>  Note: tar包为定时从 <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/</a> 下载</p><p>  具体查看：<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/aosp</a></p></li><li><p>添加依赖文件</p><p>  sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386<br>  sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib<br>  sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386<br>  sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-dev<br>  sudo apt-get install git-core gnupg flex bison gperf build-essential<br>  sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib<br>  sudo apt-get install libc6-dev-i386<br>  sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev<br>  sudo apt-get install lib32z-dev ccache<br>  sudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4</p></li><li><p>根据自己所下载的Android代码的版本，选择安装所需的jdk版本</p><p>  Android版本是7.1.2，所需的JDK版本是openjdk-8-jdk。Ubuntu默认自带的openjdk-8-jdk的安装源，可以直接安装，使用下面的命令安装即可：</p><pre><code>sudo apt-get updatesudo apt-get install openjdk-8-jdk</code></pre><p>  如果使用的OpenJDK7，由于Ubuntu 16.04没有OpenJDK7的源，因此要先添加源，然后在安装OpenJDK7，按下面的命令操作即可：</p><pre><code>sudo add-apt-repository ppa:openjdk-r/ppasudo apt-get updatesudo apt-get install openjdk-7-jdk</code></pre><p>  安装完以后，执行下面的命令添加JAVA_HOME相关配置</p><pre><code>sudo gedit /etc/profile</code></pre><p>  在打开的profile文件的末尾添加下面的内容：</p><pre><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH</code></pre><p>  修改了/etc/profile文件需要重启才能生效，但使用下面命令可以在不重启的情况下在当前bash环境生效：</p><pre><code>source /etc/profile</code></pre><p>  最后，检查一下jdk是否安装成功：</p><pre><code>java -version</code></pre></li><li><p>编译参数配置</p><p>  基本环境准备完成后，下面开始Android编译相关配置。</p><p>  1）修改android_common_build.mk文件，查找WITHOUT_HOST_CLANG，将</p><pre><code>    ifneq ($(WITHOUT_HOST_CLANG),true)修改成    ifeq ($(WITHOUT_HOST_CLANG),false)如果不修改这里，会遇到一个比较棘手的编译错误，修改的目的是把CLANG这个编译选项关掉。</code></pre><p>  2）修改 .bashrc文件</p><p>  　在终端中执行下面的命令，在.bashrc文件末尾添加：export USE_CCACHE = 1</p><pre><code>echo export USE_CCACHE=1 &gt;&gt; ~/.bashrc</code></pre><p>  　为了提高编译效率，设置编译器高速缓存:</p><pre><code>prebuilts/misc/linux-x86/ccache/ccache -M 50G</code></pre><p>  3）为了避免编译时出现“Try increasing heap size with java option Xmx<size>”错误，需要修改JACK_SERVER_VM_ARGUMENTS配置。修改prebuilts/sdk/tools/jack-admin文件，在JACK_SERVER_VM_ARGUMENTS的后面添加-Xmx4096M。一共有2处，都要进行修改</size></p><pre><code>修改完成以后，记得重启一下jack server，执行下面两条命令即可，一定要执行下面的命令，否则上面的修改可能不生效：    ./prebuilts/sdk/tools/jack-admin kill-server    ./prebuilts/sdk/tools/jack-admin start-server</code></pre></li></ul><ul><li><p>正式编译</p><p>  准备了以后工作后，基本上就ok了，运气好的话，在编译的时候基本就不会再出问题。依次执行下面的命令进行编译即可，当然随着个人电脑配置的不同，编译所需的时候也可能会有很大差异，如果觉得 -j8 太多，可以直接使用make，默认是 -j4：</p><pre><code>source build/envsetup.shlunchmake -j8</code></pre><p>  编译成功后，执行下面的命令，就可以打开Android模拟器，开始使用自己编译的系统了。</p><pre><code>emulator</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 源码编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 常用命令</title>
      <link href="/FuckCode/2017/12/11/Ubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/FuckCode/2017/12/11/Ubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Ubuntu之常用命令"><a href="#Ubuntu之常用命令" class="headerlink" title="Ubuntu之常用命令"></a>Ubuntu之常用命令</h3><h4 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h4><ul><li><p>gdebi &lt;== 自动安装依赖</p><p>  apt-get install gdebi &lt;== 安装gdebi软件管理工具</p></li><li><p>dpkg &lt;== 不安装依赖</p><p>  apt-get install -f 修复依赖</p></li><li><p>apt-get remove –purge [软件名称]</p></li></ul><p>####　Ubuntu卡死解决</p><ol><li>ctrl + alt + f1 进入TTY1</li><li>sudo top 查看栈顶程序(记住卡死进程id)</li><li>sudo kill [id] 杀死对应进程</li><li>sudo pkill [COMMAND] 杀死软件(COMMAND)</li><li>sudo restart lightdm 重启</li></ol><h4 id="Ubuntu链接远程服务器"><a href="#Ubuntu链接远程服务器" class="headerlink" title="Ubuntu链接远程服务器"></a>Ubuntu链接远程服务器</h4><pre><code>资源直接访问：  sftp://Allies@192.168.100.104/home/Allies</code></pre><h4 id="Ubuntu文件管理器无响应"><a href="#Ubuntu文件管理器无响应" class="headerlink" title="Ubuntu文件管理器无响应"></a>Ubuntu文件管理器无响应</h4><pre><code>killall nautilus  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移植源码项目到AS</title>
      <link href="/FuckCode/2017/12/08/%E7%A7%BB%E6%A4%8D%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E5%88%B0AS/"/>
      <url>/FuckCode/2017/12/08/%E7%A7%BB%E6%A4%8D%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E5%88%B0AS/</url>
      
        <content type="html"><![CDATA[<h3 id="移植源码项目到AS"><a href="#移植源码项目到AS" class="headerlink" title="移植源码项目到AS"></a>移植源码项目到AS</h3><p>为了方便代码修改和编译,我们可以适当将源码项目导入配置到android studio进行开发,以下用例为MTvHotkey项目移植到studio中</p><ol><li>找到相应的MTvHotkey项目源码根路径下/android/device/mstar/common/apps/拷贝出MTvHotkey工程</li><li>新建Android studio项目,命名以相应工程相似,建立工程模板项目</li><li>将源码项目拷贝到对应路径下(提前删除原项目中的相关文件,避免覆盖重复)</li><li>修复依赖问题,导入相关库文件(很棘手的步骤,下面详细介绍)</li><li>删除相应的测试用例以及相应库文件,减少依赖</li></ol><h4 id="修复导入项目依赖"><a href="#修复导入项目依赖" class="headerlink" title="修复导入项目依赖"></a>修复导入项目依赖</h4><ol><li><p>导入MTvHotkey项目,发现<strong><em>TvCommonManager</em></strong>报错,原因没有添加对象的库文件</p></li><li><p>查看源项目中的Android.mk文件,有如下引用:</p><p> LOCAL_STATIC_JAVA_LIBRARIES := android-support-v13<br> LOCAL_JAVA_LIBRARIES := com.mstar.android</p></li><li><p>到源码路径下找到编译生成的中间文件com.mstar.android_intermediates文件夹,找到class.jar,这里解压可以看到其文件夹中对应文件与原项目依赖文件相一致.这里直接找到最终生成的文件发现其已经被打包成dex文件,不能作为库文件使用</p><p> 路径:/android/out/target/common/obj/JAVA_LIBRARIES/</p></li><li><p>拷贝class.jar文件到studio工程下,添加为库文件(可以适当重命名)</p></li><li><p>这时候发现可以找到<strong><em>TvCommonManager</em></strong>不报错了</p></li><li><p>引用support-v4包出现错误,添加对应的依赖,注意依赖版本和编译版本相一致</p><p> implementation ‘com.android.support:support-v4:23.0.0’</p></li><li><p>sync项目,发现Default Activity not found,原因是这个项目没有启动界面,在项目配置的Launch Options中选择Launch Nothing</p></li><li><p>OK!</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB设备弹窗禁用</title>
      <link href="/FuckCode/2017/12/08/%E7%B3%BB%E7%BB%9FUSB%E5%BC%B9%E7%AA%97%E7%A6%81%E7%94%A8/"/>
      <url>/FuckCode/2017/12/08/%E7%B3%BB%E7%BB%9FUSB%E5%BC%B9%E7%AA%97%E7%A6%81%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="安卓源码修改之禁用USB存储弹窗"><a href="#安卓源码修改之禁用USB存储弹窗" class="headerlink" title="安卓源码修改之禁用USB存储弹窗"></a>安卓源码修改之禁用USB存储弹窗</h3><h4 id="代码查找"><a href="#代码查找" class="headerlink" title="代码查找"></a>代码查找</h4><ul><li><p>在我们插入或者拔出USB外设存储时候,系统都会弹出一个Notification提示设备状态,我们可以根据这点定位相关的源码位置</p><p>  dumpsys notification &lt;== 查看notification相关的dump信息</p></li></ul><p>从打印的信息中,我们发现有较多的<strong><em>com.android.systemui</em></strong>信息包含在其中.因此我们优先找到对应包名下的源代码</p><pre><code>/framework/base/package/systemui/...</code></pre><ul><li>查看此路径下的src文件夹中,我们发现有一个usb文件夹,打开即可发现重要的文件<strong><em>StorageNotification.java</em></strong>,相关的USB挂在通知就是在此进行管理</li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ul><li><p>定位</p><pre><code>android/frameworks/base/packages/SystemUI/src/com/android/systemui/usb/StorageNotification.java</code></pre></li><li><p>几个重要的类</p><pre><code>NotificationManager 通知栏管理器StorageManager 存储管理器StorageEventListener 存储事件监听者BroadcastReceiver 广播接收器MoveCallback 貌似是回调</code></pre></li><li><p>运行流程</p><p>  onstart()</p><ol><li>获取通知栏管理器</li><li>获取存储管理器</li><li>注册相应监听者</li><li>注册相应广播监听器</li><li>检测磁盘设备</li><li>扫描可用设备,处理分发设备挂载信息</li><li>注册MoveCallback,设备移除监听</li><li>更新设备状态 &lt;== 只对公共设备处理,设备没问题,等待用户处理,有问题提示用户重新插入</li></ol></li></ul><ul><li><p>扫面磁盘<strong><em>onDiskScannedInternal</em></strong></p><ol><li>磁盘数目大于0,但是可用设备0,提示用户系统不支持设备,提示格式化处理</li><li>设备检测无误,可以下序操作</li></ol></li></ul><ul><li><p>处理设备挂在信息<strong><em>onVolumeStateChangedInternal</em></strong></p><ol><li>个人设备信息,不做处理</li><li>公共设备信息,处理发送通知及提示音<ol><li>未挂载状态</li><li>检查中</li><li>成功挂载,挂载只读状态(发送设备打开Dialog)</li><li>正常移除</li><li>异常移除</li><li>…</li></ol></li></ol></li></ul><h4 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h4><ul><li>NotificationManager通过binder通信获取服务,更新通知栏状态</li><li>StorageManager也是通过binder通信机制实现</li><li>MoveCallBack可能是设备插入后拔出调用的相关逻辑</li><li><p>当存储设备状态发生改变时候,会调用对应的StorageEventListener监听者,执行器内部逻辑,检测无误,最终调用 <strong><em>onVolumeStateChangedInternal</em></strong>方法</p><ol><li>onVolumeStateChanged</li><li>onVolumeRecordChanged</li><li>onVolumeForgotten</li><li>onDiskScanned</li></ol></li><li><p>添加U盘插入后的逻辑可以在成功挂在后进行,在这里禁用MStar的多媒体弹窗即可<br>*</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码修改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 系统定制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统壁纸相关</title>
      <link href="/FuckCode/2017/12/08/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A3%81%E7%BA%B8%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%83%8C%E6%99%AF/"/>
      <url>/FuckCode/2017/12/08/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A3%81%E7%BA%B8%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="修改多任务背景"><a href="#修改多任务背景" class="headerlink" title="修改多任务背景"></a>修改多任务背景</h4><ul><li>修改多任务的背景，我们发现他是和桌面的默认壁纸联系在一起的，当我们切换壁纸的时候，多任务的壁纸也会随之变化，因此，我们可以通过修改默认壁纸达到修改多任务背景的效果</li><li>目标文件：default_wallpaper.jpg</li><li>资源位置：<ol><li>frameworks/base/core/res/res/drawable-nodpi</li><li>frameworks/base/core/res/res/drawable-sw600dp-nodpi/</li><li>frameworks/base/core/res/res/drawable-sw720dp-nodpi/</li></ol></li><li>替换目标路径下的default_wallpaper.jpg文件，从新打包生成framework-res.apk文件，替换、system/frameworks/下相应文件，记得修改文件权限，重启即可</li></ul><h4 id="源码壁纸分析"><a href="#源码壁纸分析" class="headerlink" title="源码壁纸分析"></a>源码壁纸分析</h4>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓系统新手引导分析</title>
      <link href="/FuckCode/2017/12/05/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/"/>
      <url>/FuckCode/2017/12/05/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="源码修改之新手启动引导-setupwizard"><a href="#源码修改之新手启动引导-setupwizard" class="headerlink" title="源码修改之新手启动引导(setupwizard)"></a>源码修改之新手启动引导(setupwizard)</h3><h4 id="描述：为了提供更好的用户体验以及提供云服务（云端备份等），在用户初次使用安卓设备时，厂商基本都有一个新手引导程序存在。安卓源码也提供了新手引导的范例，我们可以遵循其设计规则定制自己的新手引导程序。"><a href="#描述：为了提供更好的用户体验以及提供云服务（云端备份等），在用户初次使用安卓设备时，厂商基本都有一个新手引导程序存在。安卓源码也提供了新手引导的范例，我们可以遵循其设计规则定制自己的新手引导程序。" class="headerlink" title="描述：为了提供更好的用户体验以及提供云服务（云端备份等），在用户初次使用安卓设备时，厂商基本都有一个新手引导程序存在。安卓源码也提供了新手引导的范例，我们可以遵循其设计规则定制自己的新手引导程序。"></a>描述：为了提供更好的用户体验以及提供云服务（云端备份等），在用户初次使用安卓设备时，厂商基本都有一个新手引导程序存在。安卓源码也提供了新手引导的范例，我们可以遵循其设计规则定制自己的新手引导程序。</h4><h4 id="查找新手引导程序位置："><a href="#查找新手引导程序位置：" class="headerlink" title="查找新手引导程序位置："></a>查找新手引导程序位置：</h4><p>首次开机，进入到新手引导界面：</p><pre><code>命令: &lt;- dumpsys window(查看window视图的dump信息)采集主要信息，我们发现 ***com.mstar.android.setupwizard.DefaultActivity*** 多次出现在调试窗口中，找到代码位置位置：&lt;-device/mstar/common/apps/MSetupWizard/</code></pre><h5 id="查看源码文件：MSetupWizard"><a href="#查看源码文件：MSetupWizard" class="headerlink" title="查看源码文件：MSetupWizard"></a>查看源码文件：MSetupWizard</h5><ul><li><p>xml文件：</p>  <application><br>      <activity android:name="DefaultActivity" android:excludefromrecents="true" android:launchmode="singleInstance"><br>          <intent-filter android:priority="2"><br>              <action android:name="android.intent.action.MAIN"><br>              <category android:name="android.intent.category.HOME"><br>              <category android:name="android.intent.category.DEFAULT"><br>          </category></category></action></intent-filter><br>      </activity><br>  </application><ol><li><p>其一，注意<intent-filter android:priority="2">中的android:priority=”2”属性。其中的priority属性为优先级，默认为0，范围[-1000,1000],这里声明2</intent-filter></p></li><li><p>其二，注意<category android:name="android.intent.category.HOME">属性，这个属性是让app作为launcher界面存在，默认的编写中是没有上面的priority属性的。</category></p></li><li><p>我们大胆猜测，这里新手引导也是作为launcher界面存在，系统在启动HOME界面时候会把它加载到Launcher列表中执行，因为其属性值比其他默认的Launcher都要高，拥有优先启动的权利。</p></li></ol></li><li><p>上面我们知道了这个app作为Launcher存在，但是为什么只启动一次呢？下面我们来看一下源码！</p><pre><code>private void finishSetupWizard() {    // Add a persistent setting to allow other apps to know the device has been provisioned.    Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 1);    Settings.Secure.putInt(getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 1);    // remove this activity from the package manager.    PackageManager pm = getPackageManager();    ComponentName name = new ComponentName(this, DefaultActivity.class);    pm.setComponentEnabledSetting(name, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);    finish();}</code></pre><ol><li><p>我们在查看代码finish之前发现了这段代码，意思就是 ：</p><p> <strong><em>1. 添加全局设置并且其他app可以知道设备已经注册过</em></strong><br> <strong><em>2. 从包管理器中移除这个app</em></strong><br> <strong><em>3. setComponentEnabledSetting禁用组件</em></strong></p></li></ol></li><li><p>查找属性<intent-filter android:priority="1">的Activity（原生的setupwizard）</intent-filter></p></li></ul><p>代码路径：packages/apps/Provision/AndroidManifest.xml</p><pre><code>&lt;intent-filter android:priority=&quot;1&quot;&gt;    &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;    &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;&lt;/intent-filter&gt;</code></pre><p>对应的Activity：packages/apps/Provision/src/com/android/provision/DefaultActivity.java</p><pre><code>public class DefaultActivity extends Activity {    @Override    protected void onCreate(Bundle icicle) {        super.onCreate(icicle);        // Add a persistent setting to allow other apps to know the device has been provisioned.        Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 1);        Settings.Secure.putInt(getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 1);        // remove this activity from the package manager.        PackageManager pm = getPackageManager();        ComponentName name = new ComponentName(this, DefaultActivity.class);        pm.setComponentEnabledSetting(name, PackageManager.COMPONENT_ENABLED_STATE_DISABLED,                PackageManager.DONT_KILL_APP);        // terminate the activity.        finish();    }}</code></pre><p>上面可以看出，这里是谷歌源码提供的setupwizard引导页，逻辑和上面的几乎一致。这里的<intent-filter android:priority="1">表明优先级高于HOME，但是三方定制则将其改成了2，由此可见我们的猜想是正确的。</intent-filter></p><h4 id="源码修改"><a href="#源码修改" class="headerlink" title="源码修改"></a>源码修改</h4><ol><li><p>屏蔽MStar的setupwizard逻辑</p><ul><li><p>注释或者删除MSetupWizard的mk文件，让其不参与编译</p><pre><code># LOCAL_PATH:= $(call my-dir)# include $(CLEAR_VARS)# LOCAL_MODULE_TAGS := optional# LOCAL_SRC_FILES := $(call all-subdir-java-files)# LOCAL_PACKAGE_NAME := MSetupWizard# LOCAL_CERTIFICATE := platform           # LOCAL_OVERRIDES_PACKAGES := Provision SetupWizard# include $(BUILD_PACKAGE)</code></pre></li><li><p>注：<br>  （1）platform签名：</p><pre><code>AndroidManifest.xml的manifest节点中添加　android:sharedUserId=&quot;android.uid.system&quot;，Android.mk中增加　　LOCAL_CERTIFICATE := platform</code></pre><p>  （2）shared签名：</p><pre><code>AndroidManifest.xml的manifest节点中增加android:sharedUserId=&quot;android.uid.shared&quot;，Android.mk中增加LOCAL_CERTIFICATE := shared</code></pre><p>  （3）media签名：</p><pre><code>AndroidManifest.xml的manifest节点中增加 android:sharedUserId=&quot;android.media&quot;，Android.mk中增加 LOCAL_CERTIFICATE := media</code></pre></li></ul></li><li><p>添加定制的setupwizard程序到系统</p><ul><li><p>在packages/app/下新建自己的目录，例如：M_Guide</p></li><li><p>将apk文件上传到该目录下：M_Guide.apk</p></li><li><p>编写对应的mk文件，例如：</p><pre><code>LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := M_GuideLOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := $(LOCAL_MODULE).apkLOCAL_MODULE_CLASS := APPSLOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)LOCAL_CERTIFICATE := platformLOCAL_PRIVILEGED_MODULE := false  &lt;-- false表示生成在app下（系统不可删除）ture生成在priv-app（系统核心不可删除）LOCAL_BUILT_MODULE_STEM := package.apkLOCAL_OVERRIDES_PACKAGES := Provision SetupWizard   &lt;--覆盖编译include $(BUILD_PREBUILT)</code></pre><p>  <strong>注意这里的LOCAL_OVERRIDES_PACKAGES 这里是覆盖编译 Provision SetupWizard ，仿照的三方mmk文件的编写方式，我们需要替换其逻辑，就要将我们的apk编译时替换原生的，当然你也可以让其三方的编译（三方编译时会覆盖原生的），然后你自己再替换三方的MSetupWizard</strong></p></li><li><p>根目录下编译，生成M_Guide文件，例如：</p><p>  mmm packages/app/M_Guide</p></li></ul></li><li><p>屏蔽三方的setupwizard程序，添加自己apk到系统</p><ul><li><p>查找源码包含 MSetupWizard 的mk文件，这个文件一般包含在三方厂商的定制代码中，如果没有可忽略</p></li><li><p>添加自己的程序到device.mk文件，让其成为系统内置软件。例如：</p><pre><code># AppsPRODUCT_PACKAGES += \      M_Guide \            &lt;--在这里添加自己的app程序    livecap \    MLeanbackTv \    MTvPlayer \    MTvHotkey \    MTvMisc \    MTvFactory \    MTvTest \    MBrowser3 \    MLocalMM2 \    MMCastDemo \    Launcher3 \#    DMP \    DMS</code></pre></li><li><p>为什么添加在这里，我们可以查看Launche3的对应mk文件,部分如下：</p><pre><code>LOCAL_SDK_VERSION := currentLOCAL_PACKAGE_NAME := Launcher3LOCAL_PRIVILEGED_MODULE := true# MStar Android Patch BeginLOCAL_CERTIFICATE := platform# MStar Android Patch EndLOCAL_OVERRIDES_PACKAGES := Home Launcher2    &lt;--这里覆盖了原生的Launcher2include $(BUILD_PACKAGE)</code></pre><p>我们的基本逻辑和以上的相似，所以我们按照其添加方式进行编写</p></li><li><p>删除out目录下的MSetupWizard文件，make snod打包到系统</p></li><li><p>刷入系统验证（进入恢复出厂即可走此程序）</p></li></ul></li></ol><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>android源码提供的开机新手引导界面的设计逻辑如下：</p><ol><li>系统的新手引导app以Launcher形式存在源码中</li><li>作为引导的app的优先级priority属性要相应提高(谷歌自己的默认1)</li><li>新手引导app程序中在finish之前，设置已注册设备以及调用setComponentEnabledSetting禁用当前组件</li></ol><p>优点：源代码无需改动，即可添加替换新手引导程序，系统恢复出厂默认调用，深度解耦代码逻辑<br>缺点：不良厂商可能会修改priority属性优先级最高，已确保自己的Launcher始终处于默认状态</p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用打包系统签名</title>
      <link href="/FuckCode/2017/11/21/%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%E6%89%93%E5%8C%85apk/"/>
      <url>/FuckCode/2017/11/21/%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%E6%89%93%E5%8C%85apk/</url>
      
        <content type="html"><![CDATA[<h3 id="系统应用签名打包"><a href="#系统应用签名打包" class="headerlink" title="系统应用签名打包"></a>系统应用签名打包</h3><h4 id="解决-INSTALL-FAILED-SHARED-USER-INCOMPATIBLE"><a href="#解决-INSTALL-FAILED-SHARED-USER-INCOMPATIBLE" class="headerlink" title="解决(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE)"></a>解决(INSTALL_FAILED_SHARED_USER_INCOMPATIBLE)</h4><ol><li><p>在/out/host/linux-x86/framework/下取的signapk.jar</p></li><li><p>在/build/target/product/security/下取的platform.pk8 和 platform.x509.pem 两个文件</p></li><li><p>将以上3个文件和xxx.apk放到同一级目录下</p></li><li><p>命令行输入 java -jar signapk.jar platform.x509.pem platform.pk8 debug.apk release.apk 即可得到系统签名的apk</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统定制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码编译之生成SDK</title>
      <link href="/FuckCode/2017/11/09/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8B%E7%94%9F%E6%88%90SDK/"/>
      <url>/FuckCode/2017/11/09/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8B%E7%94%9F%E6%88%90SDK/</url>
      
        <content type="html"><![CDATA[<h3 id="制作SDK"><a href="#制作SDK" class="headerlink" title="制作SDK"></a>制作SDK</h3><ol><li>导入环境source build/envsetup.sh</li><li>make PRODUCT-sdk-sdk</li><li>生成出错，待解决</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tar 解压缩命令说明</title>
      <link href="/FuckCode/2017/11/08/Ubunut%E4%B9%8Btar%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
      <url>/FuckCode/2017/11/08/Ubunut%E4%B9%8Btar%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="tar解压缩"><a href="#tar解压缩" class="headerlink" title="tar解压缩"></a>tar解压缩</h3><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><ul><li><p>将/etc目录下的档案全部打包成为 etc.tar</p></li><li><p>tar -cvf etc.tar /etc  &lt;==仅打包，不压缩</p></li><li><p>tar -czvf etc.tar.gz /etc  &lt;==打包后，以 gzip 压缩</p></li><li><p>tar -cjvf etc.tar.bz2 /etc  &lt;==打包后，以 bzip2 压缩</p></li></ul><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><ul><li><p>解压文件</p></li><li><p>tar -zxvf *.tar.zip &lt;== 生成文件在当前目录下</p></li><li><p>tar -zxvf *.tar.zip -C ./xx/xx &lt;==指定文件夹下覆盖</p><ul><li>压缩 tar -j / J / z cvf [创建文件名] [源文件]</li><li>查询 tar -j / J / z tvf [目标文件名]</li><li>解压 tar -j / J / z xvf [目标文件名] -C [解压目录]</li><li>-j &lt;== bzip2</li><li>-J &lt;== gzip</li><li>-z &lt;== xz</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之状态模式</title>
      <link href="/FuckCode/2017/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/FuckCode/2017/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol><li>其行为由状态决定，不同状态下有不同的行为。</li><li>状态模式下的行为是平行的、不可替换的（策略模式的行为是彼此独立、可以替换的）</li><li>状态模式下，不同的状态对象（注意是状态对象）拥有一个抽象的状态基类</li></ol><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当一个状态的内在状态发生变化允许改变其行为，这个对象看起来像是改变了其类（多态）</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变他的行为</li><li>代码中包含大量和状态相关的条件语句，且这些分之语句依赖于该对象的状态</li><li>状态模式将每个条件分之放入一个独立的类中，使得我们可以根据对象自身的状态情况作为一个对象，这个对象不依赖其他对象而独立存在，通过多态去除重复的，过多的if-else等分之语句</li></ol><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://user-gold-cdn.xitu.io/2017/10/21/9f3f9eca6ed1ab048477201a758e3371" alt></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>Context：环境类，实现客户端感兴趣的方法，维护一个State实例对象，State对象定义了当前的状态，通过State对象的多态特性，自动调用其状态下该有的方法</li><li>State：抽象状态基类或者状态接口，定义一些方法或者接口，便是状态下应有的行为</li><li>ConcreteStateA、ConcreteStateB：具体状态类，每个具体状态下实现抽象类Stat中定义的方法或者接口，实现不同状态下的不同行为</li></ol><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>我们都知道电视在开机状态下可以实现调节频道，调节音量等操作；在关机状态下只能开机操作，而频道和音量调节都不能实现。下面我们就对这种应用场景实现其具体代码：</p><ul><li>TvState<pre><code>/** * 电视操作基类 */public interface TvState {    //下一个频道    void nextChannel();    //上一个频道    void prevChannel();    //增加音量    void turnUp();    //减小音量    void turnDown();}</code></pre>TvStat类中定义了操作电视的共有方法，不同状态下应有其具体实现类</li><li><p>PowerOffState</p><pre><code>/** * 关机状态下的逻辑 */public class PowerOffState implements TvState {    @Override    public void nextChannel() {        System.out.println(&quot;PowerOffState-&gt;nextChannel&quot;);    }    @Override    public void prevChannel() {        System.out.println(&quot;PowerOffState-&gt;prevChannel&quot;);    }    @Override    public void turnUp() {        System.out.println(&quot;PowerOffState-&gt;turnUp&quot;);    }    @Override    public void turnDown() {        System.out.println(&quot;PowerOffState-&gt;turnDown&quot;);    }}</code></pre><p>关机状态下的具体实现，此状态下电视的频道和音调节量都不能操作</p></li><li><p>PowerOnState</p><pre><code>/** * 开机状态下的操作逻辑实现类 */public class PowerOnState implements TvState {    @Override    public void nextChannel() {        System.out.println(&quot;PowerOnState-&gt;nextChannal&quot;);    }    @Override    public void prevChannel() {        System.out.println(&quot;PowerOnState-&gt;prevChannel&quot;);    }    @Override    public void turnUp() {        System.out.println(&quot;PowerOnState-&gt;turnUp&quot;);    }    @Override    public void turnDown() {        System.out.println(&quot;PowerOnState-&gt;turnUp&quot;);    }}</code></pre><p>开机状态下的具体实现，能够正常的对电视进行频道和音量的调节操作</p></li><li><p>PowerController</p><pre><code>/** * 电源控制接口 */public interface PowerController {    //开机    void powerOn();    //关机    void powerOff();}</code></pre><p>电源控制类，TvState的具体实现类中的具体行为就是因电源状态发生改变而改变的。</p></li><li><p>TVController</p><pre><code>/** * 电视控制类，实现电源接口 * 内部保留TvState对象，实现电视具体的逻辑操作 */public class TvController implements PowerController {    //保留TvState实例对象，调用其对应状态下的对象方法    private TvState mTvState;    private void setTvState(TvState state){        mTvState = state;    }    @Override    public void powerOn() {        setTvState(new PowerOnState());        System.out.println(&quot;TV-&gt;powerOn&quot;);    }    @Override    public void powerOff() {        setTvState(new PowerOffState());        System.out.println(&quot;TV-&gt;powerOff&quot;);    }    /**     *以下各种操作电视的逻辑分别是在对应电视开关机状态下逻辑实现     */    public void nextChannel(){        mTvState.nextChannel();    }    public void prevChannel(){        mTvState.prevChannel();    }    public void turnUp(){        mTvState.turnUp();    }    public void turnDown(){        mTvState.turnDown();    }}</code></pre><p>TVController对应于Context类，实现PowerController的方法（开机和关机），通过开关机我们得知其具体的状态，在这种状态下，通过具体行为的基类TvState实例对象，应用多态特性，其对象的具体行为自动接受其状态牵制，达到不同状态下有不同的具体行为</p></li><li><p>运行结果</p><pre><code>TV-&gt;powerOffPowerOffState-&gt;nextChannelPowerOffState-&gt;turnUpTV-&gt;powerOnPowerOnState-&gt;prevChannelPowerOnState-&gt;turnUp</code></pre><p>上面的实例中</p></li></ul><ol><li>我们抽象一个TvState接口，该接口中有操作电视的所有方法，其对应有两个实现类PowerOffState和PowerOnState</li><li>开机状态下用户可以对电视进行频道和音量的调节操作，关机状态却不能。这里就侧面反映了电视电源的状态影响了其具体的行为</li><li>状态模式就是将这些行为封装在一个对象状态类中，在进行操作时将这些功能转发到状态对象，导致不同状态下有不同的行为</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>封装了转换规则，状态类对象持有不同状态下的相应行为，达到不同状态下拥有不同的行为</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>将复杂的状态判断转换成结构清晰的状态类，保证好的扩展性和可维护性</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>状态类的使用必然会增加系统类和对象的个数</li><li>应用场景的状态模式功能划分相对复杂，如果使用不当将导致程序结构和代码的混乱</li></ol><h3 id="深度拓展"><a href="#深度拓展" class="headerlink" title="深度拓展"></a>深度拓展</h3><p><a href="https://juejin.im/editor/drafts/5aed34376fb9a07aa54230fc" target="_blank" rel="noopener">源码分析之状态机原型</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 状态模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码分析之Buinder模式</title>
      <link href="/FuckCode/2017/10/12/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/"/>
      <url>/FuckCode/2017/10/12/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>接着上次讲到的<a href="https://juejin.im/post/59c8ef285188254f5d175407" target="_blank" rel="noopener"><em>Builder设计模式</em></a>说起吧！Builder的主要作用，在我的理解上来看就是分离原料部件和组装过程，使部件组装自由化，高度解耦，内部返回自己的对象以形成链式调用，优化代码逻辑，在实例化对象过程中需要很多参数或者默认很多配置的情况下尤为突出。下面我们就来看一下Android源码中的Builder模式是怎么实现的吧！</p><h3 id="Android源码AlertDialog的Builder设计模式"><a href="#Android源码AlertDialog的Builder设计模式" class="headerlink" title="Android源码AlertDialog的Builder设计模式"></a>Android源码AlertDialog的Builder设计模式</h3><ul><li><p>在Android中，使用Builder模式最突出的就是Dialog了。每次我们在使用dialog时候，都要默认的设置很多参数，例如title，message，button等等。对于这样在实例化对象需要很多参数的情况下，Builder的设计优势便体现出来了。例如下面我们经常使用的实例化Dialog方式：</p><pre><code>private void showDialog() {    AlertDialog.Builder builder = new AlertDialog.Builder(getApplicationContext());    builder.setTitle(&quot;title&quot;)            .setIcon(null)            .setMessage(&quot;Message&quot;)            .setView(null)            .setPositiveButton(&quot;button&quot;,null)            .setPositiveButton(&quot;button&quot;, null)            .show();}</code></pre></li><li><p>上面展示了AlertDialog的实例过程，通过链式调用我们很方便并清晰的实例化了自己想要的Dialog，其内部含有多个参数需要配置，通过调用方法后返回自身对象，可以使得我们更加方便的进行链式调用，使得整个逻辑更加清晰。</p></li><li><p>首先我们先来到源码的AlertDialog类中，AlertDialog继承Dialog实现了DialogInterface，具体代码如下：</p><pre><code>public class AlertDialog extends Dialog implements DialogInterface {    //接受Builder成员变量P中的各个参数    private AlertController mAlert;    //省略部分    //构造函数    AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) {        super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0,                createContextThemeWrapper);        mWindow.alwaysReadCloseOnTouchAttr();        //构造AlertController实例对象mAlert        mAlert = new AlertController(getContext(), this, getWindow());    }}    //AlertDialog实际上调用的是mAlert的setMessage方法    public void setMessage(CharSequence message) {        mAlert.setMessage(message);    }</code></pre><p>上面可以看到，在实例化AlertDialog过程中，构造了一个mAler成员对象，它是AlertController中的对象，主要负责Dialo真正的参数和布局文件的设置工作，有点代理类的意味，这里我们就不做更深的讨论。</p></li><li><p>在AlertDialog中，有一个Builder的静态内部类，如下：</p><pre><code>public static class Builder {    //存储AlertDialog的各个参数，如title,mmessage,icon等    private final AlertController.AlertParams P;    //省略部分    public Builder(Context context, int themeResId) {        P = new AlertController.AlertParams(new ContextThemeWrapper(                context, resolveDialogTheme(context, themeResId)));    }    //设置各种参数    public Builder setTitle(@StringRes int titleId) {        P.mTitle = P.mContext.getText(titleId);        return this;    }}public Builder setView(View view, int viewSpacingLeft, int viewSpacingTop,        int viewSpacingRight, int viewSpacingBottom) {    P.mView = view;    P.mViewLayoutResId = 0;    P.mViewSpacingSpecified = true;    P.mViewSpacingLeft = viewSpacingLeft;    P.mViewSpacingTop = viewSpacingTop;    P.mViewSpacingRight = viewSpacingRight;    P.mViewSpacingBottom = viewSpacingBottom;    return this;}</code></pre></li></ul><p>上面在Builder实例化过程中，又通过AlertController中构建一个AlertController。AlertParams的P成员变量，这跟变量用来存储Dialog的相关参数，在下面的设置参数过程中，直接将参数通过P对象中的局部变量进行保存，相信的后面过程中，统一会从中抽取参数进行Dialog的布局设置工作。其次，在设置参数过程中，其默认直接返回本身，这样有利于我们在设置多个参数过程中方便的进行链式调用，使得程序更加简洁。</p><ul><li><p>下面我们来看一下AlertDialog中Bbuilder的OnCreate（）方法，代码如下：</p><pre><code>public AlertDialog create() {       // Context has already been wrapped with the appropriate theme.       //4. 调用new AlertDialog构造对象，并且将参数传递给个体AlertDialog       final AlertDialog dialog = new AlertDialog(P.mContext, 0, false);       //5. 将P中参数应用到dialog的mAlert对象中       P.apply(dialog.mAlert);       dialog.setCancelable(P.mCancelable);       if (P.mCancelable) {           dialog.setCanceledOnTouchOutside(true);       }       dialog.setOnCancelListener(P.mOnCancelListener);       dialog.setOnDismissListener(P.mOnDismissListener);       if (P.mOnKeyListener != null) {           dialog.setOnKeyListener(P.mOnKeyListener);       }       return dialog;   }</code></pre><p>在这里，我们才看到真正的Dialog才被创建，其创建过程中，通过P（AlertController.AlertParams）这个变量获取获取之前用户设置的参数配置，通过P.apply()将配置统一配置到Dialog样式中去。</p></li><li><p>对于P.apply()这个方法我们有必要来看一下其内部实现原理。其在AlertDialog的另一个重要的控制类AlertController中的静态类AlertParams中，如下：</p><pre><code>public void apply(AlertController dialog) {        if (mCustomTitleView != null) {            dialog.setCustomTitle(mCustomTitleView);        } else {            if (mTitle != null) {                dialog.setTitle(mTitle);            }            //省略        }        if (mMessage != null) {            dialog.setMessage(mMessage);        }        if (mPositiveButtonText != null) {            dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,                    mPositiveButtonListener, null);        }        //省略        if (mView != null) {            if (mViewSpacingSpecified) {                dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight,                        mViewSpacingBottom);            } else {                dialog.setView(mView);            }        } else if (mViewLayoutResId != 0) {            dialog.setView(mViewLayoutResId);        }    }</code></pre><p>上面的主要逻辑是将用户设置的AlertDialog的参数设置到真正的dialog中去，其中的各个参数一开始就被记录到AlertController中的AlertParams中去了。在AlertParams中包含众多AlertDialog的成员变量，记录用户设置的参数，用户设置的alertDialog的参数全部被记录在这里，部分代码如下：</p><pre><code>public static class AlertParams {    public final Context mContext;    public final LayoutInflater mInflater;    public int mIconId = 0;    public Drawable mIcon;    public int mIconAttrId = 0;    public CharSequence mTitle;    public View mCustomTitleView;    public CharSequence mMessage；    public boolean mCancelable;    public DialogInterface.OnKeyListener mOnKeyListener;    public CharSequence[] mItems;    public ListAdapter mAdapter;    public DialogInterface.OnClickListener mOnClickListener;    public int mViewLayoutResId;    public View mView;    //省略部分}</code></pre></li><li><p>在设置好Dialog的参数后，我们便调用show即可在界面显示设置的Dialog。我们先来看一下Dialo的shoew()方法：</p><pre><code>public AlertDialog show() {    final AlertDialog dialog = create();    dialog.show();    return dialog;}</code></pre><p>具体的show()方法在Dialog中实现：</p><pre><code>public void show() {    //显示状态，return    if (mShowing) {        //省略        return;    }    mCanceled = false;    //1. onCreate调用    if (!mCreated) {        dispatchOnCreate(null);    }    //2. onStart    onStart();    //3. 获取DecorView    mDecor = mWindow.getDecorView();    //省略    //4. 获取布局参数    WindowManager.LayoutParams l = mWindow.getAttributes();    if ((l.softInputMode            &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();        nl.copyFrom(l);        nl.softInputMode |=                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;        l = nl;    }    try {        //5. 将mDecor添加到WindowManager中        mWindowManager.addView(mDecor, l);        mShowing = true;        //6. 发送一个显示Dialog的消息        sendShowMessage();    } finally {    }}</code></pre><p>在show（）函数中主要做了一下几个事情：</p></li></ul><ol><li>通过dispatchOnCreate调用AlertDialog的onCreate方法</li><li>代用AlertDialog的onStart方法</li><li>将Dialog的DectorView添加到WindowManager中</li><li>发送消息，通过WindowManager显示当前的Dialog</li></ol><p>以上几个方面调用了Dialog的一系列生命周期，完成Dialo的实例化过程，下面我们跟踪一下AlertDialog的onCreate方法（Dialog的oncreate是一个空实现）：</p><pre><code>protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    // 调用AlertController的inatallContent方法    mAlert.installContent();}</code></pre><ul><li>在AlertDialog的oncreate中，其父类Dialog的通过dispatchOnCreate将方法分发给子类自己，如下:<br>  public void installContent() {<pre><code>    /* We use a custom title so never request a window title */    //设置窗口，没有title    mWindow.requestFeature(Window.FEATURE_NO_TITLE);    int contentView = selectContentView();    //设置窗口的内容视图布局    mWindow.setContentView(contentView);    //初始化AlertDialog的其他子视图内容    setupView();    setupDecor();}</code></pre></li><li><p>在installContent中，设置AlertDialog的内容布局，这个布局的默认布局文件及布局样式在AlertDialog的构造函数中进行了初始化</p><pre><code>public AlertController(Context context, DialogInterface di, Window window) {    mContext = context;    mDialogInterface = di;    mWindow = window;    mHandler = new ButtonHandler(di);    //获取布局样式和属性    final TypedArray a = context.obtainStyledAttributes(null,            R.styleable.AlertDialog, R.attr.alertDialogStyle, 0);    mAlertDialogLayout = a.getResourceId(            R.styleable.AlertDialog_layout, R.layout.alert_dialog);    mButtonPanelSideLayout = a.getResourceId(            R.styleable.AlertDialog_buttonPanelSideLayout, 0);    mListLayout = a.getResourceId(            R.styleable.AlertDialog_listLayout, R.layout.select_dialog);    //省略    a.recycle();}</code></pre></li><li><p>对于setupview()方法，我们进一步看看：</p><pre><code> private void setupView() {    final View parentPanel = mWindow.findViewById(R.id.parentPanel);    //1. 初始化title区域    final View defaultTopPanel = parentPanel.findViewById(R.id.topPanel);    //2. 初始化内容区域    final View defaultContentPanel = parentPanel.findViewById(R.id.contentPanel);    //3. 初始化button区域    final View defaultButtonPanel = parentPanel.findViewById(R.id.buttonPanel);    // Install custom content before setting up the title or buttons so    // that we can handle panel overrides.    //4. 用户自定义视图区域    final ViewGroup customPanel = (ViewGroup) parentPanel.findViewById(R.id.customPanel);    setupCustomContent(customPanel);    final View customTopPanel = customPanel.findViewById(R.id.topPanel);    final View customContentPanel = customPanel.findViewById(R.id.contentPanel);    final View customButtonPanel = customPanel.findViewById(R.id.buttonPanel);    // Resolve the correct panels and remove the defaults, if needed.    //5. 如果用户自定义内容区域，替换默认区域内容为自定义    final ViewGroup topPanel = resolvePanel(customTopPanel, defaultTopPanel);    final ViewGroup contentPanel = resolvePanel(customContentPanel, defaultContentPanel);    final ViewGroup buttonPanel = resolvePanel(customButtonPanel, defaultButtonPanel);    //6. 填充相应布局    setupContent(contentPanel);    setupButtons(buttonPanel);    setupTitle(topPanel);    //7. 处理显示与隐藏逻辑    final boolean hasCustomPanel = customPanel != null            &amp;&amp; customPanel.getVisibility() != View.GONE;    final boolean hasTopPanel = topPanel != null            &amp;&amp; topPanel.getVisibility() != View.GONE;    final boolean hasButtonPanel = buttonPanel != null            &amp;&amp; buttonPanel.getVisibility() != View.GONE;    //省略部分    }</code></pre><p>setupView()主要加载初始化AlertDialog布局文件中的各个部分。统一加载系统默认的Dialog布局文件和用户设置的布局文件，然后根据用户自定义的程度，优先设置自定义的布局方式及相关属性值，并将其设置到Dialog中去。</p></li><li>此时，用户通过show方法后，WindoeManager便会将AlertDialog显示到界面上。</li></ul><p><strong>总结</strong><br>Android源码的Builder设计模式在AlertDialog中使用最为频繁，通过AlertDialog我们可以这样理解：</p><ol><li>AlertDialog内部使用Builder设计模式，其内部类Builder每次构建返回自身，有利于链式调用，代码结构清晰</li><li>AlertDialog的Builder掌握所有的Dialog参数配置工作，其具体配置由AlertController来实现</li><li>AlertController是AlertDialog的重要实现类，用户配置的参数信息由内部静态类AlertParams来保存，其内部具体完成Dialog的装配工作</li><li>Dialog的具体显示和消失逻辑由WindowManager来完成</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Builder </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码编译之镜像翻转显示</title>
      <link href="/FuckCode/2017/10/12/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8B%E9%95%9C%E5%83%8F%E7%BF%BB%E8%BD%AC/"/>
      <url>/FuckCode/2017/10/12/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8B%E9%95%9C%E5%83%8F%E7%BF%BB%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="源码编译之镜像翻转显示"><a href="#源码编译之镜像翻转显示" class="headerlink" title="源码编译之镜像翻转显示"></a>源码编译之镜像翻转显示</h3><ul><li>挂载读写tvconfig</li><li><p>修改tvconfig/model/Customer_1.ini文件</p><pre><code>[MISC_MIRROR_CFG]#OSD mirror option setting, enable mirror first and select mirror type.#Default MIRROR_OSD is False; MIRROR_OSD_TYPE is not mirror;MIRROR_OSD = True;      # True:enable OSD mirror.  False:disable OSD mirror.MIRROR_OSD_TYPE = 3;    # 0:normal type.  1:Horizontal-mirror only.  2:Vertical-mirror only.  3:HV-mirror.MIRROR_VIDEO = True;      # True:enable OSD mirror.  False:disable OSD mirror.MIRROR_VIDEO_TYPE = 3;    # 0:normal type.  1:Horizontal-mirror only.  2:Vertical-mirror only.3:HV-mirror.</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 修改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 常用语法</title>
      <link href="/FuckCode/2017/10/09/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/FuckCode/2017/10/09/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><ul><li>one</li><li>two</li><li>three</li><li>four</li></ul><ol><li>第一条</li><li>第二条</li><li>第三条</li></ol><p><em>斜体</em></p><p><strong>加粗</strong></p><p><del>下划线</del></p><p>表格</p><table><thead><tr><th>产品</th><th style="text-align:center">数量</th><th style="text-align:right">单价</th></tr></thead><tbody><tr><td>苹果</td><td style="text-align:center">30</td><td style="text-align:right">$1600</td></tr><tr><td>葡萄</td><td style="text-align:center">18</td><td style="text-align:right">$12</td></tr><tr><td>橘子</td><td style="text-align:center">43</td><td style="text-align:right">$1</td></tr></tbody></table><blockquote><p>引用</p></blockquote><p>这是链接   <a href="www.baidu.com">点击</a></p><p>这是图片  <img src="..." alt></p><p>分割线</p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码编译之错误解决</title>
      <link href="/FuckCode/2017/10/01/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8B%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
      <url>/FuckCode/2017/10/01/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B9%8B%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="源码编译之错误解决"><a href="#源码编译之错误解决" class="headerlink" title="源码编译之错误解决"></a>源码编译之错误解决</h1><ul><li>错误1：<br>描述：<pre><code>...error: unsupported reloc 42target thumb C++: libGLES_trace_32 &lt;=clang: error: linker command failed with exit code 1 (use -v to see invocation)...</code></pre></li></ul><p>解决1：修改 build/core/clang/HOST_x86_common.mk</p><pre><code>CLANG_CONFIG_x86_LINUX_HOST_EXTRA_ASFLAGS := \--gcc-toolchain=$($(clang_2nd_arch_prefix)HOST_TOOLCHAIN_FOR_CLANG) \--sysroot=$($(clang_2nd_arch_prefix)HOST_TOOLCHAIN_FOR_CLANG)/sysroot \</code></pre><ul><li><p>-B$($(clang_2nd_arch_prefix)HOST_TOOLCHAIN_FOR_CLANG)/x86_64-linux/bin \<br>-no-integrated-as</p><p>CLANG_CONFIG_x86_LINUX_HOST_EXTRA_CFLAGS := \  </p></li></ul><p>解决2：修改 art/build/Android.common_build.mk</p><pre><code>  # Host.  ART_HOST_CLANG := false  ifeq ($(WITHOUT_HOST_CLANG),false)    # By default, host builds use clang for better warnings.    ART_HOST_CLANG := true  endif执行命令，更改链接指向  ln -sf /usr/bin/ld.gold prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.11-4.6/x86_64-linux/bin/ld</code></pre><p>解决3：</p><pre><code>cp /usr/bin/ld.gold prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.11-4.6/x86_64-linux/bin/ld</code></pre>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之Builder模式</title>
      <link href="/FuckCode/2017/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/"/>
      <url>/FuckCode/2017/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h3><ol><li>对外部隐藏内部实现细节</li><li>分离部件和组装过程</li><li>自由扩展部件和构造过程</li><li>降低解耦，分工明确</li></ol><h3 id="适应场景"><a href="#适应场景" class="headerlink" title="适应场景"></a>适应场景</h3><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果</li><li>多个部件和零件，都可以装配到一个对象中，但产生的运行结果又不相同时</li><li>产品类非常复杂，或者产品类中的调用顺序不同产生不同的作用</li><li>当初始化一个对象特别复杂，如参数多，且很多参数具有默认值时</li></ol><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://user-gold-cdn.xitu.io/2017/10/17/019970181f7739849ec93011c75e675d" alt></p><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ol><li>抽象类Builder由ConcreteBuilder子类来实现</li><li>Director类含有一个Builder的实例对象，通过construct方法指导Builder控制Product的流程</li><li>ConcreteBuilder实现具体的组装工作（new Product），组装流程由Director控制</li></ol><h3 id="代码实例实现"><a href="#代码实例实现" class="headerlink" title="代码实例实现"></a>代码实例实现</h3><p>计算机的组装过程较为复杂，且组装过程也不是固定的，我们暂且将计算机的组装过程简化为构建主机，设置显示器，设置操作系统三个步骤，通过Director和具体的Builder来构建计算机对象</p><ul><li><p>计算机抽象类，即Product角色</p><pre><code>public abstract class Computer {protected String mBoard;protected String mDisplay;protected String mOS;    public Computer() {    }    //设置cpu    public void setBoard(String board){        mBoard = board;    }    //设置显示    public void setDisplay(String display){        mDisplay = display;    }    //设置操作系统    public abstract void setOS();    @Override    public String toString() {        return &quot;Computer { &quot; +                &quot;mBoard=&apos;&quot; + mBoard + &apos;\&apos;&apos; +                &quot;, mDisplay=&apos;&quot; + mDisplay + &apos;\&apos;&apos; +                &quot;, mOS=&apos;&quot; + mOS + &apos;\&apos;&apos; +                &apos;}&apos;;    }}</code></pre></li><li><p>具体的Computer类,即macboook</p><pre><code>public class Macbook extends Computer{    public Macbook() {    }    @Override    public void setOS() {        mOS = &quot;Mac OS X 10.10&quot;;    }}</code></pre></li><li><p>抽象Builder类,只提供抽象方法，也不提供组装方法，有Director实现组装</p><pre><code>public abstract class Builder {    //设置主机    public abstract void buildBoard(String board);    //设置显示器    public abstract void buildDisplay(String display);    //设置操作系统    public abstract void buildOS();    //创建Computer    public abstract Computer create();}</code></pre></li><li><p>MAcbookBuilder，具体的builder类</p><pre><code>public class MacbookBuilder extends Builder {  //实例化，父类容器容纳子类对象    private Computer mComputer = new Macbook();    @Override    public void buildBoard(String board) {        mComputer.setBoard(board);    }    @Override    public void buildDisplay(String display) {        mComputer.setDisplay(display);    }    @Override    public void buildOS() {        mComputer.setOS();    }    @Override    public Computer create() {        return mComputer;    }}</code></pre></li><li><p>Director类，负责构造Computer，通过传入builder对象，负责具体的组装工作</p><pre><code>public class Director {    Builder mBuilder = null;    public Director(Builder builder) {        this.mBuilder = builder;    }    public void construct(String board, String display){        mBuilder.buildBoard(board);        mBuilder.buildDisplay(display);        mBuilder.buildOS();    }}</code></pre></li><li><p>测试Main</p><pre><code>public class Main {    public static void main(String[] args) {    //Director，通过传入builder对象，可实现builder的自动组装任务    Director pcDirector = new Director(macbookBuilder);    //封装构建过程，传入具体的零件信息：4核CPU，内存2GB，MAC操作系统    pcDirector.construct(&quot;英特尔主板 酷睿I7CPU&quot;, &quot;Retina 显示器&quot;);        //构建计算机，输出相关信息        System.out.println(&quot;Computer Info : &quot; + macbookBuilder.create().toString());    }}</code></pre></li></ul><ul><li><p>运行结果</p><pre><code>Computer Info : Computer { mBoard=&apos;英特尔主板 酷睿I7CPU&apos;, mDisplay=&apos;Retina 显示器&apos;, mOS=&apos;Mac OS X 10.10&apos;}</code></pre></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>抽象出数据原型Computer，其内包含基本的数据组成</li><li>具体的数据原型MacBook，通过继承Computer而来</li><li>Builder类实现具体的装配工作，其内部必须要有数据原型对象（原料）用来装配，但是具体装配的前后顺序不是自己能控制的，只是拥有装配的能力</li><li>Director指挥Builder实现具体的装配工作，其内部封装了构建复杂的产品对象过程，对外部隐藏构建的细节，控制装配的流程</li><li>Builde的派生类Macbookbuilder，用于构建具体的装配对象Macbook（Computer的派生类类）</li><li>Director通过指挥Builder，一起将一个复杂的对象构建和表示过程分离，使同样的构建过程可以创建不同的对象</li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>良好的封装性，使用建造者模式可以使客户端不必要知道产品内部组成的细节</li><li>建造者独立，容易扩展</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>会产生多余的Builder对象以及Director对象，消耗内存</li></ul><h4 id="深度拓展"><a href="#深度拓展" class="headerlink" title="深度拓展"></a>深度拓展</h4><p><a href="https://juejin.im/post/59ccbf186fb9a00a562ea439" target="_blank" rel="noopener">Android源码分析之Builder模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Builder </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实战之备忘录模式</title>
      <link href="/FuckCode/2017/09/26/%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/FuckCode/2017/09/26/%E5%AE%9E%E6%88%98%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="备忘录模式实战"><a href="#备忘录模式实战" class="headerlink" title="备忘录模式实战"></a>备忘录模式实战</h3><ul><li>前面文章依次介绍了Java设计模式中的<a href="https://juejin.im/post/59c8eb6951882564c5164c5f" target="_blank" rel="noopener">备忘录模式</a>以及其在<a href="https://juejin.im/post/59c9a976f265da06434b9a08" target="_blank" rel="noopener">Android源码中的实现</a>，相信很多人和我一样，知其然但不知其所以然。俗话说时间是检验真理的唯一标准。现在就跟我来进行实战分析吧！</li><li><p>本次采用一个简单的记事本案例，通过记事本的撤销，重做，保存等逻辑，使用备忘录模式对其代码重构。先看一下人人都会写的部分吧：<br>   &lt;LinearLayout</p><pre><code>android:layout_width=&quot;368dp&quot;android:layout_height=&quot;495dp&quot;android:orientation=&quot;vertical&quot;tools:layout_editor_absoluteX=&quot;8dp&quot;tools:layout_editor_absoluteY=&quot;8dp&quot;&gt;&lt;EditText    android:id=&quot;@+id/edit_text&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;0dp&quot;    android:layout_weight=&quot;1&quot;    android:gravity=&quot;left&quot; /&gt;&lt;RelativeLayout    android:layout_margin=&quot;12dp&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_marginBottom=&quot;10dp&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tv_save&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_centerInParent=&quot;true&quot;        android:layout_margin=&quot;12dp&quot;        android:text=&quot;保存&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv_pre&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;12dp&quot;        android:layout_toLeftOf=&quot;@id/tv_save&quot;        android:text=&quot;撤销&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/tv_next&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_margin=&quot;12dp&quot;            android:layout_toRightOf=&quot;@id/tv_save&quot;            android:text=&quot;重做&quot; /&gt;    &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt;</code></pre><p>xml布局代码，主要有三个逻辑（撤销、保存、重做）以及一个edittext空间进行数据的编辑。</p></li><li><p>Activity中主要进行控件初始化，点击事件的监听，代码如下：</p><pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener {    private TextView tvPre;//撤销    private TextView tvSave;//保存    private TextView tvNext;//重做    private EditText etText;//编辑器    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        initViews();        setOnClick();    }    private void initViews() {        tvPre = (TextView) findViewById(R.id.tv_pre);        tvSave = (TextView) findViewById(R.id.tv_save);        tvNext = (TextView) findViewById(R.id.tv_next);        etText = (EditText) findViewById(R.id.edit_text);    }    private void setOnClick() {        tvPre.setOnClickListener(this);        tvSave.setOnClickListener(this);        tvNext.setOnClickListener(this);    }</code></pre></li><li><p>撤销、保存、重做逻辑的具体实现（CareTaker作用）：</p><pre><code>@Overridepublic void onClick(View view) {    int id = view.getId();    switch (id) {        case R.id.tv_pre:            //获取前一个存档信息（撤销）            restoreeditText(getPreMemoto());            makeToast(&quot;撤销：&quot;);            break;        case R.id.tv_save:            //保存记录信息            saveMemoto(createMemotoForEditText());            makeToast(&quot;保存：&quot;);            break;        case R.id.tv_next:            //获取下一条记录（重做）            restoreeditText(getNextMemoto());            makeToast(&quot;重做：&quot;);            break;    }}private void makeToast(String msg) {    Toast.makeText(this, msg + etText.getText() +                    &quot;光标位置&quot; + etText.getSelectionStart(),            Toast.LENGTH_SHORT).show();    System.out.println(msg + etText.getText() +            &quot;光标位置&quot; + etText.getSelectionStart());}</code></pre></li><li><p>备忘录的数据操作部分，可以保存30次操作记录，主要包括初始化、获取前一个存放信息、获取后一个存档信息以及恢复数据等逻辑。相当于Originator作用。</p><pre><code>//最大存储数量private static final int MAX = 30;//存储30条记录List&lt;Memoto&gt; mMemoto = new ArrayList&lt;Memoto&gt;(MAX);int mIndex = 0;/** * 保存备忘录 */public void saveMemoto(Memoto memoto) {    if (mMemoto.size() &gt; MAX) {        mMemoto.remove(0);    }    mMemoto.add(memoto);    mIndex = mMemoto.size() - 1;}/** * 获取前一个存档，相当于撤销 * * @return */public Memoto getPreMemoto() {    mIndex = mIndex &gt; 0 ? --mIndex : mIndex;    return mMemoto.get(mIndex);}/** * 获取下一个存档，相当于重做 * * @return */public Memoto getNextMemoto() {    mIndex = mIndex &lt; mMemoto.size() - 1 ? ++mIndex : mIndex;    return mMemoto.get(mIndex);}/** * 为编辑器创建Memoto对象 * * @return */private Memoto createMemotoForEditText() {    Memoto memoto = new Memoto();    memoto.cursor = etText.getSelectionStart();    memoto.text = etText.getText().toString();    return memoto;}/** * 恢复编辑器状态 * * @param memoto */private void restoreeditText(Memoto memoto) {    etText.setText(memoto.text);    etText.setSelection(memoto.cursor);}</code></pre></li><li><p>Memot备忘录数据，其中记录数据的字符以及游标信息</p><pre><code>/** * Created by allies on 17-9-26. * 存储edittext的光标和内容 */public class Memoto {    //字符数据    public String text;    //游标信息    public int cursor;}</code></pre></li></ul><p>*由上面可以看出，记事本的基本数据编辑、保存，以及特有的撤销操作和重做逻辑都已经实现。相信很多人上面的代码都可以不假思索的信手拈来，但是既然我们学习了备忘录模式，就要对其代码进行重构，学以致用方能行以千里。</p><hr><p><strong>以上代码的缺点：</strong></p><p><em>Activity内逻辑众多，既要负责View的操作逻辑，还要管理记事本的记录、修改编辑器的状态，也就是Originator与CareTaker功能耦合在一起，造成类型膨胀，后续难以维护。我们需要优化的是将Activity中的保存数据的逻辑、职责分离出去，使每个类的职责都分工明确，降低代码之间的耦合度。</em></p><ul><li>优化步骤：</li></ul><ol><li><p>将Activity中的CareTaker部分抽取出来，明确Originator与CreaTaker的功能。新建一个NoteCareTaker类，负责管理Memoto对象，包括撤销、保存、重做部分的逻辑（注意不对元数据进行修改操作）。</p><pre><code>/** * Created by allies on 17-9-26. * 备忘录CareTaker部分逻辑 */public class NoteCareTaker {    //最大存储数量    private static final int MAX = 30;    //存储30条记录    List&lt;Memoto&gt; mMemoto = new ArrayList&lt;Memoto&gt;(MAX);    int mIndex = 0;    /**     * 保存备忘录     */    public void saveMemoto(Memoto memoto) {        if (mMemoto.size() &gt; MAX) {            mMemoto.remove(0);        }        mMemoto.add(memoto);        mIndex = mMemoto.size() - 1;    }    /**     * 获取前一个存档，相当于撤销     *     * @return     */    public Memoto getPreMemoto() {        mIndex = mIndex &gt; 0 ? --mIndex : mIndex;        return mMemoto.get(mIndex);    }    /**     * 获取下一个存档，相当于重做     *     * @return     */    public Memoto getNextMemoto() {        mIndex = mIndex &lt; mMemoto.size() - 1 ? ++mIndex : mIndex;        return mMemoto.get(mIndex);    }}</code></pre><p><em>NoteCareTaker中会维护一个备忘录列表，使用mIndex标识编辑器当前的记录点，可以通过相应的方法获取数据的前一个、后一个记录信息以及保存记录信息。</em></p></li><li><p>下面就是对Originator作用的代码重构。我们先来分析一下Originator的作用是什么？在第一篇中我们明确指出Originator作用是负责创建一个备忘录，可以记录、恢复自身的内部状态。这里我们可以看出，其可以直接操作元数据信息，也就是和数据信息耦合度最高的部分，其自身需要直接访问Memoto信息，以便通过这些信息存储和恢复数据等操作。此外最重要的是可以创建备忘录，也就是createMemoto的操作在这里执行。</p><pre><code>public class NoteEditText extends EditText {    public NoteEditText(Context context) {        this(context,null);    }    public NoteEditText(Context context, AttributeSet attrs) {        this(context, attrs,0);    }    public NoteEditText(Context context, AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);    }    /**     * 创建备忘录对象，存储元数据信息     * @return     */    public Memoto createMemoto(){        Memoto memoto = new Memoto();        memoto.text = getText().toString();        memoto.cursor = getSelectionStart();        return  memoto;    }    /**     * 从备忘录恢复数据     * @param memoto     */    public void restoreMemoto(Memoto memoto){        setText(memoto.text);        setSelection(memoto.cursor);    }}</code></pre><p><em>从上面分析我们知道和数据接触最深的就是EditText了，我们这里直接覆写一个NoteEditTExt继承EditText，在其内部组织负责备忘录的创建以及恢复操作。这里也就突出了Originator的创建以及恢复状态的作用。</em></p></li><li><p>之后便是Activity中的具体操作逻辑，其直接通过自定义的NoteEditText空间创建Memoto备忘录，然后其撤销、保存、重做等逻辑不在Activity内部实现，而是转交给了CareTaker来实现。代码如下：</p><pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener {    private TextView tvPre;//撤销    private TextView tvSave;//保存    private TextView tvNext;//重做    private NoteEditText etText;//自定义的编辑器    //新建Caretaker对象，负责备忘录的撤销，恢复以及保存等操作    NoteCareTaker mCareTaker = new NoteCareTaker();    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        initViews();        setOnClick();    }    private void initViews() {        tvPre = (TextView) findViewById(R.id.tv_pre);        tvSave = (TextView) findViewById(R.id.tv_save);        tvNext = (TextView) findViewById(R.id.tv_next);        etText = (NoteEditText) findViewById(R.id.edit_text);    }    private void setOnClick() {        tvPre.setOnClickListener(this);        tvSave.setOnClickListener(this);        tvNext.setOnClickListener(this);    }    @Override    public void onClick(View view) {        int id = view.getId();        switch (id) {            case R.id.tv_pre:                etText.restoreMemoto(mCareTaker.getPreMemoto());                makeToast(&quot;撤销：&quot;);                break;            case R.id.tv_save:                //1.首先创建备忘录对象,创建时候就已经记录了元数据信息                Memoto mMemoto = etText.createMemoto();                //通过caretaker，保存备忘录信息                mCareTaker.saveMemoto(mMemoto);                makeToast(&quot;保存：&quot;);                break;            case R.id.tv_next:                //重做                etText.restoreMemoto(mCareTaker.getNextMemoto());                makeToast(&quot;重做：&quot;);                break;        }    }    private void makeToast(String msg) {        Toast.makeText(this, msg + etText.getText() +                        &quot;光标位置&quot; + etText.getSelectionStart(),                Toast.LENGTH_SHORT).show();        System.out.println(msg + etText.getText() +                &quot;光标位置&quot; + etText.getSelectionStart());    } }</code></pre><p><em>从上面可以看出：Activity中的逻辑简单化了不止一点两点，各个类的职责更加单一、明确。界面相关的类型和业务处理逻辑的类型隔离开来，避免类型膨胀，逻辑混乱等问题。在优化代码前一定要着重思考各个类的主要职责，明确他们之间的关系和功能，使得各个类各司其职，不可越过雷池半步。往往在这个时候，就要多看看这个设计模式中，各个角色所担任的职责，找准切入点在进一步优化重构代码。</em></p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>优点</li></ul><ol><li>给用户提供一种可以恢复状态的机制，能够使用户方便的恢复到某个历史状态</li><li>实现数据信息的封装，使得用户不用关心其状态的保存细节</li></ol><ul><li>缺点<br>消耗资源，如果类的成员变多，势必会占用较大的资源，而且每一次保存都会消耗一定的内存（降低耦合导致类增多，各个类分工明确单一的后果）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 备忘录 </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android源码分析之备忘录模式</title>
      <link href="/FuckCode/2017/09/26/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/FuckCode/2017/09/26/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚看到Java设计模式中的<a href="https://juejin.im/post/59c8eb6951882564c5164c5f" target="_blank" rel="noopener"><em>备忘录模式</em></a>，心思一转，就想到了Android开发中Activity的两个重要的方法onSaveInstanceState和onRestoreInstanceState，这两个方法能够保证我们在开发应用时，遇到未知问题，导致Activity非正常退出时候，在Activity在随后时间被系统杀死之前会回调这两个方法，存储记录Activity相关的信息，以便在下次返回Activity的时候能够恢复这些数据。</p><h3 id="Android源码分析"><a href="#Android源码分析" class="headerlink" title="Android源码分析"></a>Android源码分析</h3><p><strong><em>之前文章讲到了Java设计模式中的备忘录模式，今天就根据这个模式来看看Android中是如何实现备忘录模式的（源码基于Android6.0）</em></strong></p><ul><li><p>首先来看一下Activity的onSaveInstanceState方法</p><pre><code>final void performSaveInstanceState(Bundle outState) {    onSaveInstanceState(outState);    saveManagedDialogs(outState);    mActivityTransitionState.saveState(outState);    if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState);}</code></pre><p>  由上面可以看出，Android6.0源码将onSaveInstanceState包含在了performSaveInstanceState中，具体的onSaveInstanceState方法如下</p><pre><code>protected void onSaveInstanceState(Bundle outState) {    //1.存储当前窗口的视图树状态，调用的是windoe的实现类phonewindow的方法    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());    //2.存储Fragments的状态    Parcelable p = mFragments.saveAllState();    if (p != null) {        outState.putParcelable(FRAGMENTS_TAG, p);    }    //3.如果用户设置了Activity的ActivityLifecycleCallbacks    //那么调用这些ActivityLifecycleCallbacks的onSaveInstanceState进行存储    getApplication().dispatchActivitySaveInstanceState(this, outState);}</code></pre><p>  上面的方法分为三部分：</p><ol><li>存储窗口的视图树的状态</li><li>存储fragment的状态</li><li>调用Activity的ActivityLifecycleCallbacks的onSaveInstanceState方法进行存储状态</li></ol></li><li><p>下面我们来看第一步，Window的saveHierarchyState由其实现类PhoneWindow的saveHierarchyState方法实现，具体代码如下：</p><pre><code>@Overridepublic Bundle saveHierarchyState() {    Bundle outState = new Bundle();    if (mContentParent == null) {        return outState;    }SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();// 1.调用mContentParent的saveHierarchyState方法，保存当前视图内容，这里存储着整个视图树的内容mContentParent.saveHierarchyState(states);// 将视图树结构放到outState中outState.putSparseParcelableArray(VIEWS_TAG, states);// 2.保存当前界面的中获取的焦点信息View focusedView = mContentParent.findFocus();if (focusedView != null) {    if (focusedView.getId() != View.NO_ID) {        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());    } else {        if (false) {            Log.d(TAG, &quot;couldn&apos;t save which view has focus because the focused view &quot;                    + focusedView + &quot; has no id.&quot;);        }    }}// 3.保存整个面板的状态SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;();savePanelState(panelStates);if (panelStates.size() &gt; 0) {    outState.putSparseParcelableArray(PANELS_TAG, panelStates);}// 4.保存actionbar的状态if (mDecorContentParent != null) {    SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;();    mDecorContentParent.saveToolbarHierarchyState(actionBarStates);    outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);}return outState;</code></pre><p>  }</p></li><li><p>上面方法中分别保存了页面的主要信息，包括UI，actionbar的相关信息。其中这个mContentParent是我们通过Activity的setContentView方法设置的内容视图，它是整个内容视图的根节点，存储了它的层级结构中的view状态，就相当于存储了用户界面的状态。它是一个ViewGroup对象，但这个saveHierarchyState方法是View的一个方法，如下：</p><pre><code>public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) {    // ViewGroup调用的父类View的方法，其父类View用调用此方法存储状态    dispatchSaveInstanceState(container);}</code></pre></li><li><p>View方法没有直接存储，而是调用dispatchSaveInstanceState方法间接存储，这里便是真正存储View的状态了</p><pre><code>protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {    //1.如果View没有id，那么这个view将不会被存储    if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) {        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;        //2.调用onSaveInstanceState获取自身状态（View的默认状态空）        Parcelable state = onSaveInstanceState();        if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {            throw new IllegalStateException(                    &quot;Derived class did not call super.onSaveInstanceState()&quot;);        }        if (state != null) {            // Log.i(&quot;View&quot;, &quot;Freezing #&quot; + Integer.toHexString(mID)            // + &quot;: &quot; + state);            // 3.以key为id，state为value存储到container中            container.put(mID, state);        }    }}</code></pre></li><li><p>View自身的onSaveInstanceState方法</p><pre><code>@CallSuperprotected Parcelable onSaveInstanceState() {    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;    // View类默认的存储状态为空    if (mStartActivityRequestWho != null) {        BaseSavedState state = new BaseSavedState(AbsSavedState.EMPTY_STATE);        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;        return state;    }    return BaseSavedState.EMPTY_STATE;}</code></pre></li><li><p>在View类中的saveHirearchyState方法中调用dispatchSaveInstanceState方法来存储自身的状态，而ViewGroup则覆写了dispatchSaveInstanceState方法来存储自身以及子视图的状态，如下：</p><pre><code>@Overrideprotected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {    //ViewGroup覆写View的dispatchSaveInstanceState方法，保存自身的状态    super.dispatchSaveInstanceState(container);    final int count = mChildrenCount;    final View[] children = mChildren;    for (int i = 0; i &lt; count; i++) {        View c = children[i];        if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) {            c.dispatchSaveInstanceState(container);        }    }}</code></pre></li><li><p>在ViewGroup的dispatchSaveInstanceState方法中，首先调用super.dispatchSaveInstanceState存储自身的状态，然后遍历子视图，调用子视图的dispatchSaveInstanceState方法来存储它们的状态。其中在View的具体保存过程中我们可以看出，只有View设置了唯一性的id，View才会进行记录。此外，在View中我们看到返回的是空状态，这意味着我们需要存储View状态时，需要覆写onSaveInstanceState方法，将要存储的数据放到Parcelable并将它返回。这里我们可以看一下TextView的实现过程：</p><pre><code>@Overridepublic Parcelable onSaveInstanceState() {    Parcelable superState = super.onSaveInstanceState();    // Save state if we are forced to    boolean save = mFreezesText;    int start = 0;    int end = 0;    if (mText != null) {        start = getSelectionStart();        end = getSelectionEnd();        if (start &gt;= 0 || end &gt;= 0) {            // Or save state if there is a selection            save = true;        }    }    //存储TextView的start，end以及文本内容    if (save) {        SavedState ss = new SavedState(superState);        // XXX Should also save the current scroll position!        ss.selStart = start;        ss.selEnd = end;        if (mText instanceof Spanned) {            Spannable sp = new SpannableStringBuilder(mText);            if (mEditor != null) {                removeMisspelledSpans(sp);                sp.removeSpan(mEditor.mSuggestionRangeSpan);            }            ss.text = sp;        } else {            ss.text = mText.toString();        }        if (isFocused() &amp;&amp; start &gt;= 0 &amp;&amp; end &gt;= 0) {            ss.frozenWithFocus = true;        }        ss.error = getError();        if (mEditor != null) {            ss.editorState = mEditor.saveInstanceState();        }        return ss;    }    return superState;}</code></pre></li><li><p>调用View的onSaveInstanceState方法后就得到了View要存储的数据，到这里便执行到了第三步。至此，经过一层层的遍历，整个内容视图树便存储下来了。</p><pre><code>if (state != null) {    // Log.i(&quot;View&quot;, &quot;Freezing #&quot; + Integer.toHexString(mID)    // + &quot;: &quot; + state);    // 3.以key为id，state为value存储到container中    container.put(mID, state);}</code></pre></li><li><p>存储完Window的视图树信息后，便执行存储Fragment的状态信息、回退栈等。这个存储Fragment的状态信息也是调用它的onSaveInstanceState方法，存储Fragment中View视图树状态，最好就是调用用户设置的ActivityLifecycleCallbacks的onSaveInstanceState方法，让用户能够再做一些额外的处理。到这里，整个存储过程就完成了。</p></li></ul><hr><ul><li><p>上面分析了Activity在未知状态下销毁前存储的信息，这些存储的信息都保存在了Bundle数据中，那系统又是如何恢复数据的呢？在Activity被销毁onStop方法执行之前，系统会调用ActivityThread的performStopActivity方法，如下：</p><pre><code>//包含stop方法final void performStopActivity(IBinder token, boolean saveState) {    // 获取ActivityClientRecord对象    ActivityClientRecord r = mActivities.get(token);    // 执行方法，saveState就是表示是否要存储的状态    performStopActivityInner(r, null, false, saveState);}private void performStopActivityInner(ActivityClientRecord r,    StopInfo info, boolean keepShown, boolean saveState) {    if (localLOGV) Slog.v(TAG, &quot;Performing stop of &quot; + r);    if (r != null) {        if (!keepShown &amp;&amp; r.stopped) {            //省略        }        if (info != null) {            try {                info.description = r.activity.onCreateDescription();            } catch (Exception e) {                //省略            }        }        // Next have the activity save its current state and managed dialogs...        if (!r.activity.mFinished &amp;&amp; saveState) {            if (r.state == null) {                // 执行Activity的OnSaveInstanceState函数                callCallActivityOnSaveInstanceState(r);            }        }        if (!keepShown) {            try {                // Now we are idle.                // 执行Activity的OnStop函数                r.activity.performStop();            } catch (Exception e) {               //省略            }            r.stopped = true;        }        r.paused = true;    }}private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) {    r.state = new Bundle();    r.state.setAllowFds(false);    if (r.isPersistable()) {        r.persistentState = new PersistableBundle();        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,                r.persistentState);    } else {        // 调用mInstrumentation的callActivityOnSaveInstanceState函数        // 实际上调用的是Activity的callActivityOnSaveInstanceState函数        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);    } }public void callActivityOnSaveInstanceState(Activity activity, Bundle outState) {    activity.performSaveInstanceState(outState);}</code></pre></li><li><p>在performStopActivity中，通过token获取一个ActivityClientRecord对象，这个对象就保存了Acvtivyt的信息。之后调用performStopActivityInner，其方法执行大致分为4部：<br>（1）判断是否需要存储Activtiy的状态<br>（2）如果需要存储，调用onSaveInstanceState方法<br>（3）将信息存储到ActivityClientRecord对象的stat字段中<br>（4）调用Actvity的onStop方法</p></li><li><p>由上可以知道，在onStop方法执行之前，系统会根据情况选择是否存储Actvity的状态，并且将这些状态保存在mActivities中，这个mActivities维护了一个Activity的信息表，当Activity重启时候，会从mActivities中查询到对应的ActivityClientRecord，如果有信息，则调用Activity的onResoreInstanceState方法，在ActivityThread的performLaunchActivity方法中，具体如下：</p><pre><code> private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {    // 省略    Activity activity = null;    try {        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();        // 1.构建Activity        activity = mInstrumentation.newActivity(                cl, component.getClassName(), r.intent);        //省略    } catch (Exception e) {        //省略    }    try {        // 2.创建一个Application        Application app = r.packageInfo.makeApplication(false, mInstrumentation);        if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);        if (activity != null) {            // 3.创建Context，类型为ContextImpl            Context appContext = createBaseContextForActivity(r, activity);            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());            Configuration config = new Configuration(mCompatConfiguration);            if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;                    + r.activityInfo.name + &quot; with config &quot; + config);            // 4.关联appContext,Application对象到Activity中            activity.attach(appContext, this, getInstrumentation(), r.token,                    r.ident, app, r.intent, r.activityInfo, title, r.parent,                    r.embeddedID, r.lastNonConfigurationInstances, config,                    r.referrer, r.voiceInteractor);            if (customIntent != null) {                activity.mIntent = customIntent;            }            r.lastNonConfigurationInstances = null;            activity.mStartedActivity = false;            int theme = r.activityInfo.getThemeResource();            if (theme != 0) {                activity.setTheme(theme);            }            activity.mCalled = false;            // 5.调用Activity的OnCreate方法            if (r.isPersistable()) {                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);            } else {                mInstrumentation.callActivityOnCreate(activity, r.state);            }            if (!activity.mCalled) {                //省略            }            r.activity = activity;            r.stopped = true;            if (!r.activity.mFinished) {                activity.performStart();                r.stopped = false;            }            // 6.调用Actvity的OnRestoreInstanceState恢复初始状态            if (!r.activity.mFinished) {               //省略            }            if (!r.activity.mFinished) {               //省略            }        }        r.paused = true;        // 将Activity的信息记录对象存到mActivities中        mActivities.put(r.token, r);    } catch (SuperNotCalledException e) {        throw e;    } catch (Exception e) {       //省略    }    return activity;}</code></pre></li><li><p>上面可以看出，系统会判断ActivityClientRecord对象的state是否为空，不为空则通过Activity的onSaveInstanceState获取其UI状态信息，通过这些信息传递给Activity的onCreate方法，使得用户可以在onCreate方法中恢复UI上的状态。</p></li></ul><p><strong>总结</strong><br>以上的分析可以看出，在整个过程中，Activity扮演了CareTaker角色，负责存储、恢复Ui的状态信息；Activity、Fragment、View等对象为Originator角色，也就是扮演存储状态的对象；Memoto则是有Bundle类扮演，单纯的负责数据的支持（容器）。Activit在异常退出时，会根据情况，选择是否需要存储相关状态信息，在重新启动时候，也会根据ActivityClientRecord对象是否存储Activity的状态，选择性的恢复其初始状态。这样下来，就保证了在非正常情况下销毁Activity时不会丢失数据，很好的提升用户体验。</p><h4 id="深度拓展"><a href="#深度拓展" class="headerlink" title="深度拓展"></a>深度拓展</h4><p><a href="https://juejin.im/post/59ca0acaf265da064261df11" target="_blank" rel="noopener">备忘录设计模式实战解析</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 备忘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之备忘录模式</title>
      <link href="/FuckCode/2017/09/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/FuckCode/2017/09/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>是一种行为模式</li><li>用于保存对象当前状态，并在之后恢复到此状态（后悔药） </li><li>需要保证被保存的对象状态不能被外部访问，保证内部完整性，不向外透露</li></ul><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便恢复到原先保存的状态</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><p>需要保存一个对象在某一个时刻的状态或者部分状态</p></li><li><p>如果用一个接口来让其他对象的到这些状态，将会暴露这个对象的实现细节并破坏对象的的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态</p></li></ul><h4 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h4><p><img src="https://user-gold-cdn.xitu.io/2017/10/17/39aa934729d98acc8bf37a629269b236" alt></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li><p>Originator:负责创建一个备忘录，可以记录、恢复自身的内部状态。同事还可以根据需要决定Memento存储自身的那些状态</p></li><li><p>Mement：备忘录角色，用于存储Originator的内部状态，并且可以防止Originator以外的对象访问Memento</p></li><li><p>Caretaker: 负责存储备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象</p></li></ol><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>1.备忘录类，用于记录游戏需要记录的详细信息</p><pre><code>/** * 备忘录类 */public class Memoto {    public int mCheckpoint;    public int mLifeValue;    public String mWeapon;    @Override    public String toString() {        return &quot;Memoto [mCheckpoint=&quot;+mCheckpoint+                &quot; mLifeValue&quot;+mLifeValue+                &quot; mWeapon&quot;+mWeapon+&quot;]&quot;;    }}</code></pre><p>2.创建游戏类（Originator），实现游戏基本逻辑，其内部可以实现备忘录的创建以及获取，但是不实现存储以及恢复的逻辑</p><pre><code>/* * 使命召唤游戏演戏（Originator） */public class CallOfDuty {    private int mCheckpoint = 1;    private int mLifeValue = 100;    private String mWeapon = &quot;沙漠之鹰&quot;;    public void play(){        System.out.println(&quot;打游戏：&quot; + String.format(&quot;第%d关&quot;, mCheckpoint) + &quot;奋战杀敌中&quot;);        mLifeValue -=10;        System.out.println(&quot;进度升级了&quot;);        mCheckpoint++;        System.out.println(&quot;到达&quot;+String.format(&quot;第%d关&quot;, mCheckpoint));    }    public void quit(){        System.out.println(&quot;---------------------&quot;);        System.out.println(&quot;退出前的属性：&quot;+this.toString());        System.out.println(&quot;退出游戏&quot;);        System.out.println(&quot;---------------------&quot;);    }    //创建备忘录    public Memoto createMemoto(){        Memoto memoto = new Memoto();        memoto.mCheckpoint = mCheckpoint;        memoto.mLifeValue = mLifeValue;        memoto.mWeapon = mWeapon;        return memoto;    }    public void restore(Memoto memoto){        this.mCheckpoint = memoto.mCheckpoint;        this.mLifeValue = memoto.mLifeValue;        this.mWeapon = memoto.mWeapon;        System.out.println(&quot;恢复后的游戏属性：&quot;+this.toString());    }    @Override    public String toString() {        return &quot;CallOfDuty [mCheckpoint=&quot;+mCheckpoint+                &quot; mLifeValue&quot;+mLifeValue+                &quot; mWeapon&quot;+mWeapon+&quot;]&quot;;    }}</code></pre><p>3.Caretaker类的创建，实现游戏进度的存档以及恢复逻辑，但是不对实际的游戏数据进行操作</p><pre><code>/** * 负责管理Memoto */public class Caretaker {    //备忘录    Memoto memoto;    //存档    public void archive(Memoto memoto){        this.memoto = memoto;    }    //获取存档    public Memoto getMemoto(){        return memoto;    }}</code></pre><p>4.Main函数的实现</p><pre><code>public class Main {public static void main(String[] args) {    //构建游戏对象    CallOfDuty callOfDuty = new CallOfDuty();    //开始游戏    callOfDuty.play();    //构建caretaker，用于游戏存档    Caretaker caretaker = new Caretaker();    //通过游戏本身创建备忘录，caretaker执行存档操作    caretaker.archive(callOfDuty.createMemoto());    //退出游戏    callOfDuty.quit();    //重新开启游戏，并通过caretaker恢复游戏进度    CallOfDuty callOfDuty1 = new CallOfDuty();    callOfDuty1.restore(caretaker.getMemoto());    }}</code></pre><p>5.运行结果</p><pre><code>打游戏：第1关奋战杀敌中进度升级了到达第2关---------------------退出前的属性：CallOfDuty [mCheckpoint=2 mLifeValue90 mWeapon沙漠之鹰]退出游戏---------------------恢复后的游戏属性：CallOfDuty [mCheckpoint=2 mLifeValue90 mWeapon沙漠之鹰]</code></pre><ul><li>总结：CallOfDuty在这里是Origintor角色，也就是需要存储数据的对象，这里并没有直接存储CallOfDuty对象，而是通过Memoto对CallOfDuty对象的数据进行存储，然后在存储Memoto对象，最终对Memoto对象的存取操作交给Caretaker对象。在整个过程中，对外屏蔽了对CallOfDuty角色的直接访问，满足对象状态存取功能的同时也是的该模块的结构保持清晰、整洁。</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><a href="https://juejin.im/post/59c9a976f265da06434b9a08" target="_blank" rel="noopener">Android源码中备忘录设计模式的实现</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 备忘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/FuckCode/2017/09/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/FuckCode/2017/09/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>只拥有一个全局对象，或者某种类型对象只应该存在一个</li><li>避免产生多个对象耗费过多的资源</li></ul><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li>构造函数不对外开放，一般是private</li><li>通过一个静态方法或者枚举返回单例类对象</li><li>确保单例类的对象有且只有一个，尤其在多线程环境下</li><li>确保单例类对象在反序列化时不会重新构建对象</li></ul><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="https://user-gold-cdn.xitu.io/2017/10/17/54ded6ce3741548585f3a86961f98997" alt></p><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ol><li>Singleton只有一个实例化对象，内部自己实现</li><li>Client通过Singleton的getInstance方法获取实例对象</li></ol><h3 id="单例模型实例"><a href="#单例模型实例" class="headerlink" title="单例模型实例"></a>单例模型实例</h3><h4 id="公司里面的CEO为例，一个公司可以有几个VP，无数的员工，但是CEO只有一个"><a href="#公司里面的CEO为例，一个公司可以有几个VP，无数的员工，但是CEO只有一个" class="headerlink" title="公司里面的CEO为例，一个公司可以有几个VP，无数的员工，但是CEO只有一个"></a>公司里面的CEO为例，一个公司可以有几个VP，无数的员工，但是CEO只有一个</h4><ul><li><p>基类，普通员工</p><pre><code>public class Staff {    public void work(){        //干活    }}</code></pre></li><li><p>副总裁，继承自员工</p><pre><code>public class VP extends Staff {    @Override    public void work() {        //管理下面的经理    }}</code></pre></li><li><p>单例方式的恶汉模式，在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快</p><pre><code>public class CEO extends Staff {    private static final CEO mCeo = new CEO();    //构造函数私有    public CEO() {    }    //共有的静态函数，对外暴露湖区单例对象的接口    public static CEO getCeo(){        return mCeo;    }    @Override    public void work() {        //管理VP    }}</code></pre></li><li><p>公司类</p><pre><code>public class Company {    private List&lt;Staff&gt; allStaffs = new ArrayList&lt;Staff&gt;();    public void addStaff(Staff per) {        allStaffs.add(per);    }    public void showAllStaffs() {        for (Staff per : allStaffs) {            System.out.println(&quot;Obj : &quot; + per.toString());        }    }}</code></pre></li><li><p>测试函数</p><pre><code>public class Main {    public static void main(String[] args) {        Company company = new Company();        //CEO对象只能通过getCeo函数获取        CEO ceo1 = CEO.getCeo();        CEO ceo2 = CEO.getCeo();        company.addStaff(ceo1);        company.addStaff(ceo2);        //通过new创建VP对象        VP vp1 = new VP();        VP vp2 = new VP();        company.addStaff(vp1);        company.addStaff(vp2);        //通过new创建Staff对象        Staff staff1 = new Staff();        Staff staff2 = new Staff();        company.addStaff(staff1);        company.addStaff(staff2);        //通过打印，判断对象是否统一        company.showAllStaffs();    }}</code></pre></li><li><p>懒汉模式实现单例，在类加载时，不创建实例，因此类加载速度快，但运行时获取对象的速度慢</p></li></ul><pre><code>public class CEO1 extends Staff {      private static CEO1 ceo1 = null;    public CEO1() {    }    public static synchronized CEO1 getCeo1() {        if (ceo1 == null) {            ceo1 = new CEO1();        }        return ceo1;    }    @Override    public void work() {        //管理VP    }}</code></pre><p><em>在一定程度上节约了资源，但在第一次加载时需要及时进行实例化，反应稍慢，最大的问题是在每次调用getCeo时候都进行同步，造成不必要的开支</em></p><ul><li><p>Double CheckLock(DCL)–双重检查锁定，实现单例</p><pre><code>public class CEO2 extends Staff {    private volatile static CEO2 mCeo2 = null;    public CEO2() {}    public static CEO2 getmCeo2(){        if (mCeo2 == null){            synchronized (CEO2.class){                if (mCeo2 == null){                    mCeo2 = new CEO2();                }            }        }        return mCeo2;    }}</code></pre></li></ul><p><em>DCL优点是资源利用率高，缺点是由于Java编译器允许处理器乱序执行，以及JDK1.5之前的Java内存模型回写顺序规定，会造成DCL小几率失效问题</em></p><ul><li><p>静态内部类实现单例模式</p><pre><code>public class CEO3 extends Staff{    public CEO3() {}    public static CEO3 getCeo3(){        return CEO3Holder.mCeo3;    }    /**     * 静态内部类     */    private static class CEO3Holder{        private static final CEO3 mCeo3 = new CEO3();    }}</code></pre></li></ul><p><em>静态内部类不仅能够保证线程安全，也能够保证对象的唯一性</em></p><ul><li><p>枚举实例的创建是线程安全的，并且在任何情况下都是一个单例，即使反序列化（不用重写readResolve方法）也不会重新生成实例</p><pre><code>public enum CEO4Enum {    CEO4;    public void doSomething(){        System.out.println(&quot;do sth.&quot;);    }}</code></pre></li><li><p>使用容器实现单例模式</p><pre><code>public class CEOManager {    private static Map&lt;String, Object&gt; mCeo = new HashMap&lt;&gt;();    public static void registerService(String key, Object ceo){        if (!mCeo.containsKey(key)){            mCeo.put(key,ceo);        }    }    public static Object getService(String key){        return mCeo.get(key);    }}</code></pre></li></ul><p><em>在程序的初始化中，将多种单例类型注入到统一的管理类中，通过key获取对象对应类型的对象</em></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk切换说明</title>
      <link href="/FuckCode/2017/09/22/%E5%88%87%E6%8D%A2jdk%E7%89%88%E6%9C%AC/"/>
      <url>/FuckCode/2017/09/22/%E5%88%87%E6%8D%A2jdk%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="切换jdk版本"><a href="#切换jdk版本" class="headerlink" title="切换jdk版本"></a>切换jdk版本</h3><ol><li><p>命令行 sudo gedit ~/.bashrc</p><pre><code># for oracle-jdk1.8# export JAVA_HOME=/home/allies/Software/Java/jdk1.8# for openjdk1.7# export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH={JAVA_HOME}/bin:$PATH# source ~/.bashrc</code></pre></li><li><p>修改export JAVA_HOME选项，根据上面注释的内容修改即可</p></li><li>保存文档</li><li>命令行source ~/.bashrc即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 切换jdk </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
